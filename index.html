<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bg-shorthand.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="bg-shorthand-blog">
<meta property="og:url" content="http://bg-shorthand.github.io/index.html">
<meta property="og:site_name" content="bg-shorthand-blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="bg-shorthand">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://bg-shorthand.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>bg-shorthand-blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bg-shorthand-blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/17/201218-%EB%B0%B0%EC%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/201218-%EB%B0%B0%EC%97%B4/" class="post-title-link" itemprop="url">201218-배열</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-17 12:35:25 / Modified: 12:35:41" itemprop="dateCreated datePublished" datetime="2020-12-17T12:35:25+09:00">2020-12-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h1><ul>
<li>여러 개의 값을 순차적으로 나열한 자료 구조.</li>
<li>요소: 배열이 가지고 있는 값(객체, 함수, 배열 등 자바스크립트에서 값으로 인정하는 모든 것이 들어갈 수 있다.)</li>
<li>인덱스: 배열에서 요소의 위치(0부터 시작)</li>
<li>요소에 접근할 때는 대괄호 표기법을 사용한다.</li>
<li>배열은 배열의 길이를 나타내는 length 프로퍼티를 갖는다.</li>
<li>인덱스와 length 프로퍼티를 갖기 때문에, for문으로 순차적으로 요소에 접근할 수 있다.</li>
<li>배열은 객체 타입이다.</li>
<li>배열은 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다.</li>
<li>Array.prototype이 배열을 위한 빌트인 메서드를 가지고 있다.<h1 id="자바스크립트의-배열"><a href="#자바스크립트의-배열" class="headerlink" title="자바스크립트의 배열"></a>자바스크립트의 배열</h1></li>
<li>자료 구조에서 말하는 배열은, 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. -&gt; 밀집 배열.</li>
<li>이러한 배열은 인덱스를 통해 효율적으로 요소에 접근할 수 있다는 장점이 있다.</li>
<li>하지만 처음부터 끝까지 검색을 하는, ‘선형 검색’을 해야 한다는 단점.</li>
<li>또한 배열의 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점.</li>
<li>그런데 자바스크립트의 배열은,</li>
<li>일반적인 배열의 동작을 흉내 낸 특수한 객체다.</li>
<li>자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티로 가지며, length 프로퍼티를 갖는 특수한 객체다. -&gt; 인덱스가 사실 프로퍼티 키. 요소는 프로퍼티 값.</li>
<li>일반적인 배열보다 성능적인 면에서 느릴 수밖에 없지만,</li>
<li>특정 요소를 검색하거나 요소를 삽입 삭제하는 경우에는 빠른 성능을 기대할 수 있다.<h1 id="length-프로퍼티와-희소-배열"><a href="#length-프로퍼티와-희소-배열" class="headerlink" title="length 프로퍼티와 희소 배열"></a>length 프로퍼티와 희소 배열</h1><h1 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h1></li>
</ul>
<ol>
<li>배열 리터럴</li>
<li>Array 생성자 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; new Array(10);</span><br></pre></td></tr></table></figure>
<ul>
<li>전달된 인수가 1개이고 숫자인 경우 인수를 length 프로퍼티 값으로 가진 배열을 생성.</li>
<li>이 때 생성된 배열은 요소가 없는 희소 배열.</li>
<li>인수가 없는 경우 빈 배열.</li>
<li>전달된 인수가 둘 이상이거나 숫자가 아닌 경우, 각각을 요소로 갖는 배열 생성.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; -&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
<li>new 연산자와 함께 호출하지 않더라도, 배열을 생성하는 생성자 함수로 동작한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(1, 2, 3); &#x2F;&#x2F; -&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.of<ul>
<li>인수를 요소로 갖는 배열을 생성. Array()와 달리 1개의 인수만 전달해도 요소로 생성.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(1); &#x2F;&#x2F; -&gt; [1]</span><br><span class="line">Array.of(1, 2, 3); &#x2F;&#x2F; -&gt; [1, 2, 3]</span><br><span class="line">Array.of(&#39;string&#39;); &#x2F;&#x2F; -&gt; [&#39;string&#39;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.from<ul>
<li>유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달받아 배열로 변환하여 반환한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 2, 0: &#39;a&#39;, 1: &#39;b&#39; &#125;); &#x2F;&#x2F; -&gt; [&#39;a&#39;, &#39;b&#39;]</span><br><span class="line">Array.from(&#39;Hello&#39;); &#x2F;&#x2F; -&gt; [&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span><br></pre></td></tr></table></figure></li>
<li>두번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.form(&#123; length: 3&#125;, (_, i) &#x3D;&gt; i); &#x2F;&#x2F; [0, 1, 2]</span><br></pre></td></tr></table></figure></li>
<li>두번째 인수로 전달된 ‘콜백 함수의 첫번째 인수’는 순차적으로 도는 배열의 요소.</li>
<li>두번째 인수는 인덱스.<h1 id="배열-요소의-참조"><a href="#배열-요소의-참조" class="headerlink" title="배열 요소의 참조"></a>배열 요소의 참조</h1><h1 id="배열-요소의-추가와-갱신"><a href="#배열-요소의-추가와-갱신" class="headerlink" title="배열 요소의 추가와 갱신"></a>배열 요소의 추가와 갱신</h1></li>
</ul>
</li>
</ol>
<ul>
<li>인덱스가 아닌 프로퍼티 키로 추가된 배열의 ‘프로퍼티’는 length에 영향을 주지 않는다.</li>
<li>length 는 인덱스가 있는 요소(인덱스만 있는 경우도 제외)만 센다.<h1 id="배열-요소의-삭제"><a href="#배열-요소의-삭제" class="headerlink" title="배열 요소의 삭제"></a>배열 요소의 삭제</h1></li>
<li>배열은 객체이기 때문에 delete 연산자를 사용할 수 있으나, 희소 배열로 만들어 버린다.</li>
<li>splice 메서드 써야지.<h1 id="배열-메서드"><a href="#배열-메서드" class="headerlink" title="배열 메서드"></a>배열 메서드</h1></li>
</ul>
<ol>
<li>Array.isArray<ul>
<li>전달된 인수가 배열이면 true, 아니면 false.</li>
</ul>
</li>
<li>Array.prototype.indexOf<ul>
<li>인수로 전달된 요소를 검색하여 인덱스를 반환한다.</li>
<li>요소가 여러 개 있다면 첫 번째로 검색된 요소의 인덱스를 반환한다.</li>
<li>요소가 존재하지 않으면 -1을 반환한다.</li>
<li>배열에 특정 요소가 존재하는지 확인할 때 유용하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하는지 확인한다.</span><br><span class="line">if (foods.indexOf(&#39;orange&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  &#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하지 않으면 &#39;orange&#39; 요소를 추가한다.</span><br><span class="line">  foods.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foods); &#x2F;&#x2F; [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure></li>
<li>Array.prototype.includes를 사용할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하는지 확인한다.</span><br><span class="line">if (!foods.includes(&#39;orange&#39;)) &#123;</span><br><span class="line">  &#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하지 않으면 &#39;orange&#39; 요소를 추가한다.</span><br><span class="line">  foods.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foods); &#x2F;&#x2F; [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.push<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다.</li>
<li>push 메서드를 사용하지 않고 length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가할 수도 있다. 이 방법이 push 메서드보다 빠르다.</li>
<li>push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 push 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 마지막에 요소를 추가할 수 있으며 부수 효과도 없다. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 스프레드 문법</span><br><span class="line">const newArr &#x3D; [...arr, 3];</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.pop<ul>
<li>원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. pop 메서드는 원본 배열을 직접 변경한다.</li>
</ul>
</li>
<li>Array.prototype.unshift<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. unshift 메서드는 원본 배열을 직접 변경한다.</li>
<li>unshift 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 unshift 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 선두에 요소를 추가할 수 있으며 부수 효과도 없다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 스프레드 문법</span><br><span class="line">const newArr &#x3D; [3, ...arr];</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; [3, 1, 2]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.shift<ul>
<li>shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. shift 메서드는 원본 배열을 직접 변경한다.</li>
</ul>
</li>
<li>Array.prototype.concat<ul>
<li>인수로 전달된 값들(배열 또는 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다. 원본 배열은 변경되지 않는다.</li>
<li>push와 unshift 메서드는 원본 배열을 직접 변경하지만 concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.</li>
<li>인수로 전달받은 값이 배열인 경우 push와 unshift 메서드는 배열을 그대로 원본 배열의 마지막/첫 번째 요소로 추가하지만 concat 메서드는 인수로 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다.</li>
</ul>
</li>
<li>Array.prototype.splice<ul>
<li>세 개의 매개변수를 받는다.</li>
<li>(요소를 제거하기 시작할 인덱스, 제거할 요소의 개수(옵션), 제거한 위치에 삽입할 요소 목록(옵션))</li>
<li>첫번째 요소가 음수인 경우, 배열의 끝에서부터.</li>
</ul>
</li>
<li>Array.prototype.slice<ul>
<li>인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. </li>
<li>두 개의 매개변수를 받는다.</li>
<li>(복사를 시작할 인덱스, 복사를 종료할 인덱스)</li>
<li>종료할 인덱스에 해당하는 요소는 복사되지 않는다. 두번째 인수는 생략 가능하며, 기본값은 length 프로퍼티 값이다.(생략시 다 복사된다.)</li>
<li>첫번째 인수가 음수인 경우, 배열의 끝에서부터 요소를 복사한다.</li>
<li>인수를 모두 생략하면 원본 전체를 복사한다.</li>
<li>이 때는 얕은 복사.</li>
<li>복사본을 생성하는 것을 이용하여, 유사 배열 객체를 배열로 변환할 수 있다.</li>
<li>Array.from 메서드를 사용하면 더욱 간단하지.</li>
</ul>
</li>
<li>prototype.join<ul>
<li>원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열, 즉 구분자(separator)로 연결한 문자열을 반환한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.join(); &#x2F;&#x2F; -&gt; &#39;1,2,3,4&#39;;</span><br><span class="line">arr.join(&#39;&#39;); &#x2F;&#x2F; -&gt; &#39;1234&#39;</span><br><span class="line">arr.join(&#39;:&#39;); &#x2F;&#x2F; -&gt; &#39;1:2:3:4&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.reverse<ul>
<li>원본 배열의 순서를 반대로 뒤집는다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다.</li>
</ul>
</li>
<li>Array.prototype.fill<ul>
<li>인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다. 이때 원본 배열이 변경된다.</li>
<li>두 번째 인수로 요소 채우기를 시작할 인덱스를 전달할 수 있다.</li>
<li>세 번째 인수로 요소 채우기를 멈출 인덱스를 전달할 수 있다.</li>
<li>fill 메서드로 요소를 채울 경우 모든 요소를 하나의 값만으로 채울 수밖에 없다는 단점이 있다. 하지만 Array.from 메서드를 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 요소값을 만들면서 배열을 채울 수 있다.</li>
</ul>
</li>
<li>Array.prototype.includes<ul>
<li>배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다.</li>
<li>(검색할 대상, 검색을 시작할 인덱스)</li>
<li>인수로 전달된 요소를 검색하여 인덱스를 반환하는 indexOf 메서드를 사용하여도 배열 내에 특정 요소가 포함되어 있는지 확인할 수 있다. 하지만 indexOf 메서드를 사용하면 반환값이 -1인지 확인해 보아야 하고 배열에 NaN이 포함되어 있는지 확인할 수 없다는 문제가 있다.</li>
</ul>
</li>
<li>Array.prototype.flat<ul>
<li>인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.</span><br><span class="line">[1, [2, [3, [4]]]].flat();  &#x2F;&#x2F; -&gt; [1, 2, [3, [4]]]</span><br><span class="line">[1, [2, [3, [4]]]].flat(1); &#x2F;&#x2F; -&gt; [1, 2, [3, [4]]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.</span><br><span class="line">[1, [2, [3, [4]]]].flat(2); &#x2F;&#x2F; -&gt; [1, 2, 3, [4]]</span><br><span class="line">&#x2F;&#x2F; 2번 평탄화한 것과 동일하다.</span><br><span class="line">[1, [2, [3, [4]]]].flat().flat(); &#x2F;&#x2F; -&gt; [1, 2, 3, [4]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.</span><br><span class="line">[1, [2, [3, [4]]]].flat(Infinity); &#x2F;&#x2F; -&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/15/201216-ES6-%ED%95%A8%EC%88%98%EC%9D%98-%EC%B6%94%EA%B0%80-%EA%B8%B0%EB%8A%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/201216-ES6-%ED%95%A8%EC%88%98%EC%9D%98-%EC%B6%94%EA%B0%80-%EA%B8%B0%EB%8A%A5/" class="post-title-link" itemprop="url">201216-ES6 함수의 추가 기능</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-15 21:12:23 / Modified: 21:12:39" itemprop="dateCreated datePublished" datetime="2020-12-15T21:12:23+09:00">2020-12-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ES6함수의-추가-기능-화살표-함수"><a href="#ES6함수의-추가-기능-화살표-함수" class="headerlink" title="ES6함수의 추가 기능(화살표 함수)"></a>ES6함수의 추가 기능(화살표 함수)</h1><h1 id="함수의-구분"><a href="#함수의-구분" class="headerlink" title="함수의 구분"></a>함수의 구분</h1><ul>
<li>ES6 이전의 함수는 다양한 형태로 호출할 수 있다.<ol>
<li>일반 함수로서 호출</li>
<li>생산자 함수로서 호출</li>
<li>메서드로서 호출</li>
</ol>
</li>
<li>즉, ES6 이전의 함수는 callable 이면서 constructor.</li>
<li>메서드, 콜백 함수 등도 불필요한 프로토타입 객체를 생성한다.</li>
<li>이러한 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분한다.<ol>
<li>일반 함수: constructor, prototype, arguments</li>
<li>메서드: super, arguments</li>
<li>화살표 함수</li>
</ol>
</li>
<li>일반 함수는 함수 선언문이나 함수 표현식으로 정의한 함수를 말하며,</li>
<li>메서드 축약 표현으로 정의된 메서드와 화살표 함수는 non-constructor다.<h1 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h1></li>
<li>ES6이전에는 메서드에 대한 명학한 정의가 없었다.</li>
<li>일반적으로 객체에 바인딩된 함수.</li>
<li>ES6 사양에서는 메서드 축약 표현으로 정의된 함수만을 메서드라고 한다.</li>
<li>non-constructor로, prototype 프로퍼티가 없다.</li>
<li>표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 non-constructor.</li>
<li>ES6 메서드는 내부슬롯 [[Home Object]]를 갖는다.</li>
<li>super참조는 내부슬롯 [[Home Object]]를 사용해 수퍼클래스의 메서드를 참조하므로, ES6 메서드는 super 키워드를 사용할 수 있다.(메서드 축약표현으로 쓰지 않은 메서드는 사용 못함.)</li>
<li>ES6 이전의 방식으로 메서드를 정의하는 것은 사용하지 않는 것이 좋다.<h1 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const multiply &#x3D; (x, y) &#x3D;&gt; x * y;</span><br><span class="line">multiply(2, 3); &#x2F;&#x2F; -&gt; 6</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>화살표 함수 정의<ul>
<li>함수 표현식으로 정의해야 한다.</li>
<li>호출 방식은 기존 함수와 동일하다.</li>
<li>매개변수가 여러 개인 경우 () 안에 매개변수를 선언한다.</li>
<li>매개변수가 한 개인 경우 ()를 생략할 수 있다.</li>
<li>매개변수가 없는 경우, ()를 생략할 수 없다.</li>
<li>함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {}를 생략할 수 있다. 이때 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다.</li>
<li>함수 몸체를 감싸는 중괄호 {}를 생략한 경우 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생한다. 표현식이 아닌 문은 반환할 수 없기 때문이다.</li>
<li>따라서 함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.</li>
<li>객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 ()로 감싸 주어야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const create &#x3D; (id, content) &#x3D;&gt; (&#123; id, content &#125;);</span><br><span class="line">create(1, &#39;JavaScript&#39;); &#x2F;&#x2F; -&gt; &#123;id: 1, content: &quot;JavaScript&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {}를 생략할 수 없다. 이때 반환값이 있다면 명시적으로 반환해야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const sum &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  const result &#x3D; a + b;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>화살표 함수도 일급 객체이므로 Array.prototype.map, Array.prototype.filter, Array.prototype.reduce 같은 고차 함수(Higher-Order Function, HOF)에 인수로 전달할 수 있다. 이 경우 일반적인 함수 표현식보다 표현이 간결하고 가독성이 좋다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map(v &#x3D;&gt; v * 2); &#x2F;&#x2F; -&gt; [ 2, 4, 6 ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>화살표 함수와 일반 함수 차이<ol>
<li>화살표 함수는 non-constructor다.</li>
<li>중복된 매개변수 이름을 선언할 수 없다.</li>
<li>화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.<ul>
<li>화살표 함수 내부에서 this, arguments, super, new.target을 참조하면, 스코프 체인을 통해 상위 스코프를 참조한다.</li>
</ul>
</li>
</ol>
</li>
<li>this<ul>
<li>화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다.</li>
<li>이는 “콜백 함수 내부의 this 문제”, 즉 콜백 함수 내부의 this가 외부 함수의 this와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것이다.</li>
<li>콜백 함수가 일반 함수로서 호출될 경우, 콜백 함수의 this는 전역 객체를 바인딩한다.</li>
<li>이를 해결하기 위해 ES6 이전에는 다음과 같은 방법을 사용했다.<ol>
<li>this를 일단 회피시킨 후에 콜백 함수 내부에서 사용한다.</li>
<li>Function.prototype.bind 메서드를 사용하여 add 메서드를 호출한 prefixer 객체를 가리키는 this를 바인딩한다.</li>
</ol>
</li>
<li>ES6에서는 화살표 함수를 사용하여 “콜백 함수 내부의 this 문제”를 해결할 수 있다.</li>
<li>화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.</li>
<li>콜백 함수를 화살표 함수로 쓰면, 외부 함수와 this가 동일해진다.</li>
<li>만약 화살표 함수의 상위 함수가 다시 화살표 함수면, 스코프 체인을 따라 this를 찾으러 간다.</li>
<li>만약 화살표 함수가 전역 함수라면 화살표 함수의 this는 전역 객체를 가리킨다. 전역 함수의 상위 스코프는 전역이고 전역에서 this는 전역 객체를 가리키기 때문이다.</li>
<li>화살표 함수는 함수 자체의 this 바인딩을 갖지 않기 때문에 Function.prototype.call/apply/bind 메서드를 사용해도 화살표 함수 내부의 this를 교체할 수 없다.</li>
<li>클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있다.</li>
<li>클래스 필드에 할당한 화살표 함수의 상위 스코프는 constructor다. 따라서 sayHi 클래스 필드에 할당한 화살표 함수 내부에서 참조한 this는 constructor 내부의 this 바인딩과 같다. constructor 내부의 this 바인딩은 클래스가 생성한 인스턴스를 가리키므로 sayHi 클래스 필드에 할당한 화살표 함수 내부의 this 또한 클래스가 생성한 인스턴스를 가리킨다.</li>
<li>하지만 클래스 필드에 할당한 화살표 함수는 프로토타입 메서드가 아니라 인스턴스 메서드가 된다. 따라서 메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋다.</li>
</ul>
</li>
<li>super<ul>
<li>화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다.</li>
</ul>
</li>
<li>arguments<ul>
<li>화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 arguments를 참조하면 this와 마찬가지로 상위 스코프의 arguments를 참조한다.</li>
<li>화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 한다.<h1 id="Rest-파라미터"><a href="#Rest-파라미터" class="headerlink" title="Rest 파라미터"></a>Rest 파라미터</h1></li>
</ul>
</li>
</ol>
<ul>
<li>매개변수 이름 앞에 세개의 점 …을 붙여서 정의한 매개변수를 의미한다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(...rest) &#123;</span><br><span class="line">  &#x2F;&#x2F; 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터다.</span><br><span class="line">  console.log(rest); &#x2F;&#x2F; [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure></li>
<li>일반 매개변수와 Rest 파라미터는 함께 사용할 수 있다. 이때 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당된다.</li>
<li>Rest 파라미터는 이름 그대로 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당된다. 따라서 Rest 파라미터는 반드시 마지막 파라미터이어야 한다.</li>
<li>Rest 파라미터는 단 하나만 선언할 수 있다.</li>
<li>Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(...rest) &#123;&#125;</span><br><span class="line">console.log(foo.length); &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">function bar(x, ...rest) &#123;&#125;</span><br><span class="line">console.log(bar.length); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">function baz(x, y, ...rest) &#123;&#125;</span><br><span class="line">console.log(baz.length); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<h1 id="Rest-파라미터와-arguments-객체"><a href="#Rest-파라미터와-arguments-객체" class="headerlink" title="Rest 파라미터와 arguments 객체"></a>Rest 파라미터와 arguments 객체</h1></li>
<li>ES5에서는 함수를 정의할 때 매개변수의 개수를 확정할 수 없는 가변 인자 함수의 경우 매개변수를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받았다.</li>
<li>하지만 arguments 객체는 배열이 아닌 유사 배열 객체이므로 배열 메서드를 사용하려면 Function.prototype.call이나 Function.prototype.apply 메서드를 사용해 arguments 객체를 배열로 변환해야 하는 번거로움이 있었다.</li>
<li>ES6에서는 rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있다.</li>
<li>화살표 함수는 함수 자체의 arguments 객체를 갖지 않으므로, 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 한다.<h1 id="매개변수-기본값"><a href="#매개변수-기본값" class="headerlink" title="매개변수 기본값"></a>매개변수 기본값</h1></li>
<li>ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(x &#x3D; 0, y &#x3D; 0) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>매개변수 기본값은 매개변수에 인수를 전달하지 않은 경우와 undefined를 전달한 경우에만 유효하다.</li>
<li>Rest 파라미터에는 기본값을 지정할 수 없다.</li>
<li>매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티와 arguments 객체에 아무런 영향을 주지 않는다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/13/201214-%ED%81%B4%EB%9E%98%EC%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/201214-%ED%81%B4%EB%9E%98%EC%8A%A4/" class="post-title-link" itemprop="url">201214-클래스</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-13 14:21:36 / Modified: 14:21:52" itemprop="dateCreated datePublished" datetime="2020-12-13T14:21:36+09:00">2020-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h1><h1 id="클래스-정의"><a href="#클래스-정의" class="headerlink" title="클래스 정의"></a>클래스 정의</h1><ul>
<li>class 키워드 사용.</li>
<li>생성자 함수와 마찬가지로, 파스칼 케이스를 사용해 이름을 짓는 게 일반적.</li>
<li>표현식으로 정의할 수 있다 -&gt; 값으로 사용할 수 있다 -&gt; 일급객체다.</li>
<li>클래스 몸체에는 0개 이상의 ‘메서드’만 정의할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 클래스 선언문</span><br><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name; &#x2F;&#x2F; name 프로퍼티는 public하다.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 프로토타입 메서드</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    console.log(&#96;Hi! My name is $&#123;this.name&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 정적 메서드</span><br><span class="line">  static sayHello() &#123;</span><br><span class="line">    console.log(&#39;Hello!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="클래스-호이스팅"><a href="#클래스-호이스팅" class="headerlink" title="클래스 호이스팅"></a>클래스 호이스팅</h1></li>
<li>let/const 키워드로 선언한 변수처럼 호이스팅</li>
<li>동작은 동일한데, 실행 컨텍스트 상에서도 동일한가? 모르겠음.<h1 id="인스턴스-생성"><a href="#인스턴스-생성" class="headerlink" title="인스턴스 생성"></a>인스턴스 생성</h1></li>
<li>클래스는 인스턴스를 생성하는 게 유일한 이유이므로 일반 함수로서 호출이 안 됨.</li>
<li>new 연산자와 함께 호출.<h1 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h1></li>
</ul>
<ol>
<li>constructor<ul>
<li>인스턴스를 생성하고 초기화 하기 위한 메서드.</li>
<li>constructor 이름을 바꿀 수는 없다.</li>
<li>클래스 내에 최대 한 개만 존재할 수 있다.</li>
<li>constructor는 생략할 수 있다. -&gt; 이 경우 인스턴스는 빈 객체.</li>
<li>constructor를 생략하면 클래스에 다음과 같이 빈 constructor가 암묵적으로 정의된다. constructor를 생략한 클래스는 빈 constructor에 의해 빈 객체를 생성한다.</li>
<li>따라서 인스턴스를 초기화하려면 constructor를 생략해서는 안 된다.</li>
<li>생성자 함수와 마찬가지로, 암묵적으로 this를 반환하므로, return은 쓰지 않는다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>근데!</li>
<li>constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. 다시 말해, 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.</li>
<li>이게 무슨 말이냐면,</li>
<li>클래스 정의가 평가되어 함수 객체를 만들 때,</li>
<li>이 때 constructor가 메서드라면 평가를 안하는데,</li>
<li>메서드로 해석하지 않으니까, constructor 동작을 하는 함수 객체도 만든다~</li>
<li>이 말이야?</li>
</ul>
</li>
<li>프로토타입 메서드<ul>
<li>클래스 몸체에 메서드 축약 표현으로 쓴 메서드.</li>
<li>프로토타입의 메서드가 되고, 인스턴스가 상속받아 쓸 수 있다.</li>
<li>즉, 클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 매커니즘이다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 프로토타입 메서드</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    console.log(&#96;Hi! My name is $&#123;this.name&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>정적 메서드<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 정적 메서드</span><br><span class="line">  static sayHi() &#123;</span><br><span class="line">    console.log(&#39;Hi!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="정적-메서드와-프로토타입-메서드의-차이"><a href="#정적-메서드와-프로토타입-메서드의-차이" class="headerlink" title="정적 메서드와 프로토타입 메서드의 차이"></a>정적 메서드와 프로토타입 메서드의 차이</h1></li>
<li>정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다. -&gt; 인스턴스에서 정적 메서드를 상속받을 수 없다.</li>
<li>정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다. -&gt; 인스턴스 생성 없이도 호출할 수 있는 정적 메서드를 지향해야 한다.</li>
<li>정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다. -&gt; this 유무 차이로 간단하게 생각할 수 있다.</li>
</ol>
<ul>
<li>클래스 또는 생성자 함수를 하나의 네임 스페이스로 여기고,</li>
<li>여기에 관련 메서드들을 정적 메서드로 모아두어 사용할 수 있다.</li>
<li>메서드를 구조화.<h1 id="클래스에서-정의한-메서드의-특징"><a href="#클래스에서-정의한-메서드의-특징" class="headerlink" title="클래스에서 정의한 메서드의 특징"></a>클래스에서 정의한 메서드의 특징</h1></li>
</ul>
<ol>
<li>function 키워드를 생략한 메서드 축약 표현을 사용한다.</li>
<li>객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.</li>
<li>암묵적으로 strict 모드로 실행된다. (“20. strict mode” 참고)</li>
<li>for…in 문이나 Object.keys 메서드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며, 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다. (“16. 프로퍼티 어트리뷰트” 참고)</li>
<li>내부 메서드 [[Construct]]를 갖지 않는 non-constructor다. 따라서 new 연산자와 함께 호출할 수 없다. (“17.2.5. constructor와 non-constructor의 구분” 참고)<h1 id="클래스의-인스턴스-생성-과정"><a href="#클래스의-인스턴스-생성-과정" class="headerlink" title="클래스의 인스턴스 생성 과정"></a>클래스의 인스턴스 생성 과정</h1></li>
</ol>
<ul>
<li>생성자 함수의 인스턴스 생성 과정과 유사하다.</li>
</ul>
<ol>
<li>인스턴스 생성과 this 바인딩.</li>
<li>constructor 메서드의 내부 코드가 실행되어 인스턴스 초기화.</li>
<li>인스턴스 반환(암묵적으로 return this)<h1 id="클래스-필드-정의-제안"><a href="#클래스-필드-정의-제안" class="headerlink" title="클래스 필드 정의 제안"></a>클래스 필드 정의 제안</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 클래스 필드 정의</span><br><span class="line">  name &#x3D; &#39;Lee&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person();</span><br><span class="line">console.log(me); &#x2F;&#x2F; Person &#123;name: &quot;Lee&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>클래스 몸체에서 클래스 필드를 정의하는 경우, this에 클래스 필드를 바인딩해서는 안된다. this는 클래스의 constructor와 메서드 내에서만 유효하다.</li>
<li>클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다.</li>
<li>외부의 초기값(인수)으로 클래스 필드를 초기화(프로퍼티 값 설정)해야 할 필요가 있다면 constructor에서 클래스 필드를 초기화해야 한다.</li>
<li>클래스 필드를 통해 메서드를 정의할 수도 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 클래스 필드에 문자열을 할당</span><br><span class="line">  name &#x3D; &#39;Lee&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클래스 필드에 함수를 할당</span><br><span class="line">  getName &#x3D; function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 화살표 함수로 정의할 수도 있다.</span><br><span class="line">  &#x2F;&#x2F; getName &#x3D; () &#x3D;&gt; this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>클래스 필드에 함수를 할당하는 경우, 이 함수는 프로토타입 메서드가 아닌 인스턴스 메서드가 된다.<h1 id="private-필드-정의-제안"><a href="#private-필드-정의-제안" class="headerlink" title="private 필드 정의 제안"></a>private 필드 정의 제안</h1></li>
<li>private 필드의 선두에는 #을 붙여준다. private 필드를 참조할 때도 #을 붙어주어야 한다.</li>
<li>private 필드는 반드시 클래스 몸체에 정의해야 한다. private 필드를 직접 constructor에 정의하면 에러가 발생한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; private 필드 정의</span><br><span class="line">  #name &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; private 필드 참조</span><br><span class="line">    this.#name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static-필드-정의-제안"><a href="#static-필드-정의-제안" class="headerlink" title="static 필드 정의 제안"></a>static 필드 정의 제안</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyMath &#123;</span><br><span class="line">  &#x2F;&#x2F; static public 필드 정의</span><br><span class="line">  static PI &#x3D; 22 &#x2F; 7;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; static private 필드 정의</span><br><span class="line">  static #num &#x3D; 10;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; static 메서드</span><br><span class="line">  static increment() &#123;</span><br><span class="line">    return ++MyMath.#num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="상속에-의한-클래스-확장"><a href="#상속에-의한-클래스-확장" class="headerlink" title="상속에 의한 클래스 확장"></a>상속에 의한 클래스 확장</h1></li>
<li>기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의.</li>
<li>extends 키워드 사용.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(age, weight) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.weight &#x3D; weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat() &#123; return &#39;eat&#39;; &#125;</span><br><span class="line"></span><br><span class="line">  move() &#123; return &#39;move&#39;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 상속을 통해 Animal 클래스를 확장한 Bird 클래스</span><br><span class="line">class Bird extends Animal &#123;</span><br><span class="line">  fly() &#123; return &#39;fly&#39;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bird &#x3D; new Bird(1, 5);</span><br><span class="line"></span><br><span class="line">console.log(bird); &#x2F;&#x2F; Bird &#123;age: 1, weight: 5&#125;</span><br><span class="line">console.log(bird instanceof Bird); &#x2F;&#x2F; true</span><br><span class="line">console.log(bird instanceof Animal); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(bird.eat());  &#x2F;&#x2F; eat</span><br><span class="line">console.log(bird.move()); &#x2F;&#x2F; move</span><br><span class="line">console.log(bird.fly());  &#x2F;&#x2F; fly</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>extends 키워드<ul>
<li>상속을 통해 확장된 클래스를 서브클래스(subclass)라 부르고, 서브클래스에게 상속된 클래스를 수퍼클래스(superclass)라 부른다.</li>
<li>수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인 뿐만이 아니라, 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.</li>
</ul>
</li>
<li>동적 상속<ul>
<li>extends 키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다. 단, extends 키워드 앞에는 반드시 클래스가 와야 한다.</li>
</ul>
</li>
<li>서브클래스의 constructor<ul>
<li>서브클래스에서 constructor를 생략하면 클래스에 다음과 같은 constructor가 암묵적으로 정의된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor(...args) &#123; super(...args); &#125;</span><br></pre></td></tr></table></figure></li>
<li>수퍼클래스와 서브클래스 모두 constructor를 생략하면 빈 객체가 생성된다.</li>
</ul>
</li>
<li>super 키워드<ul>
<li>super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.<ol>
<li>서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야 한다.</li>
<li>서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.</li>
<li>super는 반드시 서브클래스의 constructor에서만 호출한다. 서브클래스가 아닌 클래스의 constructor나 함수에서 super를 호출하면 에러가 발생한다.</li>
</ol>
</li>
<li>super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.<ol>
<li>서브클래스의 프로토타입 메서드 내에서 super.sayHi는 수퍼클래스의 프로토타입 메서드 sayHi를 가리킨다.</li>
<li>super 참조는 클래스의 전유물은 아니다. 객체 리터럴에서도 super 참조를 사용할 수 있다. 단, ES6의 메서드 축약 표현으로 정의된 함수만 가능하다.</li>
<li>서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킨다.</li>
</ol>
</li>
</ul>
</li>
<li>8.6. 상속 클래스의 인스턴스 생성 과정<ol>
<li>서브클래스의 super 호출<ul>
<li>서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 이것이 바로 서브클래스의 constructor에서 반드시 super를 호출해야 하는 이유다.</li>
</ul>
</li>
<li>수퍼클래스의 인스턴스 생성과 this 바인딩<ul>
<li>인스턴스는 수퍼클래스가 생성한 것이다. 하지만 new 연산자와 함께 호출된 클래스가 서브클래스라는 것이 중요하다.</li>
<li>즉, new 연산자와 함께 호출된 함수를 가리키는 new.target은 서브클래스를 가리킨다. 따라서 인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리된다.</li>
</ul>
</li>
<li>수퍼클래스의 인스턴스 초기화<ul>
<li>수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.</li>
</ul>
</li>
<li>서브클래스 constructor로의 복귀와 this 바인딩<ul>
<li>서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용한다.</li>
<li>super가 호출되지 않으면 인스턴스가 생성되지 않으며, this 바인딩도 할 수 없다. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없는 이유가 바로 이 때문이다.</li>
</ul>
</li>
<li>서브클래스의 인스턴스 초기화</li>
<li>인스턴스 반환</li>
</ol>
</li>
<li>표준 빌트인 생성자 함수 확장<ul>
<li>extends 키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.</li>
<li>String, Number, Array와 같은 표준 빌트인 객체도 [[Construct]] 내부 메서드를 갖는 생성자 함수이므로 extends 키워드를 사용하여 확장할 수 있다.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/10/201210-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%A1%9C%EC%A0%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/201210-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%A1%9C%EC%A0%80/" class="post-title-link" itemprop="url">201210-실행 컨텍스트, 클로저</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-10 12:49:10 / Modified: 12:49:28" itemprop="dateCreated datePublished" datetime="2020-12-10T12:49:10+09:00">2020-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h1><h1 id="소스코드의-타입"><a href="#소스코드의-타입" class="headerlink" title="소스코드의 타입"></a>소스코드의 타입</h1><ol>
<li>전역 코드: 전역 변수를 관리하기 위한 전역 스코프 생성. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결 -&gt; 전역 실행 컨텍스트 생성</li>
<li>지역 스코프 생성, 지역 변수, 매개변수, 아규먼츠 객체 관리, 지역 스코프를 스코프 체인에 연결. -&gt; 함수 실행 컨텍스트 생성</li>
<li>eval 코드: 뭐.</li>
<li>모듈 코드: 나중에 보나?<h1 id="소스코드의-평가와-실행"><a href="#소스코드의-평가와-실행" class="headerlink" title="소스코드의 평가와 실행"></a>소스코드의 평가와 실행</h1></li>
<li>실행 전, 소스코드의 평가.<ul>
<li>변수, 함수 등의 선언문만 먼저 실행.</li>
<li>식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록.</li>
</ul>
</li>
<li>실행(런타임)<ul>
<li>참조는 스코프에서 검색해 취득하고,</li>
<li>변수 값이 변경과 같은 실행 결과는 다시 스코프에 등록.<h1 id="실행-컨텍스트의-역할"><a href="#실행-컨텍스트의-역할" class="headerlink" title="실행 컨텍스트의 역할"></a>실행 컨텍스트의 역할</h1></li>
</ul>
</li>
</ol>
<ul>
<li>코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</li>
<li>즉,<ol>
<li>식별자를 스코프에 따라 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.</li>
<li>스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다.</li>
<li>현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</li>
</ol>
</li>
<li>이 일을 하는 게 실행 컨텍스트.</li>
<li>식별자를 등록, 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘이다.</li>
<li>식별자와 스코프는 실행 컨텍스트의 ‘렉시컬 환경’으로 관리.</li>
<li>코드 실행 순서는 ‘실행 컨텍스트 스택’으로 관리<h1 id="실행-컨텍스트-스택"><a href="#실행-컨텍스트-스택" class="headerlink" title="실행 컨텍스트 스택"></a>실행 컨텍스트 스택</h1></li>
<li>스택 자료구조.(선입후출)</li>
<li>실행되는 실행 컨텍스트가 추가(push), 실행 끝나면 삭제(pop).</li>
<li>전역 코드와 함수 코드로 구분되어서 진행 되고,</li>
<li>각 코드는 실행 전에 평가 단계를 거친다.</li>
<li>선입후출 구조로, 나중에 실행된 코드가 종료되면, 이전에 실행되던 코드로 돌아간다.</li>
<li>스택의 최상위에 존재하는 실행 컨텍스트가 현재 진행 중인 코드의 실행 컨텍스트. 이걸 ‘실행 중인 실행 컨텍스트’라고 부른다.<h1 id="렉시컬-환경"><a href="#렉시컬-환경" class="headerlink" title="렉시컬 환경"></a>렉시컬 환경</h1></li>
<li>식별자와 식별자에 비인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조.</li>
<li>즉, 식별자와 스코프를 관리한단 거지.</li>
<li>두 개를 관리해야 하네? 두 개의 컴포넌트.<ol>
<li>환경 레코드: 식별자를 등록하고 식별자에 바인딩된 값을 구분하는 저장소.</li>
<li>외부 렉시컬 환경에 대한 참조: 단방향 링크드 리스트인 스코프 체인 구현.<h1 id="실행-컨텍스트의-생성과-식별자-검색-과정"><a href="#실행-컨텍스트의-생성과-식별자-검색-과정" class="headerlink" title="실행 컨텍스트의 생성과 식별자 검색 과정"></a>실행 컨텍스트의 생성과 식별자 검색 과정</h1></li>
</ol>
</li>
</ul>
<ol>
<li>전역 객체 생성<ul>
<li>전역 객체는 전역 코드가 평가되기 이전에 생성. 빌트인 전역 프로퍼티/함수/객체 등이 있고, 동작 환경에 따라 호스트 객체를 포함.</li>
<li>이 전역 객체도 Object.prototype을 상속 받는다.</li>
</ul>
</li>
<li>전역 코드 평가<ol>
<li>전역 실행 컨텍스트 생성</li>
<li>전역 렉시컬 환경 생성<ol>
<li>전역 환경 레코드 생성</li>
<li>객체 환경 레코드 생성</li>
<li>선언적 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
<li>전역 코드 실행</li>
<li>(함수 호출을 만나면) 함수 코드 평가<ol>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ol>
<li>함수 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
<li>함수 코드 실행</li>
<li>함수 코드 실행 종료</li>
<li>전역 코드 실행 종료<h1 id="실행-컨텍스트와-블록-레벨-스코프"><a href="#실행-컨텍스트와-블록-레벨-스코프" class="headerlink" title="실행 컨텍스트와 블록 레벨 스코프"></a>실행 컨텍스트와 블록 레벨 스코프</h1></li>
</ol>
<ul>
<li>소스코드는 전역 코드와 함수 코드로 구분하니까,</li>
<li>블록 레벨 스코프의 코드 블록은 따로 실행 컨텍스트를 만들지 않는다.</li>
<li>근데 let/const는 블록 레벨 스코프를 만들잖아?</li>
<li>이를 위해 블록 레벨 스코프는,</li>
<li>선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.</li>
<li>즉, 실행 컨텍스트는 그대로 둔 상태에서,</li>
<li>연결되어 있던 렉시컬 환경을 ‘선언적 환경 레코드를 갖는 렉시컬 환경’으로 교체.</li>
<li>새로 연결된 렉시컬 환경은 기존의 렉시컬 환경을 상위 스코프로 갖는다.</li>
<li>코드 블록이 끝나면, 이전의 렉시컬 환경으로 복귀.</li>
<li>만약 코드 블록 내에 함수가 있다면, 이 함수의 상위 스코프는 코드 블록이 생성한 렉시컬 환경(선언적 환경 레코드를 갖는 렉시컬 환경).</li>
</ul>
<hr>
<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><ul>
<li>중첩 함수에서,</li>
<li>내부 함수가 외부 함수보다 오래 살아남으며,</li>
<li>외부 함수가 갖는 식별자를 내부 함수가 참조할 때,</li>
<li>그 내부 함수를 클로저라고 부른다.<h1 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h1></li>
<li>렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.<h1 id="함수-객체의-내부-슬롯-Envirobnment"><a href="#함수-객체의-내부-슬롯-Envirobnment" class="headerlink" title="함수 객체의 내부 슬롯 [[Envirobnment]]"></a>함수 객체의 내부 슬롯 [[Envirobnment]]</h1></li>
<li>함수 객체는 호출과 상관없이, 자신이 정의된 환경, 상위 스코프를 기억해야 한다.</li>
<li>이를 위해 함수 객체는 함수 정의가 평가 될 때,(런타임 이전에) 내부 슬롯 [[Environment]] 에 상위 스코프의 참조를 저장한다.</li>
<li>이 상위 스코프는 ‘현재 실행 중인 실행 컨텍스트’의 렉시컬 환경이다.</li>
<li>내부 슬롯에 기억하므로, 함수객체가 존재하는 한, 함수는 상위 스코프를 기억한다.</li>
<li>후에 함수가 호출 되어 함수 코드가 평가되기 시작하면,</li>
<li>함수 렉시컬 환경의 구성 요소인 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.<h1 id="클로저와-렉시컬-환경"><a href="#클로저와-렉시컬-환경" class="headerlink" title="클로저와 렉시컬 환경"></a>클로저와 렉시컬 환경</h1></li>
<li>중첩 함수에서, 외부 함수가 실행이 종료 되었을 때,</li>
<li>외부 함수의 실행 컨텍스트는 스택에서 제거되지만, 렉시컬 환경까지 소멸하는 것은 아니다.(가비지 컬렉터가 처리하지 않는다.)</li>
<li>내부 함수의 [[Environment]]에 의해 참조되고 있기 때문.</li>
<li>내부 함수가 다른 곳(변수 등)에서 참조되고 있다면,</li>
<li>외부 함수 없이 내부 함수를 호출할 수 있고, 이 때 외부 함수 객체의 변수에도 접근할 수 있다.</li>
<li>모든 함수는 상위 스코프를 기억하므로, 이론적으로 모든 함수는 클로저지만,</li>
<li>일반적으로 모든 함수를 클로저라고는 하지 않는다.</li>
<li>클로저는,<ol>
<li>상위 스코프의 식별자를 참조한다.</li>
<li>상위 스코프보다 생명 주기가 길다.</li>
</ol>
</li>
<li>를 만족해야 한다.</li>
<li>클로저에 의해 참조되는 상위 스코프의 변수는 ‘자유 변수’.<h1 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h1></li>
<li>클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 카운트 상태 변경 함수</span><br><span class="line">const increase &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저</span><br><span class="line">  return function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 카운트 상태를 1만큼 증가 시킨다.</span><br><span class="line">    return ++num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 2</span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저인 메서드를 갖는 객체를 반환한다.</span><br><span class="line">  &#x2F;&#x2F; 객체 리터럴은 스코프를 만들지 않는다.</span><br><span class="line">  &#x2F;&#x2F; 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F; num: 0, &#x2F;&#x2F; 프로퍼티는 public하므로 은닉되지 않는다.</span><br><span class="line">    increase() &#123;</span><br><span class="line">      return ++num;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrease() &#123;</span><br><span class="line">      return num &gt; 0 ? --num : 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const Counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; ① 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  function Counter() &#123;</span><br><span class="line">    &#x2F;&#x2F; this.num &#x3D; 0; &#x2F;&#x2F; ② 프로퍼티는 public하므로 은닉되지 않는다.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter.prototype.increase &#x3D; function () &#123;</span><br><span class="line">    return ++num;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Counter.prototype.decrease &#x3D; function () &#123;</span><br><span class="line">    return num &gt; 0 ? --num : 0;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return Counter;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const counter &#x3D; new Counter();</span><br><span class="line"></span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure></li>
<li>변수 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 외부 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.</li>
<li>아래의 클로저는, 내용은 같지만 서로 다른 렉시컬 환경을 참조하는 클로저<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수를 인수로 전달받고 함수를 반환하는 고차 함수</span><br><span class="line">&#x2F;&#x2F; 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.</span><br><span class="line">function makeCounter(predicate) &#123;</span><br><span class="line">&#x2F;&#x2F; 카운트 상태를 유지하기 위한 자유 변수</span><br><span class="line">let counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저를 반환</span><br><span class="line">  return function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.</span><br><span class="line">    counter &#x3D; predicate(counter);</span><br><span class="line">    return counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function increase(n) &#123;</span><br><span class="line">  return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function decrease(n) &#123;</span><br><span class="line">  return --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수로 함수를 생성한다.</span><br><span class="line">&#x2F;&#x2F; makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환한다</span><br><span class="line">const increaser &#x3D; makeCounter(increase); &#x2F;&#x2F; ①</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.</span><br><span class="line">const decreaser &#x3D; makeCounter(decrease); &#x2F;&#x2F; ②</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -1</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -2</span><br></pre></td></tr></table></figure></li>
<li>아래와 같이 수정<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수를 반환하는 고차 함수</span><br><span class="line">&#x2F;&#x2F; 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.</span><br><span class="line">const counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태를 유지하기 위한 자유 변수</span><br><span class="line">  let counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 함수를 인수로 전달받는 클로저를 반환</span><br><span class="line">  return function (predicate) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.</span><br><span class="line">    counter &#x3D; predicate(counter);</span><br><span class="line">    return counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function increase(n) &#123;</span><br><span class="line">  return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function decrease(n) &#123;</span><br><span class="line">  return --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수를 전달하여 호출</span><br><span class="line">console.log(counter(increase)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter(increase)); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 자유 변수를 공유한다.</span><br><span class="line">console.log(counter(decrease)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter(decrease)); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<h1 id="캡슐화와-정보-은닉"><a href="#캡슐화와-정보-은닉" class="headerlink" title="캡슐화와 정보 은닉"></a>캡슐화와 정보 은닉</h1></li>
<li>캡슐화(encapsulation)는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉(information hiding)이라 한다.</li>
<li>즉시 실행 함수를 활용하여 생성자 함수와 프로토타입 프로퍼티 추가를 묶음.</li>
<li>이 경우 클로저를 단 한번 생성하기 대문에, 인스턴스가 여러 개 만들어지면 동일한 상위 스코프를 사용하게 된다.</li>
<li>자바스크립트는 정보 은닉을 완전하게 지원하지 않는다. 인스턴스 메서드를 사용한다면 자유 변수를 통해 private을 흉내 낼 수는 있지만 프로토타입 메서드를 사용하면 이마저도 불가능해진다.</li>
<li>클래스에 private 필드를 정의할 수 있는 표준 사양이 제안되어 있는데, 이건 나중에.<h1 id="자주-발생하는-실수"><a href="#자주-발생하는-실수" class="headerlink" title="자주 발생하는 실수"></a>자주 발생하는 실수</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  funcs[i] &#x3D; function () &#123; return i; &#125;; &#x2F;&#x2F; ①</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var j &#x3D; 0; j &lt; funcs.length; j++) &#123;</span><br><span class="line">  console.log(funcs[j]()); &#x2F;&#x2F; ②</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 레벨 스코프 특성으로 인해 for 문의 초기화 문에서 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상.</li>
<li>아래처럼 수정할 수 있는데,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">  funcs[i] &#x3D; (function (id) &#123; &#x2F;&#x2F; ①</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return id;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var j &#x3D; 0; j &lt; funcs.length; j++) &#123;</span><br><span class="line">  console.log(funcs[j]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let을 사용하면 깔금하게 해결.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  funcs[i] &#x3D; function () &#123; return i; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; funcs.length; i++) &#123;</span><br><span class="line">  console.log(funcs[i]()); &#x2F;&#x2F; 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let/const 선언을 사용하면, 블록 레벨 스코프가 적용 되어, for문의 코드 블록이 실행될 때마다 새로운 렉시컬 환경이 만들어진다.</li>
<li>이 때 코드 블록 내에 정의한 함수가 있다면, 이 함수의 상위 스코프는 새로운 렉시컬 환경이 된다.</li>
<li>독립적인 렉시컬 환경을 각각 갖으므로, 식별자의 값을 유지할 수 있다.</li>
<li>단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.</li>
<li>고차 함수를 사용하는 방법도 있는데, 나중에 다시 배움.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/08/201206-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/201206-this/" class="post-title-link" itemprop="url">201206-this</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-08 14:47:18 / Modified: 14:47:31" itemprop="dateCreated datePublished" datetime="2020-12-08T14:47:18+09:00">2020-12-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ul>
<li>객체는 상태를 나타내는 프로퍼티와, 동작을 나타내는 메서드를 묶은 복합적인 자료구조.</li>
<li>그 중에 메서드는, 자신이 속한 객체의 상태(프로퍼티)를 참조하고 변경할 수 있어야 하는데,</li>
<li>그러려면 메서드가 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야지.</li>
<li>그래서 자바스크립트는 this라는 특수한 식별자를 제공한다.</li>
<li>즉, this는 자신이 속한 객체, 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수.</li>
<li>this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프프로퍼티나 메서드를 참조할 수 있다.</li>
<li>this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있는데,</li>
<li>this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.<h1 id="함수-호출-방식과-this-바인딩"><a href="#함수-호출-방식과-this-바인딩" class="headerlink" title="함수 호출 방식과 this 바인딩"></a>함수 호출 방식과 this 바인딩</h1></li>
<li>함수 호출 방식(일반 함수 호출, 메서드 호출, 생성자 함수 호출, Function.prototype.apply/call/bind 메서드에 의한 간접 호출)에 따라 this 바인딩이 결정.</li>
</ul>
<ol>
<li>일반 함수 호출<ul>
<li>전역 객체가 바인딩 된다.</li>
<li>중첩, 콜백 함수도 일반 함수로 호출이 되면 전역 객체에 바인딩.</li>
<li>여기서 중첩, 콜백 함수의 this가 전역 객체를 바인딩하는 것은 문제가 있다.</li>
<li>이 둘은 보통 헬퍼 함수의 역할을 하는데, 외부 함수와 this 바인딩이 다르면 헬퍼 함수 역할을 하기 힘들어.</li>
<li>그래서 이런 식으로 쓰지.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; this 바인딩(obj)을 변수 that에 할당한다.</span><br><span class="line">    const that &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 콜백 함수 내부에서 this 대신 that을 참조한다.</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(that.value); &#x2F;&#x2F; 100</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Function.protytype.apply/call/bind를 쓰기도 해<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 콜백 함수에 명시적으로 this를 바인딩한다.</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(this.value); &#x2F;&#x2F; 100</span><br><span class="line">    &#125;.bind(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>화살표 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.</span><br><span class="line">    setTimeout(() &#x3D;&gt; console.log(this.value), 100); &#x2F;&#x2F; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>메서드 호출<ul>
<li>메서드를 호출한 객체와 바인딩.</li>
<li>메서드를 소유한 객체와 바인딩되는 게 아님.</li>
<li>왜냐면, 메서드를 소유한 객체라는 건, 사실 그 객체의 프로퍼티 키가 독립적으로 존재하는 함수 객체를 바인딩하고 있는 것일 뿐이니까.</li>
<li>이 독립적인 함수 객체는 여러 곳에 바인딩될 수 있어.</li>
<li>변수든, 다른 메서드든.</li>
<li>즉, this 바인딩은 메서드를 소유한 객체와 되는 게 아니라, 메서드를 호출한 객체와 바인딩.</li>
</ul>
</li>
<li>생성자 함수 호출<ul>
<li>생성자 함수가 생성할 인스턴스와 바인딩.</li>
</ul>
</li>
<li>Function.prototype.apply/call/bind 메서드에 의한 간접 호출<ul>
<li>apply, call, bind 메서드는 Function.prototype의 메서드. -&gt; 모든 함수가 상속받아 사용 가능.</li>
<li>Function.prototype.apply, Function.prototype.call 메서드는 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 ‘호출’한다.(호출하려고 쓰는 메서드임.)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getThisBinding() &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; this로 사용할 객체</span><br><span class="line">const thisArg &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span><br><span class="line">&#x2F;&#x2F; apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.</span><br><span class="line">console.log(getThisBinding.apply(thisArg, [1, 2, 3]));</span><br><span class="line">&#x2F;&#x2F; Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">&#x2F;&#x2F; &#123;a: 1&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.</span><br><span class="line">console.log(getThisBinding.call(thisArg, 1, 2, 3));</span><br><span class="line">&#x2F;&#x2F; Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">&#x2F;&#x2F; &#123;a: 1&#125;</span><br></pre></td></tr></table></figure></li>
<li>apply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우.</li>
<li>arguments 객체는 배열이 아닌 유사 배열 객체기 때문에, 배열의 메서드를 사용할 수 없다.</li>
<li>그때, apply나 call을 써서 배열을 전달해주면,</li>
<li>배열 메서드를 쓸 수 있게 할 수 있다.</li>
<li>자세한 내용은 후에 배열을 다루면서.</li>
<li>Function.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다.</li>
<li>bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  foo(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; bind 메서드로 callback 함수 내부의 this 바인딩을 전달</span><br><span class="line">    setTimeout(callback.bind(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.foo(function () &#123;</span><br><span class="line">  console.log(&#96;Hi! my name is $&#123;this.name&#125;.&#96;); &#x2F;&#x2F; Hi! my name is Lee.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/03/201204-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/201204-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/" class="post-title-link" itemprop="url">201204- 함수와 일급 객체, 프로토타입, 빌트인 객체</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-03 20:36:23 / Modified: 20:36:35" itemprop="dateCreated datePublished" datetime="2020-12-03T20:36:23+09:00">2020-12-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h1 id="일급-객체"><a href="#일급-객체" class="headerlink" title="일급 객체"></a>일급 객체</h1><ul>
<li>일급 객체의 조건<ol>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
</ol>
</li>
<li>자바스크립트의 함수는 위의 조건을 모두 만족하므로, 일급 객체다.</li>
<li>객체왈 동일하게 사용할 수 있단 의미이고,</li>
<li>값과 동일하게 취급,</li>
<li>값을 사용하는 곳이라면 어디든지 리터럴로 정의 가능,</li>
<li>런타임에 함수 객체로 평가.</li>
<li>객체와 같지만, 일반 객체에는 없는 함수 고유의 프로퍼티를 갖는다.<h1 id="함수-객체의-프로퍼티"><a href="#함수-객체의-프로퍼티" class="headerlink" title="함수 객체의 프로퍼티"></a>함수 객체의 프로퍼티</h1></li>
<li>arguments, caller, length, name, propotype.</li>
<li>특히, __proto__는 접근자 프로퍼티로, Object.prototype 객체의 프로퍼티를 상속 받은 것.</li>
<li>Object.prototype의 프로퍼티로 모든 객체가 사용할 수 있다.(프로토타입)</li>
</ul>
<ol>
<li>arguments: 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한(이터러블iterable) 유사 배열 객체. 인수를 프로퍼티 값으로 가지며, 프로퍼티 키는 인수의 순서. length프로퍼티는 인수의 개수, callee 프로퍼티는 arguments 객체를 생성한 함수, 즉 자기 자신. 가변 인자 함수를 구현할 때 유용하다.</li>
<li>caller: 함수 자신을 호출한 함수. 사양에 포함되지 않은 비표준 프로퍼티이며, 앞으로 표준화 예정도 없다.</li>
<li>length: 함수를 정의할 때 선언한 매개변수의 개수.</li>
<li>name: 함수 이름. 익명 함수 표현식의 경우, ES5에서는 빈 문자열. ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.</li>
<li><strong>proto</strong>: [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 ‘접근자 프로퍼티’. </li>
<li>ptrototype: constructor 함수만 갖는 프로퍼티로, 함수가 객체를 생성하는 생성자 함수로 호출될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</li>
</ol>
<hr>
<h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><ul>
<li>자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어.</li>
<li>ES6부터 도입된 클래스. 새로운 객체 생성 메커니즘이다.<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1></li>
<li>실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도.</li>
<li>실체는 특징이나 성질을 나타내는 속성(attribute/property)을 가지고 있고, 이를 통해 실체를 인식, 구분.</li>
<li>이러한 방식으로, 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현하는 것이 추상화.</li>
<li>이 추상화를 통해 객체를 다른 객체와 구별할 수 있다.</li>
<li>즉, 객체는 여러 개의 값(속성)을 하나의 단위로 구성한 복합적인 자료구조.</li>
<li>객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.</li>
<li>이 때,</li>
<li>객체의 속성은 상태(프로퍼티), 동작(메서드)로 구분할 수 있다.</li>
<li>이 상태와 동작을 하나의 논리적인 단위로 묶은 게 함수고, 객체는 다른 객체와 메시지를 주고 받거나 데이터를 처리하거나,</li>
<li>다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다.(상속)<h1 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h1></li>
<li>상속은 객체지향 프로그래밍의 핵심 개념(코드의 재사용으로 개발 비용을 줄일 수 있는 잠재력이 있다)으로, 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.</li>
<li>가령, Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, Cicle.prototype의 모든 프로퍼티와 메서드를 상속받는다.</li>
<li>인스턴스에서 공통적으로 사용될 프로퍼티나 메서드를 Circle.prototype에 구현해두면?</li>
<li>모든 인스턴스가 상속받아 사용할 수 있는 거지.<h1 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h1></li>
<li>상속을 구현(목적)으로 사용.</li>
<li>모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값이 프로토타입의 참조.(null인 경우도 있다.)</li>
<li>동시에 프로토타입은 생성자 함수와 연결되어 있다.</li>
<li>생성자 함수 &lt;-&gt; 프로토타입 &lt;- 객체</li>
<li>객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근할 수 있으며,</li>
<li>프로토타입은 자신의 constructor프로퍼티를 통해 생성자 함수에 접근할 수 있고,</li>
<li>생성자 함수는 prototype프로퍼티를 통해 프로토타입에 접근할 수 있다.<h1 id="prototype-접근자-프로퍼티"><a href="#prototype-접근자-프로퍼티" class="headerlink" title="prototype 접근자 프로퍼티"></a><strong>prototype</strong> 접근자 프로퍼티</h1></li>
</ul>
<ol>
<li><strong>proto</strong> 는 접근자 프로퍼티다.<ul>
<li>getter/setter 함수를 통해 프로토타입을 취득하거나 할당.</li>
<li>프로토타입을 부르거나, 교체할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티는 상속을 통해 사용된다.<ul>
<li>기본적으로 __proto__는 Object.prototype의 프로퍼티.</li>
<li>모든 객체의 프로토타입 체인상 끝에는 Object.prototype이 있으므로,</li>
<li>__proto__를 상속받아 사용할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유.<ul>
<li>__proto__은 순환참조를 막도록 구현되어 있다.</li>
<li>단방향 리크드 리스트로 프로토타입 체인을 구현할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.<ul>
<li>직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 만들 수 있다.</li>
<li>이 경우 __proto__를 사용할 수 없으므로,</li>
<li>Object.getPrototypeOf, Object.setPrototypeOf 메서드를 사용한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 취득</span><br><span class="line">Object.getPrototypeOf(obj); &#x2F;&#x2F; obj.__proto__;</span><br><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 교체</span><br><span class="line">Object.setPrototypeOf(obj, parent); &#x2F;&#x2F; obj.__proto__ &#x3D; parent;</span><br></pre></td></tr></table></figure>
<h1 id="함수-객체의-prototype-프로퍼티"><a href="#함수-객체의-prototype-프로퍼티" class="headerlink" title="함수 객체의 prototype 프로퍼티"></a>함수 객체의 prototype 프로퍼티</h1></li>
</ul>
</li>
</ol>
<ul>
<li>생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</li>
<li>화살표 함수와 메서드 축약 표현으로 정의한 메서드는 non-constructor 함수로, prototype 프로퍼티를 가질 이유가 없지.</li>
<li>생성자 함수를 목적으로 만들지 않은 함수도 prototype 프로퍼티를 가지고는 있다. 의미는 없지만.<h1 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h1></li>
<li>prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</li>
<li>프로토타입 체인 상 자식 역할의 객체도 상속받아 사용할 수 있다.<h1 id="리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h1></li>
<li>일단 결론은, Object.prototype을 프로토타입으로 갖는다.</li>
<li>리터럴이 평가 될 때는 추상연산 OrdinaryObjectCreate가 호출되어 객체 등을 만드는데,</li>
<li>프로퍼티 추가 처리 등의 세부 내용은 다르지만,</li>
<li>추상연산을 호출한다는 점에서 Object() 함수를 이용한 방법과 동일하다.</li>
<li>즉, 리터럴로 만든 객체, 함수, 배열, 정규 표현식은 각각 Object, Function, Array, RegExp 생성자 함수로 만든 각각과 같은 프로토타입을 갖는다.<h1 id="프로토타입의-생성-시점"><a href="#프로토타입의-생성-시점" class="headerlink" title="프로토타입의 생성 시점"></a>프로토타입의 생성 시점</h1></li>
<li>생성자 함수가 생성되는 시점과 같다.</li>
<li>즉 생성자 함수가 생성되면 동시에 프로토타입도 준비하는 건데,</li>
<li>생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분할 수 있다.</li>
</ul>
<ol>
<li>사용자 정의 생성자 함수와 프로토타입 생성 시점<ul>
<li>함수 정의가 평가 되어 함수 객체를 생성하는 시점에 프로토타입도 생성.</li>
<li>그게 언제야?</li>
<li>함수 선언문으로 정의된 생성자 함수는 런타임 이전에 평가.</li>
<li>그때 만드는 거지, 뭐.</li>
<li>이렇게 만들어진 프로토타입의 프로토타입은? Object.prototype.</li>
</ul>
</li>
<li>빌트인 생성자 함수와 프로토타입 생성 시점<ul>
<li>모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성.</li>
<li>이 때 같이 만들어지지.</li>
</ul>
</li>
</ol>
<ul>
<li>즉, 프로토타입은 이미 만들어져 준비되어 있는 거다!<h1 id="객체-생성-방식과-프로토타입의-결정"><a href="#객체-생성-방식과-프로토타입의-결정" class="headerlink" title="객체 생성 방식과 프로토타입의 결정"></a>객체 생성 방식과 프로토타입의 결정</h1></li>
<li>어떤 방식이든 추상연산 OrdinaryObjectCreate를 호출하는 건 동일,</li>
<li>이 때 인수로 주어지는 프로토타입이 다른 거야.<h1 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h1></li>
<li>사용자 정의 생성자 함수로 만들어진 프로토타입은 Object.prototype을 프로토타입으로 갖고,</li>
<li>그 생성자 함수로 만든 객체는 그 함수.prototype을 프로토타입으로 가져,</li>
<li>셋은 연결된다.</li>
<li>이게 프로토타입 체인.</li>
<li>객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 그 프로퍼티가 없으면 상위 프로토타입을 따라 가며 찾는다.</li>
<li>Object.prototype은 프로토타입 체인의 종점인데,</li>
<li>여기까지 가서도 찾는 프로퍼티가 없으면 undefined.</li>
<li>프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이다.</li>
<li>앞서 다뤘던 스코프 체인과 비슷하게 움직이는데,</li>
<li>둘은 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용한다.<h1 id="오버라이딩과-프로퍼티-섀도잉"><a href="#오버라이딩과-프로퍼티-섀도잉" class="headerlink" title="오버라이딩과 프로퍼티 섀도잉"></a>오버라이딩과 프로퍼티 섀도잉</h1></li>
<li>상속받아 사용하던 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가했을 때,</li>
<li>프로토타입 프로퍼티에 덮어쓰는 게 아니라, 인스턴스 프로퍼티로 추가.</li>
<li>사용되어지는 것도 인스턴스 프로퍼티.</li>
<li>삭제하면 없어지는 것도 인스턴스 프로퍼티.</li>
<li>이 때, 인스턴스 프로퍼티가 프로토타입 메서드를 ‘오버라이딩’ 했고, 이렇게 가려지는 현상을 ‘프로퍼티 섀도잉’ 이라고 한다.<h1 id="프로토타입의-교체"><a href="#프로토타입의-교체" class="headerlink" title="프로토타입의 교체"></a>프로토타입의 교체</h1></li>
</ul>
<ol>
<li>생성자 함수에 의한 프로토타입의 교체<ul>
<li>프로토타입으로 쓸 객체를 재할당 하면 되지.</li>
<li>이때 교체한 프로토타입에는 constructor 프로퍼티가 없지.</li>
<li>따라서 인스턴스의 생성자 함수를 찾으면 상위의 Object가 나올 거야.</li>
<li>동적 추가로 새 프로토타입에 constructor 프로퍼티를 만들 수 있다.</li>
</ul>
</li>
<li>인스턴스에 의한 프로토타입의 교체<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(me, parent);</span><br><span class="line">&#x2F;&#x2F; 위 코드는 아래의 코드와 동일하게 동작한다.</span><br><span class="line">&#x2F;&#x2F; me.__proto__ &#x3D; parent;</span><br></pre></td></tr></table></figure>
<ul>
<li>이 경우도 새 프로토타입이 constructor가 없지</li>
<li>그건 위와 같지만,</li>
<li>차이는 생성자 함수의 prototype 프로퍼티가 새 프로토타입을 가리키냐 아니냐.</li>
<li>이것도 재설정 할수 있다.(재할당)</li>
</ul>
</li>
</ol>
<ul>
<li>이처럼 프로토타입 교체를 통해 상속 관계를 변경하는 것은 번거롭다.</li>
<li>직접 상속이나 클래스가 편함.<h1 id="instanceof-연산자"><a href="#instanceof-연산자" class="headerlink" title="instanceof 연산자"></a>instanceof 연산자</h1></li>
<li>좌항에 위차한 객체의 프로토타입 체인에, 우변의 생성자 함수가 있으면 트루, 아니먼 펄스.</li>
<li>프로토타입인지를 확인하는 게 아니라, 프로토타입 체인에 존재하는지를 확인한다.<h1 id="직접-상속"><a href="#직접-상속" class="headerlink" title="직접 상속"></a>직접 상속</h1></li>
</ul>
<ol>
<li>Object.create에 의한 직접 상속<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj &#x3D; Object.create(Object.prototype);</span><br></pre></td></tr></table></figure>
<ul>
<li>new 연산자 없이도 객체를 생성할 수 있다.</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다.</li>
<li>객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.</li>
<li>그런데,</li>
<li>const obj = Object.create(null); 처럼 프로토타입 체인의 종점에 해당하는 객체를 만들 수도 있다.</li>
<li>이때 Object.prototype 빌트인 메서드를 사용할 수 없으므로, 빌트인 메서드는 간접적으로 호출해서 써야 하는데,</li>
<li>이 방법은 나중에.</li>
</ul>
</li>
<li>객체 리터럴 내부에서 <strong>proto</strong> 에 의한 직접 상속<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  y: 20,</span><br><span class="line">  &#x2F;&#x2F; 객체를 직접 상속받는다.</span><br><span class="line">  &#x2F;&#x2F; obj → myProto → Object.prototype → null</span><br><span class="line">  __proto__: myProto</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="정적-프로퍼티-메서드"><a href="#정적-프로퍼티-메서드" class="headerlink" title="정적 프로퍼티/메서드"></a>정적 프로퍼티/메서드</h1></li>
</ol>
<ul>
<li>생성자 함수가 가지고 있는 프로퍼티/메서드.</li>
<li>프로토타입에 있는 프로퍼티/메서드가 아니므로, 인스턴스가 참조/호출할 수 없지만,</li>
<li>직접 호출할 수는 있다.</li>
<li>참고로 프로토타입 프로퍼티/메서드를 표기할 때 prototype을 #으로 표기(예를 들어, Object.prototype.isPrototypeOf를 Object#isPrototypeOf으로 표기)하는 경우도 있으니 알아두도록 하자.<h1 id="프로퍼티-존재-확인"><a href="#프로퍼티-존재-확인" class="headerlink" title="프로퍼티 존재 확인"></a>프로퍼티 존재 확인</h1></li>
</ul>
<ol>
<li>in 연산자<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체에 name 프로퍼티가 존재한다.</span><br><span class="line">console.log(&#39;name&#39; in person);    &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<ul>
<li>객체 내 프로퍼티가 존재하는지 여부 확인.</li>
<li>상속받은 모든 프로퍼티를 확인한다.</li>
<li>같은 동작으로<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflect.has(person, &#39;name&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Object.prototype.hasOwnProperty 메서드<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.hasOwnProperty(&#39;name&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li>상속받은 프로퍼티는 빼고, 객체 고유의 프로퍼티인 경우에만 트루.<h1 id="프로퍼티-열거"><a href="#프로퍼티-열거" class="headerlink" title="프로퍼티 열거"></a>프로퍼티 열거</h1></li>
</ul>
</li>
<li>for…in 문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.</span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">  console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name: Lee</span><br><span class="line">&#x2F;&#x2F; address: Seoul</span><br></pre></td></tr></table></figure>
<ul>
<li>in 연산자처럼 상속받은 프로퍼티까지 열거.</li>
<li>단 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false인 경우는 열거 안함.</li>
<li>상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티 만을 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용해서 방어코드 작성.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;,</span><br><span class="line">  __proto__: &#123; age: 20 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">  &#x2F;&#x2F; 객체 자신의 프로퍼티인지 확인한다.</span><br><span class="line">  if (!person.hasOwnProperty(key)) continue;</span><br><span class="line">  console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name: Lee</span><br><span class="line">&#x2F;&#x2F; address: Seoul</span><br></pre></td></tr></table></figure></li>
<li>for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다.</li>
<li>배열에는 for 문이나 for…of 문 또는 Array.prototype.forEach 메서드를 사용하기를 권장. 배열에서 다시.</li>
</ul>
</li>
<li>Object.keys/values/entries 메서드<ul>
<li>객체 자신의 고유 프로퍼티만 열거.</li>
<li>Object.keys: 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.</li>
<li>Object.values: 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.</li>
<li>Object.entries: 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="빌트인-객체"><a href="#빌트인-객체" class="headerlink" title="빌트인 객체"></a>빌트인 객체</h1><h1 id="자바스크립트-객체의-분류"><a href="#자바스크립트-객체의-분류" class="headerlink" title="자바스크립트 객체의 분류"></a>자바스크립트 객체의 분류</h1><ol>
<li>표준 빌트인 객체: ECMAScript 사양에 정의된 객체. 애플리케이션 전역의 공통 기능을 제공. 전역 객체의 프로퍼티로서 제공된다. 따라서, 별도의 선언없이 언제나 참조할 수 있다.</li>
<li>호스트 객체: 자바스크립트 실행 환경이 추가로 제공하는 객체.</li>
<li>사용자 정의 객체: 사용자가 직접 정의한 객체<h1 id="표준-빌트인-객체"><a href="#표준-빌트인-객체" class="headerlink" title="표준 빌트인 객체"></a>표준 빌트인 객체</h1></li>
</ol>
<ul>
<li>Objet, String, Number, Boolean, Symbol, Date, Math, Array 등, 자바스크립트가 제공하는 표준 빌트인 객체.</li>
<li>Math, Reflect, JSON을 제외한 모든 표준 빌트인 객체는 인스턴스를 생성할 수 있다.</li>
<li>인스턴스를 생성할 수 있단 건, 정적 메서드와 프로토타입 메서드를 제공한다는 거지.</li>
<li>아닌 건 정적 메서드만 제공하는 거고.</li>
<li>표준 빌트인 객체가 생성한 인스턴스의 프로토타입은, 그 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.</li>
<li>이 프로토타입이 다양한 프로토타입 메서드를 제공.<h1 id="원시값과-래퍼-객체"><a href="#원시값과-래퍼-객체" class="headerlink" title="원시값과 래퍼 객체"></a>원시값과 래퍼 객체</h1></li>
<li>원시값을 마치 객체처럼 접근할 수 있는데(ex. str.length),</li>
<li>이 때 자바스크립트 엔진은 일시적으로 원시값을 연관된 객체로 변환.</li>
<li>객체로 아주 바꾸는 건 아니고, 할 일 다 하면 버림.</li>
<li>아무튼 이때 생성되는 임시 객체를 ‘래퍼 객체’라 한다.</li>
<li>객체가 되었으니 프로토타입의 메서드를 갖다 쓸 수도 있지.</li>
<li>문자열, 숫자, 불리언, 심벌이 이렇게 움직이는데,</li>
<li>불리언은 쓸 일이 없고, 심벌은 나중에 배움.</li>
<li>그외 null과 undefined는 래퍼 객체를 생성하지 않는다.<h1 id="전역-객체"><a href="#전역-객체" class="headerlink" title="전역 객체"></a>전역 객체</h1></li>
<li>코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.</li>
<li>프로토타입 체인상 최상위는 아님. 당연하지. 프로토타입이 아닌데.<h1 id="빌트인-전역-프로퍼티"><a href="#빌트인-전역-프로퍼티" class="headerlink" title="빌트인 전역 프로퍼티"></a>빌트인 전역 프로퍼티</h1></li>
<li>전역 객체의 프로퍼티.<br>주로 애플리케이션 전역에서 사용하는 값을 제공.</li>
</ul>
<ol>
<li>Infinity</li>
<li>NaN</li>
<li>undefined<h1 id="빌트인-전역-함수"><a href="#빌트인-전역-함수" class="headerlink" title="빌트인 전역 함수"></a>빌트인 전역 함수</h1></li>
</ol>
<ul>
<li>전역 객체의 메서드</li>
<li>전역에서 호출 가능.</li>
</ul>
<ol>
<li>eval<ul>
<li>금지라는데 일아야 하나?</li>
</ul>
</li>
<li>isFinite<ul>
<li>전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환하고, 무한수이면 false를 반환한다.</li>
<li>NaN으로 평가되면 false.</li>
<li>null은 0으로 변환되므로 true.</li>
</ul>
</li>
<li>isNaN<ul>
<li>전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.</li>
</ul>
</li>
<li>parseFloat<ul>
<li>전달받은 문자열 인수를 실수로 해석(parsing)하여 반환.</li>
</ul>
</li>
<li>parseInt<ul>
<li>전달받은 문자열 인수를 정수(integer)로 해석(parsing)하여 반환.</li>
<li>두 번째 인수로 진법을 나타내는 기수(2 ~ 36)를 전달할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#39;10&#39;을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다</span><br><span class="line">parseInt(&#39;10&#39;, 2); &#x2F;&#x2F; -&gt; 2</span><br></pre></td></tr></table></figure></li>
<li>기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메서드(“28.3.8. Number.prototype.toString” 참고)를 사용.</li>
</ul>
</li>
<li>encodeURI / decodeURI<ul>
<li>encodeURI 함수는 완전한 URI(Uniform Resource Identifier)를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.</li>
</ul>
</li>
<li>encodeURIComponent / decodeURIComponent<ul>
<li>encodeURIComponent 함수는 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. <h1 id="암묵적-전역"><a href="#암묵적-전역" class="headerlink" title="암묵적 전역"></a>암묵적 전역</h1></li>
</ul>
</li>
</ol>
<ul>
<li>선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다.</li>
<li>전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다.</li>
<li>변수는 아니므로, 호이스팅은 발생하지 않는다.</li>
<li>단지 프로퍼티니까, delete 연산자로 삭제할 수 있다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/02/201202-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/201202-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/" class="post-title-link" itemprop="url">201202-생성자 함수에 의한 객체 생성</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-02 10:04:52 / Modified: 10:05:14" itemprop="dateCreated datePublished" datetime="2020-12-02T10:04:52+09:00">2020-12-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h1 id="Object-생성자-함수"><a href="#Object-생성자-함수" class="headerlink" title="Object 생성자 함수"></a>Object 생성자 함수</h1><ul>
<li>new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수.</li>
<li>생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; new Object();</span><br></pre></td></tr></table></figure></li>
<li>빈 객체를 생성, 프로퍼티 또는 메소드를 추가하여 객체를 완성.<ul>
<li>String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인(built-in, 내장) 생성자 함수.</li>
</ul>
</li>
<li>객체 리터럴이 더 간편해, 특별한 이유가 없다면 그다지 유용하지 않다.<h1 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h1></li>
<li>객체 리터럴과 달리, 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Who(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.hi &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;hi $&#123;name&#125;!&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Who(han, 32);</span><br><span class="line">const you &#x3D; new Who(park, 31);</span><br></pre></td></tr></table></figure></li>
<li>이런 식.</li>
<li>this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수. 함수를 호출하면서, 어떤 ‘객체’와 바인딩.</li>
<li>위의 경우, 생성자 함수가 생성할 인스턴스와 바인딩된다.</li>
<li>다시 생성자 함수로 돌아가서,</li>
<li>생성자 함수는 일반 함수와 동일한 방법으로 정의된다.</li>
<li>이후 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작.</li>
<li>new 연산자가 없으면 일반 함수로 동작한다.</li>
<li>생성자 함수의 인스턴스 생성 과정(인스턴스 생성, 인스턴스 초기화)<ol>
<li>인스턴스 생성과 this 바인딩<ul>
<li>런타임 이전에 실행.</li>
<li>암묵적으로 빈 객체 생성.</li>
<li>객체는 this에 바인딩(식별자와 값을 연결).</li>
<li>필수.</li>
</ul>
</li>
<li>인스턴스 초기화<ul>
<li>런타임.</li>
<li>함수 몸체가 한 줄씩 실행되며, this에 바인딩되어 있는 인스턴스를 초기화(프로퍼티나 메서드를 추가.)</li>
<li>인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</li>
<li>옵션.(함수 몸체가 비어있을 수 있다. 이 경우 빈 객체 반환.)</li>
</ul>
</li>
<li>인스턴스 반환<ul>
<li>모든 처리가 끝나면 인스턴스(함수로 만들어진 객체)가 바인딩된 this가 암묵적으로 반환.</li>
<li>return 문으로 명시적인 다른 객체를 반환하면 this는 무시.</li>
<li>return 문으로 명시적인 원시값을 반환하면 무시, this 반환.</li>
<li>return 문으로 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손하므로 반드시 생략.<h1 id="내부-메서드-Call-과-Construct"><a href="#내부-메서드-Call-과-Construct" class="headerlink" title="내부 메서드 [[Call]] 과 [[Construct]]"></a>내부 메서드 [[Call]] 과 [[Construct]]</h1></li>
</ul>
</li>
</ol>
</li>
<li>함수는 객체이므로 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가진다.</li>
<li>일반 객체와 달리 호출할 수 있는 건, 함수 객체만이 가진 내부 슬롯과 내부 메서드가 있기 때문.</li>
<li>[[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드 등.</li>
<li>이 때, 함수가 일반 수로 호출되면 [[Call]]이, new 연산자와 함께 생성자 함수로 호출되면 [[Construct]]가 호출된다.</li>
<li>모든 함수는 호출이 가능하므로 [[Call]]을 가지고 있으나,</li>
<li>[[Construct]] 는 생성자 함수만 가지고 있다.</li>
<li>즉, 함수는 constructor 와 non-constructor로 구분할 수 있다.</li>
<li>모든 함수가 생성자 함수로서 호출할 수 있는 것은 아닌 것.<h1 id="constructor와-non-constructor의-구분"><a href="#constructor와-non-constructor의-구분" class="headerlink" title="constructor와 non-constructor의 구분"></a>constructor와 non-constructor의 구분</h1></li>
<li>constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)</li>
<li>non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수</li>
<li>여기서 메서드는, ES6의 메서드 축약 표현만을 의미.</li>
<li>non-constructor 함수는 [[Construct]]가 없으므로, 생성자 함수로 호출하면 에러.</li>
<li>주의할 것은 생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반 함수(callable이면서 constructor)에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것이다.</li>
<li>this 등의 객체를 만들기 위한 내용이 있어야 하는데 없는 애를 데리고 그럴 수 있단 거지.</li>
<li>그럴 때는, 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span><br><span class="line">let inst &#x3D; new add();</span><br><span class="line">&#x2F;&#x2F; 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.</span><br><span class="line">console.log(inst); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체를 반환하는 일반 함수</span><br><span class="line">function createUser(name, role) &#123;</span><br><span class="line">  return &#123; name, role &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span><br><span class="line">inst &#x3D; new createUser(&#39;Lee&#39;, &#39;admin&#39;);</span><br><span class="line">&#x2F;&#x2F; 함수가 생성한 객체를 반환한다.</span><br><span class="line">console.log(inst); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;, role: &quot;admin&quot;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="new-연산자"><a href="#new-연산자" class="headerlink" title="new 연산자"></a>new 연산자</h1></li>
<li>일반 호출일 땐 [[Call]] 호출, new 연산자와 함께 호출할 땐 [[Construct]] 호출.</li>
<li>생성자 함수로 만들어진 함수를 일반 호출하면, 내부의 this는 전역 객체 window와 바인딩.</li>
<li>이로 인해 만들어진 프로퍼티와 메서드는 전역 객체의 프로퍼티와 메서드가 된다.</li>
<li>일반 함수와 생성자 함수는 특별한 형식적 차이가 없으므로, 이름 짓는 방법을 구분한다. 일반적으로 생성자 함수는 첫 문자를 대문자로 기술하는 파스칼 케이스.<h1 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h1></li>
<li>함수를 정의할 때, 이후 호출에 new가 붙을지 안 붙을지 모르잖아?</li>
<li>그걸 확인하는 new.target</li>
<li>new 연산자와 함께 호출되면 new.target은 함수 자신을 가리키고,</li>
<li>일반 함수로 호출되면 new.target은 undefined.</li>
<li>이걸 이용해서 함수가 실행될 때 호출 방법을 확인하고, 재귀 호출로 new 연산자를 붙일 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.</span><br><span class="line">  if (!new.target) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.</span><br><span class="line">    return new Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.</span><br><span class="line">const circle &#x3D; Circle(5);</span><br><span class="line">console.log(circle.getDiameter());</span><br></pre></td></tr></table></figure></li>
<li>IE에서는 지원하지 않아, 스코프 세이프 생성자 패턴을 사용할 수도 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Scope-Safe Constructor Pattern</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고</span><br><span class="line">  &#x2F;&#x2F; this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다.</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다.</span><br><span class="line">  &#x2F;&#x2F; 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다.</span><br><span class="line">  if (!(this instanceof Circle)) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.</span><br><span class="line">    return new Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>프로토타입이랑 instanceof를 모르겠네. 나중에 다시.</li>
<li>아무튼 중요한 건 호출될 때 new가 붙었는지 안붙었는지 확인할 수 있단 건데,</li>
<li>대부분의 빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다.</li>
<li>가령, Object와 Function 은 new가 없이 호출되어도 new가 있는 것과 동일하게 동작.</li>
<li>String, Number, Boolean 생성자 함수는 new 연산자와 함께 호출했을 때 String, Number, Boolean 객체를 생성하여 반환하지만 new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. -&gt; 명시적 타입 변환 때 봤던 거. 이것도 결국 꼼수였네.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/29/201130-let-const%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/29/201130-let-const%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">201130 let, const와 블록 레벨 스코프, 프로퍼티 어트리뷰트</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-29 17:16:06 / Modified: 17:16:27" itemprop="dateCreated datePublished" datetime="2020-11-29T17:16:06+09:00">2020-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록-레벨-스코프"><a href="#let-const와-블록-레벨-스코프" class="headerlink" title="let, const와 블록 레벨 스코프"></a>let, const와 블록 레벨 스코프</h1><h1 id="var-키워드로-선언한-변수의-문제점"><a href="#var-키워드로-선언한-변수의-문제점" class="headerlink" title="var 키워드로 선언한 변수의 문제점"></a>var 키워드로 선언한 변수의 문제점</h1><ol>
<li>변수 중복 선언 허용<ul>
<li>var 키워드로 선언한 변수는 중복 선언을 허용한다.</li>
<li>중복 선언의 경우, 초기화문의 유무에 따라 다르게 동작.</li>
<li>초기화문이 있는 변수 선언문은 자바스크립트에 의해 var 키워드가 없는 것처럼(할당문만 있는 것처럼) 동작하고,</li>
<li>초기화문이 없는 변수 선언문은 무시된다.</li>
<li>변수 중복 선언은 의도치 않게 변수 값이 변경되는 부작용을 낳는다.</li>
</ul>
</li>
<li>함수 레벨 스코프<ul>
<li>var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.</li>
<li>함수 외부(if나 for 문의 블록 안쪽이더라도,)에서 선언한 변수는 모두 전역 변수가 된다.</li>
<li>전역 변수를 남발하게 되고, 중복 선언이 되는 경우가 발생한다.</li>
</ul>
</li>
<li>변수 호이스팅<ul>
<li>호이스팅에 의해 변수 선언문 이전에도 참조할 수 있다.(undefined)</li>
<li>에러는 아니지만, 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.<h1 id="let-키워드"><a href="#let-키워드" class="headerlink" title="let 키워드"></a>let 키워드</h1></li>
</ul>
</li>
</ol>
<ul>
<li>var 키워드의 단점을 보완하기 위해 만들어진 새로운 변수 선언 키워드.</li>
</ul>
<ol>
<li>변수 중복 선언 금지<ul>
<li>중복 선언하면 문법 에러(SyntaxError) 발생.</li>
</ul>
</li>
<li>블록 레벨 스코프</li>
<li>변수 호이스팅<ul>
<li>선언 단계와 초기화 단계가 분리되어 진행.</li>
<li>초기화 단계가 실행되기 이전에 접근하면 참조 에러(ReferenceError). -&gt; 일시적 사각지대.</li>
<li>호이스팅이 일어나지 않는 것은 아니다. 다만 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ul>
</li>
<li>전역 객체와 let<ul>
<li>let 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 아니다.</li>
<li>보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하는데, 이거 뭔지 아직 모름.<h1 id="const-키워드"><a href="#const-키워드" class="headerlink" title="const 키워드"></a>const 키워드</h1></li>
</ul>
</li>
</ol>
<ul>
<li>재할당이 금지됨. -&gt; 값의 불변과 다름.</li>
<li>선언과 동시에 초기화해야 한다. 그렇지 않으면 문법 에러.</li>
<li>재할당이 금지된 것으로, 객체가 할당되었을 경우 값을 변경할 수 있다.<h1 id="var-vs-let-vs-const"><a href="#var-vs-let-vs-const" class="headerlink" title="var vs. let vs. const"></a>var vs. let vs. const</h1></li>
<li>ES6를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.</li>
</ul>
<hr>
<h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><ul>
<li>(객체의) 프로퍼티 각각도 어트리뷰트를 갖고, 객체로 관리된다.<h1 id="내부-슬롯과-내부-메서드"><a href="#내부-슬롯과-내부-메서드" class="headerlink" title="내부 슬롯과 내부 메서드"></a>내부 슬롯과 내부 메서드</h1></li>
<li>자바스크립트 엔진의 구현 알고리즘을 ‘설명’하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티(pseudo property)와 의사 메서드(pseudo method).</li>
<li>예를 들어, 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다.</li>
<li>실제로 그 이름의 내부 슬롯이 있는지는 중요한 게 아니고, 그런 식으로 동작되는 원리가 있다는 게 중요.</li>
<li>원칙적으로 직접 접근할 수 없지만 [[Prototype]] 내부 슬롯의 경우 __proto__를 통해 간접적으로 접근할 수 있다.<h1 id="프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h1></li>
<li>자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</li>
<li>프로퍼티 상태: 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable). -&gt; 자바스크립트 엔진이 프로퍼티를 관리하는 내부 상태 값인 내부 슬롯.</li>
<li>각각에 직접 접근할 수는 없지만, Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyDescriptor(person, &#39;name&#39;));</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure></li>
<li>프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor) 객체. 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터는 undefined.</li>
<li>Object.getOwnPropertyDescriptors는 모든 프로퍼티 어트리뷰트 정보를 제공.(끝에 s. 복수형)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;,</span><br><span class="line">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="데이터-프로퍼티"><a href="#데이터-프로퍼티" class="headerlink" title="데이터 프로퍼티"></a>데이터 프로퍼티</h1></li>
<li>키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.</li>
<li>프로퍼티 어트리뷰트로 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 을 갖는다.</li>
<li>value: 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값. 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다. 이때 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</li>
<li>writable: 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</li>
<li>enumerable: 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티는 for…in 문이나 Object.keys 메서드 등으로 열거할 수 없다.</li>
<li>configurable: 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우 [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. -&gt; 객체 밀봉, 객체 동결.<h1 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h1></li>
<li>자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function)로 구성된 프로퍼티다. getter / setter 함수</li>
<li>프로퍼티 어트리뷰트로 [[Get]], [[Set]], [[Enumerable]], [[Configurable]] 을 갖는다.</li>
<li>get: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수. 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</li>
<li>set: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</li>
<li>객체 안에 접근자 프로퍼티라고 하는 함수가 있고, 이 함수를 통해 프로퍼티를 읽거나 쓸 수 있다.</li>
<li>읽을 때는 getter, 쓸 때는 setter가 쓰인다.<h1 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h1></li>
<li>새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것.</li>
<li>Object.defineProperty<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(person, &#39;firstName&#39;, &#123;</span><br><span class="line">  value: &#39;Ungmo&#39;,</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>정의할 때, 프로퍼티 어트리뷰트를 생략하면, 기본값은 undefined, false.</li>
<li>Object.defineProperties 메서드를 사용하면 여러 개의 프로퍼티를 한 번에 정의할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 데이터 프로퍼티 정의</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    value: &#39;Ungmo&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName: &#123;</span><br><span class="line">    value: &#39;Lee&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 접근자 프로퍼티 정의</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    &#x2F;&#x2F; getter 함수</span><br><span class="line">    get() &#123;</span><br><span class="line">      return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; setter 함수</span><br><span class="line">    set(name) &#123;</span><br><span class="line">      [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="객체-변경-방지"><a href="#객체-변경-방지" class="headerlink" title="객체 변경 방지"></a>객체 변경 방지</h1></li>
<li>프로퍼티 어트리뷰트를 재정의하여, 객체의 변경을 방지할 수 있다.</li>
<li>메서드 제공.</li>
</ul>
<ol>
<li>Object.preventExtensions<ul>
<li>객체 확장 금지.</li>
<li>프로퍼티 추가 금지.(프로퍼티 동적 추가, Object.defineProperty 모두.)</li>
<li>확장 가능한 객체인지 여부는 Object.isExtensible 메서드로 확인할 수 있다.</li>
</ul>
</li>
<li>Object.seal<ul>
<li>객체 밀봉. 읽기와 쓰기만 가능.(열거, 재정의 불가.)</li>
<li>밀봉된 객체인지 여부는 Object.isSealed 메서드로 확인 할 수 있다.</li>
</ul>
</li>
<li>Object.freeze<ul>
<li>객체 동결. 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의, 프로퍼티 값 갱신 금지. -&gt; 읽기만 가능.</li>
<li>동결된 객체인지 여부는 Object.isFrozen 메서드로 확인 할 수 있다.<h1 id="불변-객체"><a href="#불변-객체" class="headerlink" title="불변 객체"></a>불변 객체</h1></li>
</ul>
</li>
</ol>
<ul>
<li>위 세 메서드는 얕은 변경 방지로, 직속 프로퍼티만 변경 방지 되고 중첩 객체까지는 영향을 주지 못한다.(얕은 복사?)</li>
<li>중첩 객체까지 동결하여 불변 객체를 구현하려면, 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(target) &#123;</span><br><span class="line">  &#x2F;&#x2F; 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.</span><br><span class="line">  if (target &amp;&amp; typeof target &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; !Object.isFrozen(target)) &#123;</span><br><span class="line">    Object.freeze(target);</span><br><span class="line">    &#x2F;*</span><br><span class="line">      모든 프로퍼티를 순회하며 재귀적으로 동결한다.</span><br><span class="line">      Object.keys 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.</span><br><span class="line">      (&quot;19.15.2. Object.keys&#x2F;values&#x2F;entries 메서드&quot; 참고)</span><br><span class="line">      forEach 메서드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.</span><br><span class="line">      (&quot;27.9.2. Array.prototype.forEach&quot; 참고)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    Object.keys(target).forEach(key &#x3D;&gt; deepFreeze(target[key]));</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#123; city: &#39;Seoul&#39; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/26/201127-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/201127-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" class="post-title-link" itemprop="url">스코프, 전역 객체의 문제점</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-26 11:22:17 / Modified: 11:22:56" itemprop="dateCreated datePublished" datetime="2020-11-26T11:22:17+09:00">2020-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><ul>
<li>자바스크립트의 스코프는 다른 언어의 스코프와 구별되는 특징이 있어 주의가 필요하다.</li>
<li>모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.</li>
<li>이것이 스코프.</li>
<li>즉, 스코프는 식별자가 유효한 범위.</li>
<li>자바스크립트 엔진의 입장에서 보자면, ‘식별자를 검색할 때 사용하는 규칙’이라고도 볼 수 있다.</li>
<li>자바스크립트 엔진은 코드를 실행할 때 (암묵적 타입 변환 등에서 살펴봤듯이,) 코드의 문맥을 고려한다.</li>
<li>‘코드가 어디서 실행되며 주변에 어떤 코드가 있는지’를 렉시컬 환경이라고 부른다. = 코드의 문맥</li>
<li>이를 구현한 것이 ‘실행 컨텍스트’</li>
<li>그건 나중에 살펴볼 거고, 아무튼,</li>
<li>컴퓨터를 사용할 때 디렉토리가 다르면 같은 이름을 쓸 수 있는 것처럼,</li>
<li>식별자 이름 역시 스코프가 다르면 같은 이름을 사용할 수 있다.</li>
<li>즉, 스코프는 ‘네임스페이스(개체를 구분할 수 있는 범위)’다.</li>
<li>정리.<ol>
<li>식별자의 입장에서, 스코프는 ‘식별자가 유효한 범위’</li>
<li>자바스크립트 엔진의 입장에서, ‘식별자를 검색할 때 사용하는 규칙.’</li>
<li>같은 이름의 식별자를 구분하게 하는 ‘네임 스페이스’</li>
</ol>
</li>
<li>근데, var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용. 개판. let, const는 허용 안함.<h1 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h1></li>
</ul>
<ol>
<li>전역 스코프: 코드의 가장 바깥 영역 -&gt; 전역 변수<ul>
<li>전역 변수는 어디서든지 참조할 수 있다.</li>
</ul>
</li>
<li>지역 스코프: 함수 몸체 내부 -&gt; 지역 변수<ul>
<li>지역은 ‘함수 몸체 내부’</li>
<li>지역에 변수를 선언하면 그 지역을 ‘지역 스코프’로 갖는 ‘지역 변수’가 된다.</li>
<li>지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</li>
<li>상위 지역 스코프는 스코프는 유효하지 않아, 식별자가 같더라도 참조하지 않는다. -&gt; 스코프 체인<h1 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h1></li>
</ul>
</li>
</ol>
<ul>
<li>함수는 중첩이 가능하므로, 지역 역시 중첩이 가능하고, 지역 스코프도 중첩이 됨.</li>
<li>이말인 즉슨, 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 것.</li>
<li>상위 스코프 / 하위 스코프</li>
<li>최상위 스코프는 뭐야? 전역 스코프.</li>
<li>이렇게 스코프가 계층적으로 연결된 것을 ‘스코프 체인’이라고 한다.</li>
<li>스코프 체인은 ‘물리적인 실체’로 존재한다.<ul>
<li>스코프 체인, 렉시컬 환경, 실행 컨텍스트.</li>
<li>이런 자료 구조를 갖추고 관리한다는 말 같은데,</li>
<li>아직은 정확히 몰라.<h1 id="스코프-체인에-의한-변수-함수-검색"><a href="#스코프-체인에-의한-변수-함수-검색" class="headerlink" title="스코프 체인에 의한 변수, 함수 검색"></a>스코프 체인에 의한 변수, 함수 검색</h1></li>
</ul>
</li>
<li>자바스크립트 엔진은 변수를 참조할 때, 변수가 ‘선언’된 위치에서부터 ‘상위’스코프로 이동하며 변수 식별자를 검색한다.</li>
<li>‘상위’스코프로 이동하며 식별자를 검색한다 -&gt; 유효한 스코프는 자신과 하위 스코프다.</li>
<li>상속의 개념으로 생각할 수도 있다.</li>
<li>호이스팅? -&gt; 호이스팅 역시 스코프 단위로 동작한다.</li>
<li>함수의 경우,</li>
<li>자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.(함수 선언문)</li>
<li>그렇다면 똑같지 뭐.</li>
<li>자바스크립트 엔진은 코드 실행 전, 모든 (전역)선언문을 찾는다.<h1 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h1></li>
<li>대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 모든 코드 블록이 지역 스코프를 만든다. 이게 ‘블록 레벨 스코프’.</li>
<li>하지만 var키워드로 선언된 변수는 오로지 함수의 코드블록(함수 몸체)만을 지역 스코프로 인정한다. 이게 ‘함수 레벨 스코프’.<ul>
<li>예를 들어, if문의 코드 블록에서 var키워드로 선언된 변수는 전역 변수.</li>
<li>말만 들어도 개판이네,</li>
<li>let, const 키워드는 블록 레벨 스코프를 지원.<h1 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h1></li>
</ul>
</li>
<li>상위 스코프를 결정하는 두 가지 방식.<ol>
<li>함수를 어디서 ‘호출’ 했는지<ul>
<li>함수를 정의하는 시점에서, 이 함수가 어디서 호출될지 알 수 없다. 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 ‘동적 스코프’.</li>
</ul>
</li>
<li>함수를 어디서 ‘정의’ 했는지<ul>
<li>함수를 정의하는 순간 상위 스코프가 결정되므로 ‘정적 스코프’. 이를 ‘렉시컬 스코프’라고 부른다.</li>
<li>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h1 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1><ul>
<li>전역 변수의 무분별한 사용은 위험.</li>
<li>이름이 중복되기도 쉽고, 그 과정에서 값이 변하기도 할 테고.</li>
<li>전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면, 지역 변수를 사용해야 한다.<h1 id="지역-변수의-생명-주기"><a href="#지역-변수의-생명-주기" class="headerlink" title="지역 변수의 생명 주기"></a>지역 변수의 생명 주기</h1></li>
<li>변수에 생명 주기가 없다면, 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.</li>
<li>어우, 이러면 안 되지.</li>
<li>전역 변수는 애플리케이션이 종료되면 죽고, 함수 내부에서 선언된 지역 변수는 함수가 호출되면 태어났다가 종료하면 죽는다.</li>
<li>함수 몸체의 문들은 함수가 호출되어야만 하나씩 실행되기 때문.</li>
<li>즉, 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치.</li>
<li>스코프, 렉시컬 환경는 물리적 실체가 있는데, 함수가 종료되어도 누군가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존.</li>
<li>지역 변수가 함수보다 더 오래 사는 건데, 클로저가 뭔데.ㅠㅠ<h1 id="전역-변수의-생명-주기"><a href="#전역-변수의-생명-주기" class="headerlink" title="전역 변수의 생명 주기"></a>전역 변수의 생명 주기</h1></li>
<li>전역 코드는 함수 호출과 같이 특별한 진입점이 없으므로 코드가 로드되면 곧바로 해석, 실행.</li>
<li>마지막 문이 실행되면 종료.</li>
<li>var 키워드로 선언한 전역 변수는 이 전역에서, ‘전역 객체’의 프로퍼티가 된다.<ul>
<li>전역 객체: 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체.</li>
<li>클라이언트 사이드 환경(브라우저)에서는 window,</li>
<li>서버 사이드 환경(Node.js)에서는 global 객체를 의마하나,</li>
<li>ES11부터 globalThis로 통일.</li>
<li>이 객체는 프로퍼티로 ‘표준 빌트인 객체’, ‘호스트 객체’, ‘var 키워드로 선언한 전역 변수와 전역 함수’ 등이 있다.</li>
<li>이것도 나중에.</li>
</ul>
</li>
<li>전역 객체는 웹페이지가 닫히면 꺼지고, 전역 변수도 그때 사라져.<h1 id="전역-변수의-문제점-1"><a href="#전역-변수의-문제점-1" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1></li>
</ul>
<ol>
<li>암묵적 결합<ul>
<li>모든 코드가 전역 변수를 참조하고 변경할 수 있는 ‘암묵적 결합’</li>
<li>변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험.</li>
</ul>
</li>
<li>긴 생명 주기<ul>
<li>메모리 리소스도 오랜 기간 소비.</li>
<li>전역 변수의 상태를 변경할 수 있는 시간과 기회도 많아 위험.</li>
<li>이름도 중복될 가능성. -&gt; 의도치 않는 재할당의 위험.</li>
</ul>
</li>
<li>스코프 체인 상에서 종점에 존재<ul>
<li>검색 속도가 가장 느리다.</li>
<li>크진 않지만 차이가 있긴 있어.</li>
</ul>
</li>
<li>네임스페이스 오염<ul>
<li>자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.<h1 id="전역-변수의-사용을-억제하는-방법"><a href="#전역-변수의-사용을-억제하는-방법" class="headerlink" title="전역 변수의 사용을 억제하는 방법"></a>전역 변수의 사용을 억제하는 방법</h1></li>
</ul>
</li>
<li>즉시 실행 함수<ul>
<li>즉시 실행 함수를 통해 스코프를 인위적으로 만들 수도 있지.</li>
</ul>
</li>
<li>네임스페이스 객체<ul>
<li>전역 객체의 역할을 할 객체를 생성할 수 있어.</li>
<li>근데 어차피 네임스페이스 객체도 전역 변수에 할당되는 거잖아?</li>
<li>유용하지 않음.</li>
</ul>
</li>
<li>모듈 패턴<ul>
<li>모듈 패턴을 이해하려면 클로저를 먼저 이해해야 하므로 지금은 클로저라는 기능을 통해 전역 변수를 억제할 수 있다는 데 주목하자.</li>
</ul>
</li>
<li>ES6 모듈<ul>
<li>파일 자체의 독자적인 모듈 스코프를 제공.</li>
<li>모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다. script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다.</li>
<li>IE를 포함한 구형 브라우저에서는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.</li>
<li>후에 다시.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/24/201125-%ED%95%A8%EC%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/201125-%ED%95%A8%EC%88%98/" class="post-title-link" itemprop="url">함수</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-24 14:27:03" itemprop="dateCreated datePublished" datetime="2020-11-24T14:27:03+09:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-26 11:22:35" itemprop="dateModified" datetime="2020-11-26T11:22:35+09:00">2020-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5);</span><br></pre></td></tr></table></figure>
<ul>
<li>일련의 과정을 문(statement)로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.</li>
<li>함수 정의 통해 생성, 함수 호출을 통해 실행.</li>
<li>호출의 인수(argument)가 매개변수(parameter)를 통해 함수 몸체(문)의 과정을 실행하고 결과값 출력.</li>
<li>return이 없거나 값이 없으면, undefined 출력.<h1 id="함수의-사용-이유"><a href="#함수의-사용-이유" class="headerlink" title="함수의 사용 이유"></a>함수의 사용 이유</h1></li>
<li>코드의 재사용.</li>
<li>함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</li>
<li>적절한 함수 이름을 통해 코드의 가독성을 향상.<h1 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h1></li>
<li>자바스크립트의 함수는 객체 타입의 ‘값’이므로, 리터럴로 생성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 이름<ul>
<li>식별자다. 식별자 네이밍 규칙을 준수해야 한다.</li>
<li>함수 몸체 내에서만 참조할 수 있는 식별자다.(밖에서 부르는 식별자를 가지려면 변수 식별자에 할당이 필요하다.)</li>
<li>함수 이름은 생략할 수 있다. 기명함수, 익명 함수.</li>
</ul>
</li>
<li>매개변수 목록<ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고, 쉼표로 구분</li>
<li>각 매개변수에는 지정한 인수가 순서대로 할당. 즉, 매개 변수 목록은 ‘순서’에 의미가 있다.</li>
<li>매개변수는 몸체 내에서 변수와 동일하게 취급.(암묵적으로 선언과 할당을 실행한다.) -&gt; 식별자 네이밍 규칙을 준수해야 한다.</li>
</ul>
</li>
<li>함수 몸체<ul>
<li>실행된 문들을 묶은 코드 블록.</li>
<li>함수 호출에 의해 실행된다.</li>
</ul>
</li>
<li>함수 리터럴도 ‘리터럴’이므로 값으로 평가 가능. 그 값은 ‘객체’이고, 즉, 함수는 객체.</li>
<li>리터럴만 된 코드의 함수를 호출할 수는 없다.(식별자가 없잖아.)</li>
<li>함수 객체 값을 만들기 위한 수단.</li>
<li>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.<h1 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h1></li>
</ul>
<ol>
<li>함수 선언문<ul>
<li>함수 이름을 생략할 수 없다는 것만 빼면 함수 리터럴과 형태가 같다.</li>
<li>차이는 값으로 평가되느냐, 되지 않느냐.</li>
<li>자바스크립트 엔진은 문맥(값이 들어가야 할 자린지 아닌지)에 따라 둘을 구분한다.</li>
<li>함수 선언문의 함수 이름은 자바스크립트 엔진이 암묵적으로 식별자로 생성해 선언, 할당한다.</li>
<li>선언문이므로, 호이스팅된다.</li>
</ul>
</li>
<li>함수 표현식<ul>
<li>자바스크립트의 함수는 객체 타입의 값이므로, 함수를 값처럼 자유롭게 사용할 수 있다.</li>
<li>변수에 함수(리터럴)를 할당하는 모양새.</li>
<li>함수 이름은 생략하는 것이 일반적이다.(호출하는데는 식별자만 변수 식별자만 있으면 되니까.)</li>
<li>호이스팅으로 함수 선언문과 차이를 보인다.</li>
<li>함수를 호출하기 전에 반드시 함수를 선언해야한다는 규칙을, 호이스팅은 무시하므로, 선언문 대신 함수 표현식(var가 아닌)을 사용하는 걸 권장.</li>
</ul>
</li>
<li>Function 생성자 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Function 함수로 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.</li>
<li>클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.</li>
</ul>
</li>
<li>화살표 함수.<ul>
<li>이후 자세히.<h1 id="함수-호출"><a href="#함수-호출" class="headerlink" title="함수 호출"></a>함수 호출</h1><h1 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h1></li>
</ul>
</li>
</ol>
<ul>
<li>인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.</li>
<li>매개변수는 함수 몸체 내부에서만 참조할 수 있다. 즉, 매개변수의 스코프는 함수 내부다.</li>
<li>매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.<ul>
<li>인수가 더 적을 때, 전달되지 않은 매개변수는 undefined.</li>
<li>인수가 더 많을 때, 무시.(버려지는 것처럼 보이지만, 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관.)</li>
</ul>
</li>
<li>인수 확인<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(2));        &#x2F;&#x2F; NaN</span><br><span class="line">console.log(add(&#39;a&#39;, &#39;b&#39;)); &#x2F;&#x2F; &#39;ab&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.</li>
<li>자바스크립트는 동적 타입 언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.</li>
<li>따라서, 의도하지 않은 동작을 할 수도 있다.</li>
<li>이 때, 인수 확인이 필요하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  if (typeof x !&#x3D;&#x3D; &#39;number&#39; || typeof y !&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.</span><br><span class="line">    throw new TypeError(&#39;인수는 모두 숫자 값이어야 합니다.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>타입스크립트를 사용하는 것도 방법.</li>
<li>인수가 전달되지 않은 경우, 단축 평가(or 옵셔널 체이닝 연산자 ?.)를 사용해 매개변수에 기본값을 할당할 수도 있다.</li>
<li>매개변수의 기본값도 사용 가능.<h1 id="매개변수의-최대-개수"><a href="#매개변수의-최대-개수" class="headerlink" title="매개변수의 최대 개수"></a>매개변수의 최대 개수</h1></li>
</ul>
</li>
<li>매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 함수의 사용법을 이해하기 어렵게 만들고 실수를 발생시킬 가능성을 높인다.</li>
<li>또한 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받는다. 즉, 유지보수성이 나빠진다.</li>
<li>이상적인 매개변수 개수는 0개이며 적을 수록 좋다.</li>
<li>매개변수의 개수가 많다는 것은 함수가 여러가지 일을 한다는 증거이므로 바람직하지 않다. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.</li>
<li>매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.</li>
<li>객체를 인수로 전달했을 때, 주의할 것은 부수 효과.<h1 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h1></li>
<li>반환문은 값을 반환하고, 이 값으로 평가되는 함수 호출은 평가식이다.</li>
<li>반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.(이후 문은 무시.)</li>
<li>반환문이 생략되면, 함수 몸체의 마지막 문까지 실행 후, undefined를 반환.</li>
<li>반환문과 뒤의 표현식에 줄바꿈이 있으면 세미콜론이 자동 추가 되어, 아래 쓰인 표현식이 무시된다.<h1 id="참조에-의한-전달과-외부-상태의-변경"><a href="#참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="참조에 의한 전달과 외부 상태의 변경"></a>참조에 의한 전달과 외부 상태의 변경</h1></li>
<li>인수 -&gt; 매개변수 -&gt; 함수 몸체 에서, 원시값은 ‘값에 의한 전달’, 객체는 ‘참조에 의한 전달’</li>
<li>특히 객체를 매개변수로 사용할 경우, 함수 몸체에서 참조값을 통해 객체를 변경할 경우 원본이 훼손된다. -&gt; 부수효과 발생.</li>
<li>이런 변경을 어떻게 추적하겠어.(옵저버 패턴을 통해 객체의 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응?)</li>
<li>이 때, 객체를 불변 객체로 만들어 사용해, 방어적 복사를 통한 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체할 수 있다.</li>
<li>이것도 힘드니까 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는, ‘순수 함수’를 지향하는 게 필요.<h1 id="다양한-함수의-형태"><a href="#다양한-함수의-형태" class="headerlink" title="다양한 함수의 형태"></a>다양한 함수의 형태</h1></li>
</ul>
<ol>
<li>즉시 실행 함수(생성과 동시에 ())<ul>
<li>리터럴을 ()그룹 연산자로 감싼 형태.(값이 들어갈 자리. -&gt; 자바스크립트 엔진이 함수 선언문이 아닌 리터럴로 읽을 수 있도록. -&gt; 다른 연산자도 사용할 수 있지만, 일반적이지 않다.)</li>
<li>감싸지 않으면 엔진이 함수 선언문이라고 읽는다. -&gt; 중괄호 뒤에 세미콜론이 찍히고, -&gt; 뒤의 ()은 그룹 연산자로 읽어, 에러.</li>
<li>즉시 실행하며, 일반 함수처럼 값을 반환할 수 있고, 인수를 전달할 수도 있다.</li>
<li>즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수 있는 변수나 함수 이름의 충동을 방지할 수 있다 -&gt; 전역 변수 사용 억제 방법.</li>
</ul>
</li>
<li>재귀 함수<ul>
<li>함수가 자기 자신을 호출(재귀 호출)할 때, 재귀 호출을 수행하는 함수.</li>
<li>반복되는 처리를 위하 새용한다.</li>
<li>함수 몸체에서, 함수 이름으로 호출한다.</li>
<li>탈출 조건이 반드시 있어야 한다. -&gt; 없으면 스택 오버플로 에러.</li>
<li>따라서, 반복문을 대체할 수 있지만, 주의해서 사용해야 해.</li>
<li>반복문을 사용하는 것보다 직관적으로 이해하기 쉬울 때만 한정적으로 사용.</li>
</ul>
</li>
<li>중첩 함수<ul>
<li>일반적으로 중첩 함수는 외부 함수를 돕는 헬퍼 함수의 역항르 한다.</li>
<li>함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하지만,</li>
<li>호이스팅으로 인해 혼란이 발생할 수 있으므로, if문이나 for문 등의 코드 블록에서 정의하는 것은 바람직하지 않다.</li>
</ul>
</li>
<li>콜백 함수<ul>
<li>함수를 인수로 사용, 매개변수를 통해 함수 안에 함수를(중첩 함수)를 만든다.</li>
<li>공통적으로 수행해야 할 함수(고차함수)에 일부분만 다른 함수들(콜백함수)를 조합해 사용.</li>
<li>고차 함수의 몸체에는 콜백 함수의 호출 시점이 명시.</li>
<li>이 때 필요에 따라 인수를 전달.</li>
<li>콜백 함수가 고차 함수 내부에만 호출된다면, 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.(즉시 실행 함수).</li>
<li>다른 곳에서도 호출할 필요가 있다면, 콜백 함수를 정의한 후, 함수 참조(식별자)를 고차 함수에 전달.</li>
<li>콜백 함수는 비동기 처리, 배열 고차 함수 등에 활용된다.(아직은 뭔지 모름)</li>
</ul>
</li>
<li>순수 함수와 비순수 함수<ul>
<li>순수 함수: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수</li>
<li>비순수 함수:  외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수 -&gt; 외부 상태에 따라 반환값이 달라진다.</li>
<li>함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이라 할 수 있다. 자바스크립트는 멀티 패러다임 언어이므로 객체지향 프로그래밍뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bg-shorthand</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bg-shorthand</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
