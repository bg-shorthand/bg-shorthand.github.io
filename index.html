<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bg-shorthand.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="bg-shorthand-blog">
<meta property="og:url" content="http://bg-shorthand.github.io/index.html">
<meta property="og:site_name" content="bg-shorthand-blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="bg-shorthand">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://bg-shorthand.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>bg-shorthand-blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bg-shorthand-blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/22/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-String-%EB%A9%94%EC%84%9C%EB%93%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-String-%EB%A9%94%EC%84%9C%EB%93%9C/" class="post-title-link" itemprop="url">정규표현식, String 메서드</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-22 14:37:49 / Modified: 14:38:37" itemprop="dateCreated datePublished" datetime="2020-12-22T14:37:49+09:00">2020-12-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="정규-표현식"><a href="#정규-표현식" class="headerlink" title="정규 표현식"></a>정규 표현식</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">let tel &#x3D; &#39;010-1234-567팔&#39;;</span><br><span class="line">let regExp &#x3D; &#x2F;^\d&#123;3&#125;-\d&#123;4&#125;-\d&#123;4&#125;$&#x2F;;</span><br><span class="line">console.log(regExp.test(tel));</span><br><span class="line">&#x2F;&#x2F; &#x2F;regexp&#x2F;i</span><br><span class="line"></span><br><span class="line">let target &#x3D; &#39;Is this all there is?&#39;;</span><br><span class="line">regexp &#x3D; &#x2F;is&#x2F;i;</span><br><span class="line">console.log(regexp.test(target));</span><br><span class="line"></span><br><span class="line">regexp &#x3D; new RegExp(&#x2F;is&#x2F;i);</span><br><span class="line">console.log(regexp.test(target));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; RegExp#exec</span><br><span class="line">console.log(regexp.exec(target));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; RegExp#test</span><br><span class="line">console.log(regexp.test(target));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#match</span><br><span class="line">console.log(target.match(regexp));</span><br><span class="line">console.log(target.match(&#x2F;is&#x2F;g));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 플래그</span><br><span class="line">&#x2F;&#x2F; i : 대소문자를 구별하지 않고 패턴을 검색(플래그가 없으면 대소문자를 구별)</span><br><span class="line">&#x2F;&#x2F; g : 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색</span><br><span class="line">&#x2F;&#x2F; m : 문자열의 행이 바뀌더라도 패턴 검색을 계속</span><br><span class="line"></span><br><span class="line">console.log(target.match(&#x2F;is&#x2F;));</span><br><span class="line">console.log(target.match(&#x2F;is&#x2F;i));</span><br><span class="line">console.log(target.match(&#x2F;is&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;is&#x2F;ig));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 패턴</span><br><span class="line">console.log(target.match(&#x2F;...&#x2F;g));</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;A AA B BB Aa Bb AAA&#39;;</span><br><span class="line">console.log(target.match(&#x2F;A&#123;1,2&#125;&#x2F;g)); &#x2F;&#x2F; 최소 한번, 최대 두번 반복</span><br><span class="line">console.log(target.match(&#x2F;A&#123;2&#125;&#x2F;g)); &#x2F;&#x2F; 두번 반복</span><br><span class="line">console.log(target.match(&#x2F;A&#123;2,&#125;&#x2F;g)); &#x2F;&#x2F; 최소 두 번 반복</span><br><span class="line">console.log(target.match(&#x2F;A+&#x2F;g)); &#x2F;&#x2F; 최소 한 번 이상 반복</span><br><span class="line">console.log(target.match(&#x2F;A?&#x2F;g)); &#x2F;&#x2F; 0번 이상 반복</span><br><span class="line">target &#x3D; &#39;color colour&#39;;</span><br><span class="line">console.log(target.match(&#x2F;colou?r&#x2F;g));</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;A AA B BB Aa Bb&#39;;</span><br><span class="line">console.log(target.match(&#x2F;A|B&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;A+|B+&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;[AB]+&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;[A-B]+&#x2F;g));</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;AA BB Aa Bb 12&#39;;</span><br><span class="line">console.log(target.match(&#x2F;[A-Za-z]+&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;[a-z]+&#x2F;ig));</span><br><span class="line">console.log(target.match(&#x2F;[0-9]+&#x2F;g));</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;AA BB 12,345&#39;;</span><br><span class="line">console.log(target.match(&#x2F;[0-9]+&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;[0-9,]+&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;\d+&#x2F;g));</span><br><span class="line">console.log(target.match(&#x2F;[\d,]+&#x2F;g)); &#x2F;&#x2F; \D는 숫자가 아닌 문자</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;Aa Bb 12,345 _$%&amp;&#39;;</span><br><span class="line">console.log(target.match(&#x2F;[\w,]+&#x2F;g)); &#x2F;&#x2F; 숫자, 알파벳, _</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;AA BB Aa Bb 12&#39;;</span><br><span class="line">console.log(target.match(&#x2F;[^0-9]+&#x2F;g));</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;https:&#x2F;&#x2F;www.naver.com&#39;;</span><br><span class="line">console.log((&#x2F;^https&#x2F;).test(target));</span><br><span class="line">console.log((&#x2F;com$&#x2F;).test(target));</span><br></pre></td></tr></table></figure>
<h1 id="String-메서드"><a href="#String-메서드" class="headerlink" title="String 메서드"></a>String 메서드</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; String</span><br><span class="line">console.log(&#39;hello&#39;.length);</span><br><span class="line">console.log(&#39;안녕하세요!&#39;.length);</span><br><span class="line"></span><br><span class="line">let strObj &#x3D; new String(&#39;Lee&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(strObj));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#indexOf</span><br><span class="line">let str &#x3D; &#39;Hello World&#39;;</span><br><span class="line">console.log(str.indexOf(&#39;l&#39;));</span><br><span class="line">console.log(str.indexOf(&#39;or&#39;));</span><br><span class="line">console.log(str.indexOf(&#39;x&#39;));</span><br><span class="line">console.log(str.indexOf(&#39;l&#39;, 3));</span><br><span class="line">if (str.indexOf(&#39;Hello&#39;) !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">if (str.includes(&#39;Hello&#39;)) &#123;</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#search</span><br><span class="line">console.log(str.search(&#x2F;ll&#x2F;g));</span><br><span class="line">console.log(str.search(&#x2F;x&#x2F;g));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#includes</span><br><span class="line">console.log(str.includes(&#39;Hello&#39;));</span><br><span class="line">console.log(str.includes(&#39;world&#39;));</span><br><span class="line">console.log(str.includes());</span><br><span class="line">console.log(str.includes(&#39;l&#39;, 3));</span><br><span class="line">console.log(str.includes(&#39;H&#39;, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#startsWith</span><br><span class="line">console.log(str.startsWith(&#39;He&#39;));</span><br><span class="line">console.log(str.startsWith(&#39;le&#39;));</span><br><span class="line">console.log(str.startsWith(&#39; &#39;, 5));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#endsWith</span><br><span class="line">console.log(str.endsWith(&#39;ld&#39;));</span><br><span class="line">console.log(str.endsWith(&#39;x&#39;));</span><br><span class="line">console.log(str.endsWith(&#39;lo&#39;, 5));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#charAt</span><br><span class="line">console.log(str.charAt(&#39;4&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#substring</span><br><span class="line">console.log(str.substring(1, 4));</span><br><span class="line">console.log(str.substring(1, 100));</span><br><span class="line">console.log(str.substring(20));</span><br><span class="line">console.log(str.substring(0, str.indexOf(&#39; &#39;)));</span><br><span class="line">console.log(str.indexOf(&#39; &#39;) + 1, str.length);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#slice</span><br><span class="line">console.log(str.slice(0, 5));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#toUpperCase</span><br><span class="line">console.log(str.toUpperCase());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#trim</span><br><span class="line">str &#x3D; &#39;   foo   &#39;;</span><br><span class="line">console.log(str.trim());</span><br><span class="line">console.log(str.trimStart());</span><br><span class="line">console.log(str.trimEnd());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#repeat</span><br><span class="line">str &#x3D; &#39;abc&#39;;</span><br><span class="line">console.log(str.repeat());</span><br><span class="line">console.log(str.repeat(0));</span><br><span class="line">console.log(str.repeat(1));</span><br><span class="line">console.log(str.repeat(3));</span><br><span class="line">&#x2F;&#x2F; console.log(str.repeat(-1)); 레인지에러</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String#replace</span><br><span class="line">str &#x3D; &#39;Hello world&#39;;</span><br><span class="line">console.log(str.replace(&#39;world&#39;, &#39;Lee&#39;));</span><br><span class="line">console.log(str);</span><br><span class="line">console.log(str.replace(&#39;world&#39;, &#39;&lt;strong&gt;$&amp;&lt;&#x2F;strong&gt;&#39;));</span><br><span class="line">console.log(str.replace(&#x2F;hello&#x2F;gi, &#39;Lee&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 카멜 케이스를 스네이크 케이스로 변환</span><br><span class="line">function camelToSnake(camelCase) &#123;</span><br><span class="line">  return camelCase.replace(&#x2F;.[A-Z]&#x2F;g, findUpper &#x3D;&gt; findUpper[0] + &#39;_&#39; + findUpper[1].toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let camelCase &#x3D; &#39;helloWorld&#39;;</span><br><span class="line">console.log(camelToSnake(camelCase));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 스네이크 케이스를 카멜 케이스로 변환</span><br><span class="line">function snakeToCamel (snakeCase) &#123;</span><br><span class="line">  return snakeCase.replace(&#x2F;_[a-z]&#x2F;g, findUnder &#x3D;&gt; findUnder[1].toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line">let snakeCase &#x3D; &#39;hello_world&#39;;</span><br><span class="line">console.log(snakeToCamel(snakeCase));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String.split</span><br><span class="line">str &#x3D; &#39;How are you doing?&#39;;</span><br><span class="line">console.log(str.split(&#39; &#39;));</span><br><span class="line">console.log(str.split(&#39;&#39;).reverse());</span><br><span class="line">console.log(str.split(&#39;&#39;).reverse().join(&#39;&#39;));</span><br><span class="line">str &#x3D; &#39;REDRUM&#39;;</span><br><span class="line">console.log(str.split(&#39;&#39;).reverse().join(&#39;&#39;));</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/19/Number-Math-Date-%EB%A9%94%EC%84%9C%EB%93%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/19/Number-Math-Date-%EB%A9%94%EC%84%9C%EB%93%9C/" class="post-title-link" itemprop="url">Number, Math, Date 메서드</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-19 16:46:23 / Modified: 16:46:50" itemprop="dateCreated datePublished" datetime="2020-12-19T16:46:23+09:00">2020-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javasecript/" itemprop="url" rel="index"><span itemprop="name">javasecript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Number-메서드"><a href="#Number-메서드" class="headerlink" title="Number 메서드"></a>Number 메서드</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Number.isFinite</span><br><span class="line">console.log(Number.isFinite(0));</span><br><span class="line">console.log(Number.isFinite(Number.MAX_VALUE));</span><br><span class="line">console.log(Number.isFinite(Number.MIN_VALUE));</span><br><span class="line">console.log(Number.isFinite(Infinity));</span><br><span class="line">console.log(Number.isFinite(-Infinity));</span><br><span class="line">console.log(Number.isFinite(NaN));</span><br><span class="line">console.log(Number.isFinite(&#39;Infinity&#39;));&#x2F;&#x2F; 암묵적 타입변환을 하지 않음.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number.isInteger</span><br><span class="line">console.log(Number.isInteger(0));</span><br><span class="line">console.log(Number.isInteger(123));</span><br><span class="line">console.log(Number.isInteger(-123));</span><br><span class="line">console.log(Number.isInteger(0.3));</span><br><span class="line">console.log(Number.isInteger(Infinity));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number.isNaN</span><br><span class="line">console.log(Number.isNaN(NaN));</span><br><span class="line">console.log(Number.isNaN(undefined));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number.isSafeInteger</span><br><span class="line">console.log(Number.isSafeInteger(99999999999999999));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number.prototype.toExponential</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number.prototype.toFixed</span><br><span class="line">console.log((123.456).toFixed());</span><br><span class="line">console.log((123.456).toFixed(1));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number.prototype.toPrecision</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number.prototype.toString</span><br><span class="line">console.log((10).toString());</span><br><span class="line">console.log((10).toString(2));</span><br><span class="line">console.log(typeof (10).toString(2));</span><br></pre></td></tr></table></figure>

<h1 id="Math-메서드"><a href="#Math-메서드" class="headerlink" title="Math 메서드"></a>Math 메서드</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Math.PI</span><br><span class="line">console.log(Math.PI);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.abs</span><br><span class="line">console.log(Math.abs(-1));</span><br><span class="line">console.log(Math.abs(&#39;-1&#39;));</span><br><span class="line">console.log(Math.abs(null));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.round</span><br><span class="line">console.log(Math.round(1.4));</span><br><span class="line">console.log(Math.round(-1.4));</span><br><span class="line"></span><br><span class="line">console.log((1.4).toFixed());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.ceil</span><br><span class="line">console.log(Math.ceil(1.4));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.floor</span><br><span class="line">console.log(Math.floor(1.4));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.sqrt</span><br><span class="line">console.log(Math.sqrt(9));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.random</span><br><span class="line">console.log(Math.random());</span><br><span class="line">console.log(Math.random());</span><br><span class="line">console.log(Math.random());</span><br><span class="line"></span><br><span class="line">let random &#x3D; Math.floor((Math.random() * 10) + 1);</span><br><span class="line">console.log(random);</span><br><span class="line">console.log(random);</span><br><span class="line">console.log(random);</span><br><span class="line">console.log(Math.floor((Math.random() * 100) + 1));</span><br><span class="line">console.log(Math.floor((Math.random() * 100) + 1));</span><br><span class="line">console.log(Math.floor((Math.random() * 100) + 1));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.pow</span><br><span class="line">console.log(Math.pow(2, 8));</span><br><span class="line">console.log(2 ** 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.max</span><br><span class="line">console.log(Math.max(1, 2, 3, 4, 5));</span><br><span class="line">console.log(Math.max());</span><br><span class="line">let values &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">console.log(Math.max(...values));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Math.min</span><br><span class="line">console.log(Math.min(1, 2, 3, 4, 5));</span><br></pre></td></tr></table></figure>

<h1 id="Date-메서드"><a href="#Date-메서드" class="headerlink" title="Date 메서드"></a>Date 메서드</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; new Date()</span><br><span class="line">console.log(new Date());</span><br><span class="line">console.log(new Date(1));</span><br><span class="line">console.log(new Date(&#39;2020&#x2F;12&#x2F;19&#x2F;10:00:00&#39;));</span><br><span class="line">console.log(new Date(2020, 0, 31, 10, 00, 00, 0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.now</span><br><span class="line">console.log(Date.now());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.parse</span><br><span class="line">console.log(Date.parse(new Date));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.UTC</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getFullyear</span><br><span class="line">console.log(new Date().getFullYear());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setFullYear</span><br><span class="line">let today &#x3D; new Date();</span><br><span class="line">today.setFullYear(2022);</span><br><span class="line">console.log(today);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getMonth</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setMonth</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getDate</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setDate</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getDay</span><br><span class="line">console.log(new Date().getDay()); &#x2F;&#x2F; 요일을 숫자값으로 반환</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getHours</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setHours.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getMinutes</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setMinutes</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getSeconds</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setSeconds</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getMilliseconds</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setMilliseconds</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getTime</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.setTime</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.getTimezoneOffset</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; DAte.prototype.toDateString</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.toTimeString</span><br><span class="line">today &#x3D; new Date();</span><br><span class="line">console.log(today.toString());</span><br><span class="line">console.log(today.toTimeString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.toISOString</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.toLocaleString</span><br><span class="line">console.log(today.toLocaleString(&#39;ko-KR&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Date.prototype.toLocaleTimeString</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/19/%EB%B0%B0%EC%97%B4-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/19/%EB%B0%B0%EC%97%B4-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98/" class="post-title-link" itemprop="url">배열 고차함수</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-19 13:58:56 / Modified: 13:59:12" itemprop="dateCreated datePublished" datetime="2020-12-19T13:58:56+09:00">2020-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.sort</span><br><span class="line">let fruits &#x3D; [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Apple&#39;];</span><br><span class="line">fruits.sort();</span><br><span class="line">console.log(fruits); &#x2F;&#x2F;원본 배열을 변경한다.</span><br><span class="line">fruits &#x3D; [&#39;바나나&#39;, &#39;오렌지&#39;, &#39;사과&#39;];</span><br><span class="line">fruits.sort();</span><br><span class="line">console.log(fruits);</span><br><span class="line">fruits.reverse();</span><br><span class="line">console.log(fruits);</span><br><span class="line"></span><br><span class="line">let points &#x3D; [40, 100, 1, 5, 2, 25, 10];</span><br><span class="line">points.sort();</span><br><span class="line">console.log(points);</span><br><span class="line">points.sort((a, b) &#x3D;&gt; a - b);</span><br><span class="line">console.log(points);</span><br><span class="line">&#x2F;&#x2F; 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다.</span><br><span class="line">&#x2F;&#x2F; 비교 함수는 양수나 음수 또는 0을 반환해야 한다.</span><br><span class="line">&#x2F;&#x2F; 반환값이 0보다 작으면 비교 함수의 첫 번째 인수를 우선,</span><br><span class="line">&#x2F;&#x2F; 반환값이 0보다 크면 비교 함수의 두 번째 인수를 우선,</span><br><span class="line">&#x2F;&#x2F; 반환값이 0이면 정렬하지 않는다.</span><br><span class="line"></span><br><span class="line">let todos &#x3D; [</span><br><span class="line">  &#123; id: 4, content: &#39;JavaScript&#39;&#125;,</span><br><span class="line">  &#123; id: 1, content: &#39;HTML&#39;&#125;,</span><br><span class="line">  &#123; id: 2, content: &#39;CSS&#39;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function compare(key) &#123;</span><br><span class="line">  return (a, b) &#x3D;&gt; (a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">todos.sort(compare(&#39;id&#39;));</span><br><span class="line">console.log(todos);</span><br><span class="line"></span><br><span class="line">todos.sort(compare(&#39;content&#39;));</span><br><span class="line">console.log(todos);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.forEach</span><br><span class="line">let numbers &#x3D; [1, 2, 3];</span><br><span class="line">let pows &#x3D; [];</span><br><span class="line"></span><br><span class="line">numbers.forEach(e &#x3D;&gt; pows.push(e ** 2));</span><br><span class="line">console.log(pows);</span><br><span class="line"></span><br><span class="line">[1, 2, 3].forEach((e, i, arr) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;Element: $&#123;e&#125;, index: $&#123;i&#125;, this: $&#123;arr&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 콜백함수에 전달하는 인자는 요소, 인덱스, this에 바인딩된 객체</span><br><span class="line"></span><br><span class="line">console.log([1, 2, 3].forEach((e, i, arr) &#x3D;&gt; &#123; arr[i] &#x3D; i ** 2; &#125;)); &#x2F;&#x2F; forEach의 반환값은 늘 undefined.</span><br><span class="line">console.log(numbers);</span><br><span class="line">numbers.forEach((e, i, arr) &#x3D;&gt; &#123; arr[i] &#x3D; e ** 2 &#125;);</span><br><span class="line">console.log(numbers);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; forEach 의 두번째 인수로 콜백 함수 내부의 this로 사용할 객체를 전달할 수 있다.</span><br><span class="line">class Numbers &#123;</span><br><span class="line">  numberArray &#x3D; [];</span><br><span class="line"></span><br><span class="line">  multiply(arr) &#123;</span><br><span class="line">    arr.forEach(function (item) &#123;</span><br><span class="line">      this.numberArray.push(item * item);</span><br><span class="line">    &#125;, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numbers &#x3D; new Numbers();</span><br><span class="line">numbers.multiply([1, 2, 3]); &#x2F;&#x2F; 작동 안함</span><br><span class="line"></span><br><span class="line">class NumbersByArrow &#123;</span><br><span class="line">  numberArray &#x3D; [];</span><br><span class="line"></span><br><span class="line">  multiply(arr) &#123;</span><br><span class="line">    arr.forEach(e &#x3D;&gt; this.numberArray.push(e * e));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numbers &#x3D; new NumbersByArrow();</span><br><span class="line">numbers.multiply([4, 5, 6]);</span><br><span class="line">console.log(numbers.numberArray);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.map</span><br><span class="line">numbers &#x3D; [1, 4, 9];</span><br><span class="line">let roots &#x3D; numbers.map(e &#x3D;&gt; Math.sqrt(e));</span><br><span class="line">console.log(numbers);</span><br><span class="line">console.log(roots);</span><br><span class="line"></span><br><span class="line">[1, 2, 3].map((e, i, arr) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;element: $&#123;e&#125;, index: $&#123;i&#125;, this: $&#123;arr&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class Prefixer &#123;</span><br><span class="line">  constructor(prefix) &#123;</span><br><span class="line">    this.prefix &#x3D; prefix;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(arr) &#123;</span><br><span class="line">    return arr.map(function (item) &#123;</span><br><span class="line">      return this.prefix + item;</span><br><span class="line">    &#125;, this);</span><br><span class="line">    &#x2F;&#x2F; 두 번째 인자로 this를 전달한다.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let prefixer &#x3D; new Prefixer(&#39;-webkit-&#39;);</span><br><span class="line">console.log(prefixer);</span><br><span class="line">console.log(prefixer.add([&#39;transition&#39;, &#39;user-select&#39;]));</span><br><span class="line"></span><br><span class="line">class PrefixerByArrow &#123;</span><br><span class="line">  constructor(prefix) &#123;</span><br><span class="line">    this.prefix &#x3D; prefix;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(arr) &#123;</span><br><span class="line">    return arr.map(e &#x3D;&gt; this.prefix + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefixer &#x3D; new PrefixerByArrow(&#39;-webkit-&#39;);</span><br><span class="line">console.log(prefixer);</span><br><span class="line">console.log(prefixer.add([&#39;transition&#39;, &#39;user-select&#39;]));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.filter</span><br><span class="line">numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">let odds &#x3D; numbers.filter(e &#x3D;&gt; e % 2);</span><br><span class="line">console.log(odds);</span><br><span class="line"></span><br><span class="line">[1, 2, 3].filter((e, i, arr) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;element: $&#123;e&#125;, index: $&#123;i&#125;, this: $&#123;arr&#125;&#96;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">class User &#123;;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.users &#x3D; [</span><br><span class="line">      &#123; id: 1, name: &#39;Lee&#39; &#125;,</span><br><span class="line">      &#123; id: 2, name: &#39;Kim&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findById(id) &#123;</span><br><span class="line">    return this.users.filter(user &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove(id) &#123;</span><br><span class="line">    this.users &#x3D; this.users.filter(user &#x3D;&gt; user.id !&#x3D;&#x3D; id);</span><br><span class="line">    &#x2F;&#x2F;같지 않은 애만 담아</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let users &#x3D; new User();</span><br><span class="line">let user &#x3D; users.findById(1);</span><br><span class="line">console.log(user);</span><br><span class="line"></span><br><span class="line">users.remove(1);</span><br><span class="line"></span><br><span class="line">user &#x3D; users.findById(1);</span><br><span class="line">console.log(user);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Array.prototype.reduce</span><br><span class="line">let sum &#x3D; [1, 2, 3, 4].reduce((acc, cur, index, array) &#x3D;&gt; acc + cur, 0);</span><br><span class="line">console.log(sum);</span><br><span class="line"></span><br><span class="line">let values &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line">let average &#x3D; values.reduce((acc, cur, index, &#123; length &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return index &#x3D;&#x3D;&#x3D; length - 1 ? (acc + cur) &#x2F; length : (acc + cur);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(average);</span><br><span class="line"></span><br><span class="line">values &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">let max &#x3D; values.reduce((acc, cur) &#x3D;&gt; &#123;</span><br><span class="line">  return acc &gt; cur ? acc : cur;</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">max &#x3D; Math.max(...values);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">values &#x3D; [1, 2, 3, 3, 2];</span><br><span class="line">let count &#x3D; values.reduce((acc,cur) &#x3D;&gt; &#123;</span><br><span class="line">  acc[cur] &#x3D; (acc[cur] || 0) + 1;</span><br><span class="line">  return acc;</span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line">console.log(count);</span><br><span class="line"></span><br><span class="line">values &#x3D; [1, [2, 3], 4, [5, 6]];</span><br><span class="line">let flatten &#x3D; values.reduce((acc, cur) &#x3D;&gt; acc.concat(cur),[])</span><br><span class="line">console.log(flatten);</span><br><span class="line"></span><br><span class="line">console.log([1, [2, 3, 4, 5]].flat());</span><br><span class="line">console.log([1, [2, 3, [4, 5]]].flat(2));</span><br><span class="line"></span><br><span class="line">values &#x3D; [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];</span><br><span class="line">result &#x3D; values.reduce((acc, cur, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">  if (index &#x3D;&#x3D;&#x3D; arr.indexOf(cur)) &#123;</span><br><span class="line">    acc[acc.length] &#x3D; cur;</span><br><span class="line">  &#125;</span><br><span class="line">  return acc;</span><br><span class="line">&#125;,[])</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; values.filter((v, i, arr) &#x3D;&gt; i &#x3D;&#x3D;&#x3D; arr.indexOf(v));</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; [...new Set(values)]; &#x2F;&#x2F; Set?</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">let products &#x3D; [</span><br><span class="line">  &#123; id: 1, price: 100 &#125;,</span><br><span class="line">  &#123; id: 2, price: 200 &#125;,</span><br><span class="line">  &#123; id: 3, price: 300 &#125;</span><br><span class="line">]</span><br><span class="line">let priceSum &#x3D; products.reduce((acc, cur) &#x3D;&gt; acc + cur.price,0)</span><br><span class="line">console.log(priceSum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.some</span><br><span class="line">console.log([5, 10, 15].some(v &#x3D;&gt; v &gt; 10));</span><br><span class="line">console.log([5, 10, 15].some(v &#x3D;&gt; v &lt; 0));</span><br><span class="line">console.log([&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;].some(v &#x3D;&gt; v &#x3D;&#x3D;&#x3D; &#39;banana&#39;));</span><br><span class="line">console.log([].some(v &#x3D;&gt; v)); &#x2F;&#x2F;빈배열의 경우 언제나 false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.every</span><br><span class="line">console.log([5, 10, 15].every(v &#x3D;&gt; v &gt; 1));</span><br><span class="line">console.log([5, 10, 15].every(v &#x3D;&gt; v &gt; 10));</span><br><span class="line">console.log([].every(v &#x3D;&gt; v)); &#x2F;&#x2F;빈배열의 경우 언제나 true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.find</span><br><span class="line">users &#x3D; [</span><br><span class="line">  &#123; id: 1, name: &#39;Lee&#39;&#125;,</span><br><span class="line">  &#123; id: 2, name: &#39;Kim&#39;&#125;,</span><br><span class="line">  &#123; id: 3, name: &#39;Choi&#39;&#125;,</span><br><span class="line">  &#123; id: 4, name: &#39;Park&#39;&#125;,</span><br><span class="line">];</span><br><span class="line">console.log(users.find(v &#x3D;&gt; v.id &#x3D;&#x3D;&#x3D; 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.findIndex</span><br><span class="line">users &#x3D; [</span><br><span class="line">  &#123; id: 1, name: &#39;Lee&#39;&#125;,</span><br><span class="line">  &#123; id: 2, name: &#39;Kim&#39;&#125;,</span><br><span class="line">  &#123; id: 3, name: &#39;Choi&#39;&#125;,</span><br><span class="line">  &#123; id: 4, name: &#39;Park&#39;&#125;,</span><br><span class="line">];</span><br><span class="line">console.log(users.findIndex(v &#x3D;&gt; v.id &#x3D;&#x3D;&#x3D; 2));</span><br><span class="line">console.log(users.findIndex(v &#x3D;&gt; v.name &#x3D;&#x3D;&#x3D; &#39;Choi&#39;));</span><br><span class="line"></span><br><span class="line">function predicate(key, value) &#123;</span><br><span class="line">  return item &#x3D;&gt; item[key] &#x3D;&#x3D;&#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(users.findIndex(predicate(&#39;id&#39;, 2)));</span><br><span class="line">console.log(users.findIndex(predicate(&#39;name&#39;, &#39;Park&#39;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.flatMap</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/17/%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%86%8C%EB%93%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%86%8C%EB%93%9C/" class="post-title-link" itemprop="url">배열 메소드</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-17 16:03:06 / Modified: 16:03:26" itemprop="dateCreated datePublished" datetime="2020-12-17T16:03:06+09:00">2020-12-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드"></a>배열 메소드</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.of(1));</span><br><span class="line">console.log(Array.of(1, 2, 3));</span><br><span class="line">console.log(Array.of(&#39;string&#39;));</span><br><span class="line">console.log(Array.of(&#39;stirng&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3));</span><br><span class="line"></span><br><span class="line">console.log(Array.from(&#123; length: 2, 0: &#39;a&#39;, 1: &#39;b&#39; &#125;));</span><br><span class="line">console.log(Array.from(&#39;Hello&#39;));</span><br><span class="line">console.log(Array.from(&#123; length: 3 &#125;));</span><br><span class="line">console.log(Array.from(&#123; length: 3 &#125;, (e, i) &#x3D;&gt; i));</span><br><span class="line">&#x2F;&#x2F; Array.from 두번째 인자로 받은 함수가 배열을 순회함.</span><br><span class="line">&#x2F;&#x2F; 함수의 첫번째 인자는 요소, 두번째 인자는 인덱스.</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [1, 2];</span><br><span class="line">console.log(arr[2]); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, , 3]; &#x2F;&#x2F; 리터럴이 만든 배열이 희소배열일 경우, eslint에서 빨간 줄</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(arr));</span><br><span class="line">&#x2F;&#x2F; 인덱스가 1인 요소는 존재하지 않음.</span><br><span class="line">console.log(arr[1]); &#x2F;&#x2F; undefined</span><br><span class="line">arr[100] &#x3D; 100;</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(arr.lenght);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(arr));</span><br><span class="line">&#x2F;&#x2F; 중간에 빈 요소는 프로퍼티로 갖지 않음.</span><br><span class="line"></span><br><span class="line">arr[&#39;foo&#39;] &#x3D; 3;</span><br><span class="line">arr.bar &#x3D; 4;</span><br><span class="line">arr[1.1] &#x3D; 5;</span><br><span class="line">arr[-1] &#x3D; 6;</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(arr.length);</span><br><span class="line">&#x2F;&#x2F; 인덱스가 아니면 프로퍼티로 들어감</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2, 3];</span><br><span class="line">console.log(arr);</span><br><span class="line">delete arr[1];</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(arr.length); &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line">arr.splice(1, 3);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">console.log(Array.isArray([]));</span><br><span class="line">console.log(Array.isArray([1, 2]));</span><br><span class="line">console.log(Array.isArray(new Array()));</span><br><span class="line"></span><br><span class="line">console.log(Array.isArray());</span><br><span class="line">console.log(Array.isArray(&#123;&#125;));</span><br><span class="line">console.log(Array.isArray(null));</span><br><span class="line">console.log(Array.isArray(&#123; 0: 1, length: 1&#125;));</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2, 2, 3];</span><br><span class="line">console.log(arr.indexOf(2));</span><br><span class="line">console.log(arr.indexOf(4));</span><br><span class="line">console.log(arr.indexOf(2, 2));</span><br><span class="line">arr &#x3D; [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5];</span><br><span class="line">console.log(arr.indexOf(4));</span><br><span class="line">console.log(arr.indexOf(4, 5));</span><br><span class="line">console.log(arr.indexOf(4, 10));</span><br><span class="line"></span><br><span class="line">let foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;];</span><br><span class="line">if (foods.indexOf(&#39;orange&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  foods.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(foods);</span><br><span class="line">if (foods.indexOf(&#39;watermelon&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  foods[foods.length] &#x3D; &#39;watermelon&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foods);</span><br><span class="line"></span><br><span class="line">foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;];</span><br><span class="line">if (!foods.includes(&#39;orange&#39;)) &#123;</span><br><span class="line">  foods[foods.length] &#x3D; &#39;orange&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foods);</span><br><span class="line">if (!foods.includes(&#39;watermelon&#39;)) &#123;</span><br><span class="line">  foods[foods.length] &#x3D; &#39;watermelon&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foods);</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">let result &#x3D; arr.push(3, 4);</span><br><span class="line">console.log(result); &#x2F;&#x2F; push는 length 값을 반환한다.</span><br><span class="line">console.log(arr); &#x2F;&#x2F; push는 원본 배열을 변경한다.</span><br><span class="line">&#x2F;&#x2F; push는 성능이 좋지 않아, length 접근을 사용할 수 있다.</span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">arr[arr.length] &#x3D; 3;</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">let newArr &#x3D; [...arr, 3];</span><br><span class="line">console.log(newArr);</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">console.log(arr.pop(2)); &#x2F;&#x2F; pop 은 삭제한 값을 반환한다.</span><br><span class="line">console.log(arr);</span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">result &#x3D; arr.pop(2);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 스택 자료구조 만들기</span><br><span class="line">const Stack &#x3D; (function () &#123;</span><br><span class="line">  function Stack(array &#x3D; []) &#123;</span><br><span class="line">    if (!Array.isArray(array)) &#123;</span><br><span class="line">      throw new TypeError(&#96;$&#123;array&#125; is not an array.&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.array &#x3D; array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Stack.prototype &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;   constructor: Stack,</span><br><span class="line">  &#x2F;&#x2F;   push(value) &#123;</span><br><span class="line">  &#x2F;&#x2F;     return this.array.push(value);</span><br><span class="line">  &#x2F;&#x2F;   &#125;,</span><br><span class="line">  &#x2F;&#x2F;   pop() &#123;</span><br><span class="line">  &#x2F;&#x2F;     return this.array.pop();</span><br><span class="line">  &#x2F;&#x2F;   &#125;,</span><br><span class="line">  &#x2F;&#x2F;   entries() &#123;</span><br><span class="line">  &#x2F;&#x2F;     return [...this.array];</span><br><span class="line">  &#x2F;&#x2F;   &#125;</span><br><span class="line">  &#x2F;&#x2F; &#125;;</span><br><span class="line"></span><br><span class="line">  Stack.prototype.push &#x3D; function (value) &#123;</span><br><span class="line">    return this.array.push(value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Stack.prototype.pop &#x3D; function () &#123;</span><br><span class="line">    return this.array.pop();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Stack.prototype.entries &#x3D; function () &#123;</span><br><span class="line">    return [...this.array];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return Stack;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">let stack &#x3D; new Stack([1, 2]);</span><br><span class="line">console.log(stack.entries());</span><br><span class="line"></span><br><span class="line">stack.push(3);</span><br><span class="line">console.log(stack.entries());</span><br><span class="line"></span><br><span class="line">stack.pop();</span><br><span class="line">console.log(stack.entries());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 클래스로 구현</span><br><span class="line">class StackByClass &#123;</span><br><span class="line">  #array;</span><br><span class="line">  </span><br><span class="line">  constructor (array) &#123;</span><br><span class="line">    if (!Array.isArray(array)) &#123;</span><br><span class="line">      throw new TypeError(&#96;$&#123;array&#125; is not a array.&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.#array &#x3D; array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(value) &#123;</span><br><span class="line">    return this.#array.push(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    return this.#array.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  entries() &#123;</span><br><span class="line">    return [...this.#array];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack &#x3D; new StackByClass([1, 2]);</span><br><span class="line">console.log(stack.entries());</span><br><span class="line"></span><br><span class="line">stack.push(3);</span><br><span class="line">console.log(stack.entries());</span><br><span class="line"></span><br><span class="line">stack.pop();</span><br><span class="line">console.log(stack.entries());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.unshift</span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">result &#x3D; arr.unshift(3, 4);</span><br><span class="line">console.log(result); &#x2F;&#x2F; unshift 는 length값을 반환</span><br><span class="line">console.log(arr);</span><br><span class="line">&#x2F;&#x2F; 원본 배열을 직접 변경하므로, 스프레드 문법을 쓴다</span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">newArr &#x3D; [3, ...arr];</span><br><span class="line">console.log(newArr);</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2];</span><br><span class="line">result &#x3D; arr.shift(); &#x2F;&#x2F; 삭제한 요소를 반환.</span><br><span class="line">console.log(result);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 큐 자료구조 만들기</span><br><span class="line">let Queue &#x3D; (function () &#123;</span><br><span class="line">  function Queue(array &#x3D; []) &#123;</span><br><span class="line">    if (!Array.isArray(array)) &#123;</span><br><span class="line">      throw new TypeError(&#96;$&#123;array&#125; is not an array&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.array &#x3D; array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Queue.prototype &#x3D; &#123;</span><br><span class="line">    constructor: Queue,</span><br><span class="line"></span><br><span class="line">    enqueue(value) &#123;</span><br><span class="line">      return this.array.push(value)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dequeue(value) &#123;</span><br><span class="line">      return this.array.shift(value)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    entries() &#123;</span><br><span class="line">      return [...this.array];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return Queue;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">let queue &#x3D; new Queue([1, 2]);</span><br><span class="line">console.log(queue);</span><br><span class="line"></span><br><span class="line">queue.enqueue(3);</span><br><span class="line">console.log(queue.entries());</span><br><span class="line"></span><br><span class="line">queue.dequeue();</span><br><span class="line">console.log(queue.entries());</span><br><span class="line"></span><br><span class="line">class QueueByClass &#123;</span><br><span class="line">  #array;</span><br><span class="line"></span><br><span class="line">  constructor (array) &#123;</span><br><span class="line">    if(!Array.isArray(array)) &#123;</span><br><span class="line">      throw new TypeError(&#96;$&#123;array&#125; is not an array.&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.#array &#x3D; array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enqueue(value) &#123;</span><br><span class="line">    return this.#array.push(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    return this.#array.shift();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  entries() &#123;</span><br><span class="line">    return [...this.#array];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue &#x3D; new QueueByClass([1, 2]);</span><br><span class="line">console.log(queue.entries());</span><br><span class="line"></span><br><span class="line">queue.enqueue(3);</span><br><span class="line">console.log(queue.entries());</span><br><span class="line"></span><br><span class="line">queue.dequeue();</span><br><span class="line">console.log(queue.entries());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.concat</span><br><span class="line">let arr1 &#x3D; [1, 2];</span><br><span class="line">let arr2 &#x3D; [3, 4];</span><br><span class="line">console.log(arr1.concat(arr2));</span><br><span class="line">console.log(arr1.concat(arr2, 4, 5));</span><br><span class="line">console.log(arr1); &#x2F;&#x2F; 원본 배열 변경 안함.</span><br><span class="line"></span><br><span class="line">arr1.push(arr2);</span><br><span class="line">console.log(arr1);</span><br><span class="line">arr1 &#x3D; [1, 2];</span><br><span class="line">arr2 &#x3D; [3, 4];</span><br><span class="line">result &#x3D; arr1.concat(arr2);</span><br><span class="line">console.log(result);</span><br><span class="line">&#x2F;&#x2F; push, unshift 는 인수로 전달받은 배열을 그대로 추가한다.</span><br><span class="line">arr1.unshift(arr2);</span><br><span class="line">console.log(arr1);</span><br><span class="line">&#x2F;&#x2F; concat 역시 스프레드 문법으로 대체할 수 있다.</span><br><span class="line">result &#x3D; [...[1, 2], ...[3, 4]];</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.splice</span><br><span class="line">arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">result &#x3D; arr.splice(1, 2, 20, 30);</span><br><span class="line">console.log(result); &#x2F;&#x2F; 제거한 요소가 반환된다.</span><br><span class="line">console.log(arr); &#x2F;&#x2F; 원본 배열을 직접 변경한다.</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">result &#x3D; arr.splice(1, 0, 100);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br><span class="line">&#x2F;&#x2F; 두번째 인자를 0줘서 삭제는 안하고 추가만</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">console.log(arr);</span><br><span class="line">arr.splice(1);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 특정 요소를 찾아서 제거하기</span><br><span class="line">arr &#x3D; [1, 2, 3, 1, 2];</span><br><span class="line">function remove(array, item) &#123;</span><br><span class="line">  const index &#x3D; array.indexOf(item);</span><br><span class="line">  if (index !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">    array.splice(index, 1);</span><br><span class="line">  &#125;;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line">console.log(remove(arr, 2));</span><br><span class="line">console.log(remove(arr, 2));</span><br><span class="line"></span><br><span class="line">arr &#x3D; [1, 2, 3, 1, 2];</span><br><span class="line">function removeAll(array, item) &#123;</span><br><span class="line">  return array.filter(e &#x3D;&gt; e !&#x3D;&#x3D; item);</span><br><span class="line">&#125;</span><br><span class="line">console.log(removeAll(arr, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.slice</span><br><span class="line">arr &#x3D; [1, 2, 3];</span><br><span class="line">console.log(arr.slice(0, 2));</span><br><span class="line">console.log(arr.slice(1));</span><br><span class="line">console.log(arr.slice());</span><br><span class="line">&#x2F;&#x2F; 복사는 간단하게 스프레드 문법</span><br><span class="line">result &#x3D; [...arr];</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.join</span><br><span class="line">arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">console.log(arr.join());</span><br><span class="line">console.log(arr.join(&#39;&#39;));</span><br><span class="line">console.log(arr.join(&#39;_&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.reverse</span><br><span class="line">console.log(arr.reverse());</span><br><span class="line">console.log(arr); &#x2F;&#x2F; 원본 배열을 변경한다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.fill</span><br><span class="line">arr &#x3D; new Array(5);</span><br><span class="line">console.log(arr);</span><br><span class="line">arr.fill(3);</span><br><span class="line">console.log(arr);</span><br><span class="line">arr.fill(1, 2);</span><br><span class="line">console.log(arr);</span><br><span class="line">arr.fill(2, 2, 3);</span><br><span class="line">console.log(arr);</span><br><span class="line">&#x2F;&#x2F; 원본 배열을 변경한다. 변경된 원본 배열을 반환한다.</span><br><span class="line">&#x2F;&#x2F; Array.from 을 사용하면 두 번째 인수로 전달한 콜백 함수로 요소값을 만들면서 채울 수 있다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.includes</span><br><span class="line">arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">console.log(arr.includes(2)); &#x2F;&#x2F;true</span><br><span class="line">console.log(arr.includes(5)); &#x2F;&#x2F;false</span><br><span class="line">console.log(arr.includes(2, 2)); &#x2F;&#x2F;true</span><br><span class="line">console.log(arr.includes(2, -3)); &#x2F;&#x2F;false</span><br><span class="line">&#x2F;&#x2F; indexOf도 특정 요소를 찾을 수 있는데,</span><br><span class="line">&#x2F;&#x2F; 반환값이 -1인지 확인 절차가 필요하고,</span><br><span class="line">&#x2F;&#x2F; NaN은 찾지 못한다.</span><br><span class="line">console.log([NaN].indexOf(NaN)); &#x2F;&#x2F; -1 -&gt; 없다는 뜻</span><br><span class="line">console.log([NaN].includes(NaN)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.flat</span><br><span class="line">console.log([1, [2, 3, 4, 5], 6].flat());</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat());</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat(1));</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat(2));</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat().flat());</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat(infinity));</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/17/201218-%EB%B0%B0%EC%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/201218-%EB%B0%B0%EC%97%B4/" class="post-title-link" itemprop="url">201218-배열</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-17 12:35:25 / Modified: 12:35:41" itemprop="dateCreated datePublished" datetime="2020-12-17T12:35:25+09:00">2020-12-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h1><ul>
<li>여러 개의 값을 순차적으로 나열한 자료 구조.</li>
<li>요소: 배열이 가지고 있는 값(객체, 함수, 배열 등 자바스크립트에서 값으로 인정하는 모든 것이 들어갈 수 있다.)</li>
<li>인덱스: 배열에서 요소의 위치(0부터 시작)</li>
<li>요소에 접근할 때는 대괄호 표기법을 사용한다.</li>
<li>배열은 배열의 길이를 나타내는 length 프로퍼티를 갖는다.</li>
<li>인덱스와 length 프로퍼티를 갖기 때문에, for문으로 순차적으로 요소에 접근할 수 있다.</li>
<li>배열은 객체 타입이다.</li>
<li>배열은 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다.</li>
<li>Array.prototype이 배열을 위한 빌트인 메서드를 가지고 있다.<h1 id="자바스크립트의-배열"><a href="#자바스크립트의-배열" class="headerlink" title="자바스크립트의 배열"></a>자바스크립트의 배열</h1></li>
<li>자료 구조에서 말하는 배열은, 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. -&gt; 밀집 배열.</li>
<li>이러한 배열은 인덱스를 통해 효율적으로 요소에 접근할 수 있다는 장점이 있다.</li>
<li>하지만 처음부터 끝까지 검색을 하는, ‘선형 검색’을 해야 한다는 단점.</li>
<li>또한 배열의 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점.</li>
<li>그런데 자바스크립트의 배열은,</li>
<li>일반적인 배열의 동작을 흉내 낸 특수한 객체다.</li>
<li>자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티로 가지며, length 프로퍼티를 갖는 특수한 객체다. -&gt; 인덱스가 사실 프로퍼티 키. 요소는 프로퍼티 값.</li>
<li>일반적인 배열보다 성능적인 면에서 느릴 수밖에 없지만,</li>
<li>특정 요소를 검색하거나 요소를 삽입 삭제하는 경우에는 빠른 성능을 기대할 수 있다.<h1 id="length-프로퍼티와-희소-배열"><a href="#length-프로퍼티와-희소-배열" class="headerlink" title="length 프로퍼티와 희소 배열"></a>length 프로퍼티와 희소 배열</h1><h1 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h1></li>
</ul>
<ol>
<li>배열 리터럴</li>
<li>Array 생성자 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; new Array(10);</span><br></pre></td></tr></table></figure>
<ul>
<li>전달된 인수가 1개이고 숫자인 경우 인수를 length 프로퍼티 값으로 가진 배열을 생성.</li>
<li>이 때 생성된 배열은 요소가 없는 희소 배열.</li>
<li>인수가 없는 경우 빈 배열.</li>
<li>전달된 인수가 둘 이상이거나 숫자가 아닌 경우, 각각을 요소로 갖는 배열 생성.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; -&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
<li>new 연산자와 함께 호출하지 않더라도, 배열을 생성하는 생성자 함수로 동작한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(1, 2, 3); &#x2F;&#x2F; -&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.of<ul>
<li>인수를 요소로 갖는 배열을 생성. Array()와 달리 1개의 인수만 전달해도 요소로 생성.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(1); &#x2F;&#x2F; -&gt; [1]</span><br><span class="line">Array.of(1, 2, 3); &#x2F;&#x2F; -&gt; [1, 2, 3]</span><br><span class="line">Array.of(&#39;string&#39;); &#x2F;&#x2F; -&gt; [&#39;string&#39;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.from<ul>
<li>유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달받아 배열로 변환하여 반환한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 2, 0: &#39;a&#39;, 1: &#39;b&#39; &#125;); &#x2F;&#x2F; -&gt; [&#39;a&#39;, &#39;b&#39;]</span><br><span class="line">Array.from(&#39;Hello&#39;); &#x2F;&#x2F; -&gt; [&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span><br></pre></td></tr></table></figure></li>
<li>두번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.form(&#123; length: 3&#125;, (_, i) &#x3D;&gt; i); &#x2F;&#x2F; [0, 1, 2]</span><br></pre></td></tr></table></figure></li>
<li>두번째 인수로 전달된 ‘콜백 함수의 첫번째 인수’는 순차적으로 도는 배열의 요소.</li>
<li>두번째 인수는 인덱스.<h1 id="배열-요소의-참조"><a href="#배열-요소의-참조" class="headerlink" title="배열 요소의 참조"></a>배열 요소의 참조</h1><h1 id="배열-요소의-추가와-갱신"><a href="#배열-요소의-추가와-갱신" class="headerlink" title="배열 요소의 추가와 갱신"></a>배열 요소의 추가와 갱신</h1></li>
</ul>
</li>
</ol>
<ul>
<li>인덱스가 아닌 프로퍼티 키로 추가된 배열의 ‘프로퍼티’는 length에 영향을 주지 않는다.</li>
<li>length 는 인덱스가 있는 요소(인덱스만 있는 경우도 제외)만 센다.<h1 id="배열-요소의-삭제"><a href="#배열-요소의-삭제" class="headerlink" title="배열 요소의 삭제"></a>배열 요소의 삭제</h1></li>
<li>배열은 객체이기 때문에 delete 연산자를 사용할 수 있으나, 희소 배열로 만들어 버린다.</li>
<li>splice 메서드 써야지.<h1 id="배열-메서드"><a href="#배열-메서드" class="headerlink" title="배열 메서드"></a>배열 메서드</h1></li>
</ul>
<ol>
<li>Array.isArray<ul>
<li>전달된 인수가 배열이면 true, 아니면 false.</li>
</ul>
</li>
<li>Array.prototype.indexOf<ul>
<li>인수로 전달된 요소를 검색하여 인덱스를 반환한다.</li>
<li>요소가 여러 개 있다면 첫 번째로 검색된 요소의 인덱스를 반환한다.</li>
<li>요소가 존재하지 않으면 -1을 반환한다.</li>
<li>배열에 특정 요소가 존재하는지 확인할 때 유용하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하는지 확인한다.</span><br><span class="line">if (foods.indexOf(&#39;orange&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  &#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하지 않으면 &#39;orange&#39; 요소를 추가한다.</span><br><span class="line">  foods.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foods); &#x2F;&#x2F; [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure></li>
<li>Array.prototype.includes를 사용할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하는지 확인한다.</span><br><span class="line">if (!foods.includes(&#39;orange&#39;)) &#123;</span><br><span class="line">  &#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하지 않으면 &#39;orange&#39; 요소를 추가한다.</span><br><span class="line">  foods.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foods); &#x2F;&#x2F; [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.push<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다.</li>
<li>push 메서드를 사용하지 않고 length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가할 수도 있다. 이 방법이 push 메서드보다 빠르다.</li>
<li>push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 push 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 마지막에 요소를 추가할 수 있으며 부수 효과도 없다. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 스프레드 문법</span><br><span class="line">const newArr &#x3D; [...arr, 3];</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.pop<ul>
<li>원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. pop 메서드는 원본 배열을 직접 변경한다.</li>
</ul>
</li>
<li>Array.prototype.unshift<ul>
<li>인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. unshift 메서드는 원본 배열을 직접 변경한다.</li>
<li>unshift 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 unshift 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 선두에 요소를 추가할 수 있으며 부수 효과도 없다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 스프레드 문법</span><br><span class="line">const newArr &#x3D; [3, ...arr];</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; [3, 1, 2]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.shift<ul>
<li>shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. shift 메서드는 원본 배열을 직접 변경한다.</li>
</ul>
</li>
<li>Array.prototype.concat<ul>
<li>인수로 전달된 값들(배열 또는 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다. 원본 배열은 변경되지 않는다.</li>
<li>push와 unshift 메서드는 원본 배열을 직접 변경하지만 concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.</li>
<li>인수로 전달받은 값이 배열인 경우 push와 unshift 메서드는 배열을 그대로 원본 배열의 마지막/첫 번째 요소로 추가하지만 concat 메서드는 인수로 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다.</li>
</ul>
</li>
<li>Array.prototype.splice<ul>
<li>세 개의 매개변수를 받는다.</li>
<li>(요소를 제거하기 시작할 인덱스, 제거할 요소의 개수(옵션), 제거한 위치에 삽입할 요소 목록(옵션))</li>
<li>첫번째 요소가 음수인 경우, 배열의 끝에서부터.</li>
</ul>
</li>
<li>Array.prototype.slice<ul>
<li>인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. </li>
<li>두 개의 매개변수를 받는다.</li>
<li>(복사를 시작할 인덱스, 복사를 종료할 인덱스)</li>
<li>종료할 인덱스에 해당하는 요소는 복사되지 않는다. 두번째 인수는 생략 가능하며, 기본값은 length 프로퍼티 값이다.(생략시 다 복사된다.)</li>
<li>첫번째 인수가 음수인 경우, 배열의 끝에서부터 요소를 복사한다.</li>
<li>인수를 모두 생략하면 원본 전체를 복사한다.</li>
<li>이 때는 얕은 복사.</li>
<li>복사본을 생성하는 것을 이용하여, 유사 배열 객체를 배열로 변환할 수 있다.</li>
<li>Array.from 메서드를 사용하면 더욱 간단하지.</li>
</ul>
</li>
<li>prototype.join<ul>
<li>원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열, 즉 구분자(separator)로 연결한 문자열을 반환한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.join(); &#x2F;&#x2F; -&gt; &#39;1,2,3,4&#39;;</span><br><span class="line">arr.join(&#39;&#39;); &#x2F;&#x2F; -&gt; &#39;1234&#39;</span><br><span class="line">arr.join(&#39;:&#39;); &#x2F;&#x2F; -&gt; &#39;1:2:3:4&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Array.prototype.reverse<ul>
<li>원본 배열의 순서를 반대로 뒤집는다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다.</li>
</ul>
</li>
<li>Array.prototype.fill<ul>
<li>인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다. 이때 원본 배열이 변경된다.</li>
<li>두 번째 인수로 요소 채우기를 시작할 인덱스를 전달할 수 있다.</li>
<li>세 번째 인수로 요소 채우기를 멈출 인덱스를 전달할 수 있다.</li>
<li>fill 메서드로 요소를 채울 경우 모든 요소를 하나의 값만으로 채울 수밖에 없다는 단점이 있다. 하지만 Array.from 메서드를 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 요소값을 만들면서 배열을 채울 수 있다.</li>
</ul>
</li>
<li>Array.prototype.includes<ul>
<li>배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다.</li>
<li>(검색할 대상, 검색을 시작할 인덱스)</li>
<li>인수로 전달된 요소를 검색하여 인덱스를 반환하는 indexOf 메서드를 사용하여도 배열 내에 특정 요소가 포함되어 있는지 확인할 수 있다. 하지만 indexOf 메서드를 사용하면 반환값이 -1인지 확인해 보아야 하고 배열에 NaN이 포함되어 있는지 확인할 수 없다는 문제가 있다.</li>
</ul>
</li>
<li>Array.prototype.flat<ul>
<li>인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.</span><br><span class="line">[1, [2, [3, [4]]]].flat();  &#x2F;&#x2F; -&gt; [1, 2, [3, [4]]]</span><br><span class="line">[1, [2, [3, [4]]]].flat(1); &#x2F;&#x2F; -&gt; [1, 2, [3, [4]]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.</span><br><span class="line">[1, [2, [3, [4]]]].flat(2); &#x2F;&#x2F; -&gt; [1, 2, 3, [4]]</span><br><span class="line">&#x2F;&#x2F; 2번 평탄화한 것과 동일하다.</span><br><span class="line">[1, [2, [3, [4]]]].flat().flat(); &#x2F;&#x2F; -&gt; [1, 2, 3, [4]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.</span><br><span class="line">[1, [2, [3, [4]]]].flat(Infinity); &#x2F;&#x2F; -&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/15/201216-ES6-%ED%95%A8%EC%88%98%EC%9D%98-%EC%B6%94%EA%B0%80-%EA%B8%B0%EB%8A%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/201216-ES6-%ED%95%A8%EC%88%98%EC%9D%98-%EC%B6%94%EA%B0%80-%EA%B8%B0%EB%8A%A5/" class="post-title-link" itemprop="url">201216-ES6 함수의 추가 기능</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-15 21:12:23 / Modified: 21:12:39" itemprop="dateCreated datePublished" datetime="2020-12-15T21:12:23+09:00">2020-12-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ES6함수의-추가-기능-화살표-함수"><a href="#ES6함수의-추가-기능-화살표-함수" class="headerlink" title="ES6함수의 추가 기능(화살표 함수)"></a>ES6함수의 추가 기능(화살표 함수)</h1><h1 id="함수의-구분"><a href="#함수의-구분" class="headerlink" title="함수의 구분"></a>함수의 구분</h1><ul>
<li>ES6 이전의 함수는 다양한 형태로 호출할 수 있다.<ol>
<li>일반 함수로서 호출</li>
<li>생산자 함수로서 호출</li>
<li>메서드로서 호출</li>
</ol>
</li>
<li>즉, ES6 이전의 함수는 callable 이면서 constructor.</li>
<li>메서드, 콜백 함수 등도 불필요한 프로토타입 객체를 생성한다.</li>
<li>이러한 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분한다.<ol>
<li>일반 함수: constructor, prototype, arguments</li>
<li>메서드: super, arguments</li>
<li>화살표 함수</li>
</ol>
</li>
<li>일반 함수는 함수 선언문이나 함수 표현식으로 정의한 함수를 말하며,</li>
<li>메서드 축약 표현으로 정의된 메서드와 화살표 함수는 non-constructor다.<h1 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h1></li>
<li>ES6이전에는 메서드에 대한 명학한 정의가 없었다.</li>
<li>일반적으로 객체에 바인딩된 함수.</li>
<li>ES6 사양에서는 메서드 축약 표현으로 정의된 함수만을 메서드라고 한다.</li>
<li>non-constructor로, prototype 프로퍼티가 없다.</li>
<li>표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 non-constructor.</li>
<li>ES6 메서드는 내부슬롯 [[Home Object]]를 갖는다.</li>
<li>super참조는 내부슬롯 [[Home Object]]를 사용해 수퍼클래스의 메서드를 참조하므로, ES6 메서드는 super 키워드를 사용할 수 있다.(메서드 축약표현으로 쓰지 않은 메서드는 사용 못함.)</li>
<li>ES6 이전의 방식으로 메서드를 정의하는 것은 사용하지 않는 것이 좋다.<h1 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const multiply &#x3D; (x, y) &#x3D;&gt; x * y;</span><br><span class="line">multiply(2, 3); &#x2F;&#x2F; -&gt; 6</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>화살표 함수 정의<ul>
<li>함수 표현식으로 정의해야 한다.</li>
<li>호출 방식은 기존 함수와 동일하다.</li>
<li>매개변수가 여러 개인 경우 () 안에 매개변수를 선언한다.</li>
<li>매개변수가 한 개인 경우 ()를 생략할 수 있다.</li>
<li>매개변수가 없는 경우, ()를 생략할 수 없다.</li>
<li>함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {}를 생략할 수 있다. 이때 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다.</li>
<li>함수 몸체를 감싸는 중괄호 {}를 생략한 경우 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생한다. 표현식이 아닌 문은 반환할 수 없기 때문이다.</li>
<li>따라서 함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.</li>
<li>객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 ()로 감싸 주어야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const create &#x3D; (id, content) &#x3D;&gt; (&#123; id, content &#125;);</span><br><span class="line">create(1, &#39;JavaScript&#39;); &#x2F;&#x2F; -&gt; &#123;id: 1, content: &quot;JavaScript&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {}를 생략할 수 없다. 이때 반환값이 있다면 명시적으로 반환해야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const sum &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  const result &#x3D; a + b;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>화살표 함수도 일급 객체이므로 Array.prototype.map, Array.prototype.filter, Array.prototype.reduce 같은 고차 함수(Higher-Order Function, HOF)에 인수로 전달할 수 있다. 이 경우 일반적인 함수 표현식보다 표현이 간결하고 가독성이 좋다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map(v &#x3D;&gt; v * 2); &#x2F;&#x2F; -&gt; [ 2, 4, 6 ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>화살표 함수와 일반 함수 차이<ol>
<li>화살표 함수는 non-constructor다.</li>
<li>중복된 매개변수 이름을 선언할 수 없다.</li>
<li>화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.<ul>
<li>화살표 함수 내부에서 this, arguments, super, new.target을 참조하면, 스코프 체인을 통해 상위 스코프를 참조한다.</li>
</ul>
</li>
</ol>
</li>
<li>this<ul>
<li>화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다.</li>
<li>이는 “콜백 함수 내부의 this 문제”, 즉 콜백 함수 내부의 this가 외부 함수의 this와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것이다.</li>
<li>콜백 함수가 일반 함수로서 호출될 경우, 콜백 함수의 this는 전역 객체를 바인딩한다.</li>
<li>이를 해결하기 위해 ES6 이전에는 다음과 같은 방법을 사용했다.<ol>
<li>this를 일단 회피시킨 후에 콜백 함수 내부에서 사용한다.</li>
<li>Function.prototype.bind 메서드를 사용하여 add 메서드를 호출한 prefixer 객체를 가리키는 this를 바인딩한다.</li>
</ol>
</li>
<li>ES6에서는 화살표 함수를 사용하여 “콜백 함수 내부의 this 문제”를 해결할 수 있다.</li>
<li>화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.</li>
<li>콜백 함수를 화살표 함수로 쓰면, 외부 함수와 this가 동일해진다.</li>
<li>만약 화살표 함수의 상위 함수가 다시 화살표 함수면, 스코프 체인을 따라 this를 찾으러 간다.</li>
<li>만약 화살표 함수가 전역 함수라면 화살표 함수의 this는 전역 객체를 가리킨다. 전역 함수의 상위 스코프는 전역이고 전역에서 this는 전역 객체를 가리키기 때문이다.</li>
<li>화살표 함수는 함수 자체의 this 바인딩을 갖지 않기 때문에 Function.prototype.call/apply/bind 메서드를 사용해도 화살표 함수 내부의 this를 교체할 수 없다.</li>
<li>클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있다.</li>
<li>클래스 필드에 할당한 화살표 함수의 상위 스코프는 constructor다. 따라서 sayHi 클래스 필드에 할당한 화살표 함수 내부에서 참조한 this는 constructor 내부의 this 바인딩과 같다. constructor 내부의 this 바인딩은 클래스가 생성한 인스턴스를 가리키므로 sayHi 클래스 필드에 할당한 화살표 함수 내부의 this 또한 클래스가 생성한 인스턴스를 가리킨다.</li>
<li>하지만 클래스 필드에 할당한 화살표 함수는 프로토타입 메서드가 아니라 인스턴스 메서드가 된다. 따라서 메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋다.</li>
</ul>
</li>
<li>super<ul>
<li>화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다.</li>
</ul>
</li>
<li>arguments<ul>
<li>화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 arguments를 참조하면 this와 마찬가지로 상위 스코프의 arguments를 참조한다.</li>
<li>화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 한다.<h1 id="Rest-파라미터"><a href="#Rest-파라미터" class="headerlink" title="Rest 파라미터"></a>Rest 파라미터</h1></li>
</ul>
</li>
</ol>
<ul>
<li>매개변수 이름 앞에 세개의 점 …을 붙여서 정의한 매개변수를 의미한다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(...rest) &#123;</span><br><span class="line">  &#x2F;&#x2F; 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터다.</span><br><span class="line">  console.log(rest); &#x2F;&#x2F; [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure></li>
<li>일반 매개변수와 Rest 파라미터는 함께 사용할 수 있다. 이때 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당된다.</li>
<li>Rest 파라미터는 이름 그대로 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당된다. 따라서 Rest 파라미터는 반드시 마지막 파라미터이어야 한다.</li>
<li>Rest 파라미터는 단 하나만 선언할 수 있다.</li>
<li>Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(...rest) &#123;&#125;</span><br><span class="line">console.log(foo.length); &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">function bar(x, ...rest) &#123;&#125;</span><br><span class="line">console.log(bar.length); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">function baz(x, y, ...rest) &#123;&#125;</span><br><span class="line">console.log(baz.length); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<h1 id="Rest-파라미터와-arguments-객체"><a href="#Rest-파라미터와-arguments-객체" class="headerlink" title="Rest 파라미터와 arguments 객체"></a>Rest 파라미터와 arguments 객체</h1></li>
<li>ES5에서는 함수를 정의할 때 매개변수의 개수를 확정할 수 없는 가변 인자 함수의 경우 매개변수를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받았다.</li>
<li>하지만 arguments 객체는 배열이 아닌 유사 배열 객체이므로 배열 메서드를 사용하려면 Function.prototype.call이나 Function.prototype.apply 메서드를 사용해 arguments 객체를 배열로 변환해야 하는 번거로움이 있었다.</li>
<li>ES6에서는 rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있다.</li>
<li>화살표 함수는 함수 자체의 arguments 객체를 갖지 않으므로, 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 한다.<h1 id="매개변수-기본값"><a href="#매개변수-기본값" class="headerlink" title="매개변수 기본값"></a>매개변수 기본값</h1></li>
<li>ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(x &#x3D; 0, y &#x3D; 0) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>매개변수 기본값은 매개변수에 인수를 전달하지 않은 경우와 undefined를 전달한 경우에만 유효하다.</li>
<li>Rest 파라미터에는 기본값을 지정할 수 없다.</li>
<li>매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티와 arguments 객체에 아무런 영향을 주지 않는다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/13/201214-%ED%81%B4%EB%9E%98%EC%8A%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/201214-%ED%81%B4%EB%9E%98%EC%8A%A4/" class="post-title-link" itemprop="url">201214-클래스</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-13 14:21:36 / Modified: 14:21:52" itemprop="dateCreated datePublished" datetime="2020-12-13T14:21:36+09:00">2020-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h1><h1 id="클래스-정의"><a href="#클래스-정의" class="headerlink" title="클래스 정의"></a>클래스 정의</h1><ul>
<li>class 키워드 사용.</li>
<li>생성자 함수와 마찬가지로, 파스칼 케이스를 사용해 이름을 짓는 게 일반적.</li>
<li>표현식으로 정의할 수 있다 -&gt; 값으로 사용할 수 있다 -&gt; 일급객체다.</li>
<li>클래스 몸체에는 0개 이상의 ‘메서드’만 정의할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 클래스 선언문</span><br><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name; &#x2F;&#x2F; name 프로퍼티는 public하다.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 프로토타입 메서드</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    console.log(&#96;Hi! My name is $&#123;this.name&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 정적 메서드</span><br><span class="line">  static sayHello() &#123;</span><br><span class="line">    console.log(&#39;Hello!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="클래스-호이스팅"><a href="#클래스-호이스팅" class="headerlink" title="클래스 호이스팅"></a>클래스 호이스팅</h1></li>
<li>let/const 키워드로 선언한 변수처럼 호이스팅</li>
<li>동작은 동일한데, 실행 컨텍스트 상에서도 동일한가? 모르겠음.<h1 id="인스턴스-생성"><a href="#인스턴스-생성" class="headerlink" title="인스턴스 생성"></a>인스턴스 생성</h1></li>
<li>클래스는 인스턴스를 생성하는 게 유일한 이유이므로 일반 함수로서 호출이 안 됨.</li>
<li>new 연산자와 함께 호출.<h1 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h1></li>
</ul>
<ol>
<li>constructor<ul>
<li>인스턴스를 생성하고 초기화 하기 위한 메서드.</li>
<li>constructor 이름을 바꿀 수는 없다.</li>
<li>클래스 내에 최대 한 개만 존재할 수 있다.</li>
<li>constructor는 생략할 수 있다. -&gt; 이 경우 인스턴스는 빈 객체.</li>
<li>constructor를 생략하면 클래스에 다음과 같이 빈 constructor가 암묵적으로 정의된다. constructor를 생략한 클래스는 빈 constructor에 의해 빈 객체를 생성한다.</li>
<li>따라서 인스턴스를 초기화하려면 constructor를 생략해서는 안 된다.</li>
<li>생성자 함수와 마찬가지로, 암묵적으로 this를 반환하므로, return은 쓰지 않는다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>근데!</li>
<li>constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. 다시 말해, 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.</li>
<li>이게 무슨 말이냐면,</li>
<li>클래스 정의가 평가되어 함수 객체를 만들 때,</li>
<li>이 때 constructor가 메서드라면 평가를 안하는데,</li>
<li>메서드로 해석하지 않으니까, constructor 동작을 하는 함수 객체도 만든다~</li>
<li>이 말이야?</li>
</ul>
</li>
<li>프로토타입 메서드<ul>
<li>클래스 몸체에 메서드 축약 표현으로 쓴 메서드.</li>
<li>프로토타입의 메서드가 되고, 인스턴스가 상속받아 쓸 수 있다.</li>
<li>즉, 클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 매커니즘이다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 프로토타입 메서드</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    console.log(&#96;Hi! My name is $&#123;this.name&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>정적 메서드<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인스턴스 생성 및 초기화</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 정적 메서드</span><br><span class="line">  static sayHi() &#123;</span><br><span class="line">    console.log(&#39;Hi!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="정적-메서드와-프로토타입-메서드의-차이"><a href="#정적-메서드와-프로토타입-메서드의-차이" class="headerlink" title="정적 메서드와 프로토타입 메서드의 차이"></a>정적 메서드와 프로토타입 메서드의 차이</h1></li>
<li>정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다. -&gt; 인스턴스에서 정적 메서드를 상속받을 수 없다.</li>
<li>정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다. -&gt; 인스턴스 생성 없이도 호출할 수 있는 정적 메서드를 지향해야 한다.</li>
<li>정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다. -&gt; this 유무 차이로 간단하게 생각할 수 있다.</li>
</ol>
<ul>
<li>클래스 또는 생성자 함수를 하나의 네임 스페이스로 여기고,</li>
<li>여기에 관련 메서드들을 정적 메서드로 모아두어 사용할 수 있다.</li>
<li>메서드를 구조화.<h1 id="클래스에서-정의한-메서드의-특징"><a href="#클래스에서-정의한-메서드의-특징" class="headerlink" title="클래스에서 정의한 메서드의 특징"></a>클래스에서 정의한 메서드의 특징</h1></li>
</ul>
<ol>
<li>function 키워드를 생략한 메서드 축약 표현을 사용한다.</li>
<li>객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.</li>
<li>암묵적으로 strict 모드로 실행된다. (“20. strict mode” 참고)</li>
<li>for…in 문이나 Object.keys 메서드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며, 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다. (“16. 프로퍼티 어트리뷰트” 참고)</li>
<li>내부 메서드 [[Construct]]를 갖지 않는 non-constructor다. 따라서 new 연산자와 함께 호출할 수 없다. (“17.2.5. constructor와 non-constructor의 구분” 참고)<h1 id="클래스의-인스턴스-생성-과정"><a href="#클래스의-인스턴스-생성-과정" class="headerlink" title="클래스의 인스턴스 생성 과정"></a>클래스의 인스턴스 생성 과정</h1></li>
</ol>
<ul>
<li>생성자 함수의 인스턴스 생성 과정과 유사하다.</li>
</ul>
<ol>
<li>인스턴스 생성과 this 바인딩.</li>
<li>constructor 메서드의 내부 코드가 실행되어 인스턴스 초기화.</li>
<li>인스턴스 반환(암묵적으로 return this)<h1 id="클래스-필드-정의-제안"><a href="#클래스-필드-정의-제안" class="headerlink" title="클래스 필드 정의 제안"></a>클래스 필드 정의 제안</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 클래스 필드 정의</span><br><span class="line">  name &#x3D; &#39;Lee&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person();</span><br><span class="line">console.log(me); &#x2F;&#x2F; Person &#123;name: &quot;Lee&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>클래스 몸체에서 클래스 필드를 정의하는 경우, this에 클래스 필드를 바인딩해서는 안된다. this는 클래스의 constructor와 메서드 내에서만 유효하다.</li>
<li>클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다.</li>
<li>외부의 초기값(인수)으로 클래스 필드를 초기화(프로퍼티 값 설정)해야 할 필요가 있다면 constructor에서 클래스 필드를 초기화해야 한다.</li>
<li>클래스 필드를 통해 메서드를 정의할 수도 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 클래스 필드에 문자열을 할당</span><br><span class="line">  name &#x3D; &#39;Lee&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클래스 필드에 함수를 할당</span><br><span class="line">  getName &#x3D; function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 화살표 함수로 정의할 수도 있다.</span><br><span class="line">  &#x2F;&#x2F; getName &#x3D; () &#x3D;&gt; this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>클래스 필드에 함수를 할당하는 경우, 이 함수는 프로토타입 메서드가 아닌 인스턴스 메서드가 된다.<h1 id="private-필드-정의-제안"><a href="#private-필드-정의-제안" class="headerlink" title="private 필드 정의 제안"></a>private 필드 정의 제안</h1></li>
<li>private 필드의 선두에는 #을 붙여준다. private 필드를 참조할 때도 #을 붙어주어야 한다.</li>
<li>private 필드는 반드시 클래스 몸체에 정의해야 한다. private 필드를 직접 constructor에 정의하면 에러가 발생한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; private 필드 정의</span><br><span class="line">  #name &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    &#x2F;&#x2F; private 필드 참조</span><br><span class="line">    this.#name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static-필드-정의-제안"><a href="#static-필드-정의-제안" class="headerlink" title="static 필드 정의 제안"></a>static 필드 정의 제안</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyMath &#123;</span><br><span class="line">  &#x2F;&#x2F; static public 필드 정의</span><br><span class="line">  static PI &#x3D; 22 &#x2F; 7;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; static private 필드 정의</span><br><span class="line">  static #num &#x3D; 10;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; static 메서드</span><br><span class="line">  static increment() &#123;</span><br><span class="line">    return ++MyMath.#num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="상속에-의한-클래스-확장"><a href="#상속에-의한-클래스-확장" class="headerlink" title="상속에 의한 클래스 확장"></a>상속에 의한 클래스 확장</h1></li>
<li>기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의.</li>
<li>extends 키워드 사용.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(age, weight) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.weight &#x3D; weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat() &#123; return &#39;eat&#39;; &#125;</span><br><span class="line"></span><br><span class="line">  move() &#123; return &#39;move&#39;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 상속을 통해 Animal 클래스를 확장한 Bird 클래스</span><br><span class="line">class Bird extends Animal &#123;</span><br><span class="line">  fly() &#123; return &#39;fly&#39;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bird &#x3D; new Bird(1, 5);</span><br><span class="line"></span><br><span class="line">console.log(bird); &#x2F;&#x2F; Bird &#123;age: 1, weight: 5&#125;</span><br><span class="line">console.log(bird instanceof Bird); &#x2F;&#x2F; true</span><br><span class="line">console.log(bird instanceof Animal); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(bird.eat());  &#x2F;&#x2F; eat</span><br><span class="line">console.log(bird.move()); &#x2F;&#x2F; move</span><br><span class="line">console.log(bird.fly());  &#x2F;&#x2F; fly</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>extends 키워드<ul>
<li>상속을 통해 확장된 클래스를 서브클래스(subclass)라 부르고, 서브클래스에게 상속된 클래스를 수퍼클래스(superclass)라 부른다.</li>
<li>수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인 뿐만이 아니라, 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.</li>
</ul>
</li>
<li>동적 상속<ul>
<li>extends 키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다. 단, extends 키워드 앞에는 반드시 클래스가 와야 한다.</li>
</ul>
</li>
<li>서브클래스의 constructor<ul>
<li>서브클래스에서 constructor를 생략하면 클래스에 다음과 같은 constructor가 암묵적으로 정의된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor(...args) &#123; super(...args); &#125;</span><br></pre></td></tr></table></figure></li>
<li>수퍼클래스와 서브클래스 모두 constructor를 생략하면 빈 객체가 생성된다.</li>
</ul>
</li>
<li>super 키워드<ul>
<li>super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.<ol>
<li>서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야 한다.</li>
<li>서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.</li>
<li>super는 반드시 서브클래스의 constructor에서만 호출한다. 서브클래스가 아닌 클래스의 constructor나 함수에서 super를 호출하면 에러가 발생한다.</li>
</ol>
</li>
<li>super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.<ol>
<li>서브클래스의 프로토타입 메서드 내에서 super.sayHi는 수퍼클래스의 프로토타입 메서드 sayHi를 가리킨다.</li>
<li>super 참조는 클래스의 전유물은 아니다. 객체 리터럴에서도 super 참조를 사용할 수 있다. 단, ES6의 메서드 축약 표현으로 정의된 함수만 가능하다.</li>
<li>서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킨다.</li>
</ol>
</li>
</ul>
</li>
<li>8.6. 상속 클래스의 인스턴스 생성 과정<ol>
<li>서브클래스의 super 호출<ul>
<li>서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 이것이 바로 서브클래스의 constructor에서 반드시 super를 호출해야 하는 이유다.</li>
</ul>
</li>
<li>수퍼클래스의 인스턴스 생성과 this 바인딩<ul>
<li>인스턴스는 수퍼클래스가 생성한 것이다. 하지만 new 연산자와 함께 호출된 클래스가 서브클래스라는 것이 중요하다.</li>
<li>즉, new 연산자와 함께 호출된 함수를 가리키는 new.target은 서브클래스를 가리킨다. 따라서 인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리된다.</li>
</ul>
</li>
<li>수퍼클래스의 인스턴스 초기화<ul>
<li>수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.</li>
</ul>
</li>
<li>서브클래스 constructor로의 복귀와 this 바인딩<ul>
<li>서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용한다.</li>
<li>super가 호출되지 않으면 인스턴스가 생성되지 않으며, this 바인딩도 할 수 없다. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없는 이유가 바로 이 때문이다.</li>
</ul>
</li>
<li>서브클래스의 인스턴스 초기화</li>
<li>인스턴스 반환</li>
</ol>
</li>
<li>표준 빌트인 생성자 함수 확장<ul>
<li>extends 키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.</li>
<li>String, Number, Array와 같은 표준 빌트인 객체도 [[Construct]] 내부 메서드를 갖는 생성자 함수이므로 extends 키워드를 사용하여 확장할 수 있다.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/10/201210-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%A1%9C%EC%A0%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/201210-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%A1%9C%EC%A0%80/" class="post-title-link" itemprop="url">201210-실행 컨텍스트, 클로저</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-10 12:49:10 / Modified: 12:49:28" itemprop="dateCreated datePublished" datetime="2020-12-10T12:49:10+09:00">2020-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h1><h1 id="소스코드의-타입"><a href="#소스코드의-타입" class="headerlink" title="소스코드의 타입"></a>소스코드의 타입</h1><ol>
<li>전역 코드: 전역 변수를 관리하기 위한 전역 스코프 생성. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결 -&gt; 전역 실행 컨텍스트 생성</li>
<li>지역 스코프 생성, 지역 변수, 매개변수, 아규먼츠 객체 관리, 지역 스코프를 스코프 체인에 연결. -&gt; 함수 실행 컨텍스트 생성</li>
<li>eval 코드: 뭐.</li>
<li>모듈 코드: 나중에 보나?<h1 id="소스코드의-평가와-실행"><a href="#소스코드의-평가와-실행" class="headerlink" title="소스코드의 평가와 실행"></a>소스코드의 평가와 실행</h1></li>
<li>실행 전, 소스코드의 평가.<ul>
<li>변수, 함수 등의 선언문만 먼저 실행.</li>
<li>식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록.</li>
</ul>
</li>
<li>실행(런타임)<ul>
<li>참조는 스코프에서 검색해 취득하고,</li>
<li>변수 값이 변경과 같은 실행 결과는 다시 스코프에 등록.<h1 id="실행-컨텍스트의-역할"><a href="#실행-컨텍스트의-역할" class="headerlink" title="실행 컨텍스트의 역할"></a>실행 컨텍스트의 역할</h1></li>
</ul>
</li>
</ol>
<ul>
<li>코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</li>
<li>즉,<ol>
<li>식별자를 스코프에 따라 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.</li>
<li>스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다.</li>
<li>현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</li>
</ol>
</li>
<li>이 일을 하는 게 실행 컨텍스트.</li>
<li>식별자를 등록, 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘이다.</li>
<li>식별자와 스코프는 실행 컨텍스트의 ‘렉시컬 환경’으로 관리.</li>
<li>코드 실행 순서는 ‘실행 컨텍스트 스택’으로 관리<h1 id="실행-컨텍스트-스택"><a href="#실행-컨텍스트-스택" class="headerlink" title="실행 컨텍스트 스택"></a>실행 컨텍스트 스택</h1></li>
<li>스택 자료구조.(선입후출)</li>
<li>실행되는 실행 컨텍스트가 추가(push), 실행 끝나면 삭제(pop).</li>
<li>전역 코드와 함수 코드로 구분되어서 진행 되고,</li>
<li>각 코드는 실행 전에 평가 단계를 거친다.</li>
<li>선입후출 구조로, 나중에 실행된 코드가 종료되면, 이전에 실행되던 코드로 돌아간다.</li>
<li>스택의 최상위에 존재하는 실행 컨텍스트가 현재 진행 중인 코드의 실행 컨텍스트. 이걸 ‘실행 중인 실행 컨텍스트’라고 부른다.<h1 id="렉시컬-환경"><a href="#렉시컬-환경" class="headerlink" title="렉시컬 환경"></a>렉시컬 환경</h1></li>
<li>식별자와 식별자에 비인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조.</li>
<li>즉, 식별자와 스코프를 관리한단 거지.</li>
<li>두 개를 관리해야 하네? 두 개의 컴포넌트.<ol>
<li>환경 레코드: 식별자를 등록하고 식별자에 바인딩된 값을 구분하는 저장소.</li>
<li>외부 렉시컬 환경에 대한 참조: 단방향 링크드 리스트인 스코프 체인 구현.<h1 id="실행-컨텍스트의-생성과-식별자-검색-과정"><a href="#실행-컨텍스트의-생성과-식별자-검색-과정" class="headerlink" title="실행 컨텍스트의 생성과 식별자 검색 과정"></a>실행 컨텍스트의 생성과 식별자 검색 과정</h1></li>
</ol>
</li>
</ul>
<ol>
<li>전역 객체 생성<ul>
<li>전역 객체는 전역 코드가 평가되기 이전에 생성. 빌트인 전역 프로퍼티/함수/객체 등이 있고, 동작 환경에 따라 호스트 객체를 포함.</li>
<li>이 전역 객체도 Object.prototype을 상속 받는다.</li>
</ul>
</li>
<li>전역 코드 평가<ol>
<li>전역 실행 컨텍스트 생성</li>
<li>전역 렉시컬 환경 생성<ol>
<li>전역 환경 레코드 생성</li>
<li>객체 환경 레코드 생성</li>
<li>선언적 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
<li>전역 코드 실행</li>
<li>(함수 호출을 만나면) 함수 코드 평가<ol>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ol>
<li>함수 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
<li>함수 코드 실행</li>
<li>함수 코드 실행 종료</li>
<li>전역 코드 실행 종료<h1 id="실행-컨텍스트와-블록-레벨-스코프"><a href="#실행-컨텍스트와-블록-레벨-스코프" class="headerlink" title="실행 컨텍스트와 블록 레벨 스코프"></a>실행 컨텍스트와 블록 레벨 스코프</h1></li>
</ol>
<ul>
<li>소스코드는 전역 코드와 함수 코드로 구분하니까,</li>
<li>블록 레벨 스코프의 코드 블록은 따로 실행 컨텍스트를 만들지 않는다.</li>
<li>근데 let/const는 블록 레벨 스코프를 만들잖아?</li>
<li>이를 위해 블록 레벨 스코프는,</li>
<li>선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.</li>
<li>즉, 실행 컨텍스트는 그대로 둔 상태에서,</li>
<li>연결되어 있던 렉시컬 환경을 ‘선언적 환경 레코드를 갖는 렉시컬 환경’으로 교체.</li>
<li>새로 연결된 렉시컬 환경은 기존의 렉시컬 환경을 상위 스코프로 갖는다.</li>
<li>코드 블록이 끝나면, 이전의 렉시컬 환경으로 복귀.</li>
<li>만약 코드 블록 내에 함수가 있다면, 이 함수의 상위 스코프는 코드 블록이 생성한 렉시컬 환경(선언적 환경 레코드를 갖는 렉시컬 환경).</li>
</ul>
<hr>
<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><ul>
<li>중첩 함수에서,</li>
<li>내부 함수가 외부 함수보다 오래 살아남으며,</li>
<li>외부 함수가 갖는 식별자를 내부 함수가 참조할 때,</li>
<li>그 내부 함수를 클로저라고 부른다.<h1 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h1></li>
<li>렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.<h1 id="함수-객체의-내부-슬롯-Envirobnment"><a href="#함수-객체의-내부-슬롯-Envirobnment" class="headerlink" title="함수 객체의 내부 슬롯 [[Envirobnment]]"></a>함수 객체의 내부 슬롯 [[Envirobnment]]</h1></li>
<li>함수 객체는 호출과 상관없이, 자신이 정의된 환경, 상위 스코프를 기억해야 한다.</li>
<li>이를 위해 함수 객체는 함수 정의가 평가 될 때,(런타임 이전에) 내부 슬롯 [[Environment]] 에 상위 스코프의 참조를 저장한다.</li>
<li>이 상위 스코프는 ‘현재 실행 중인 실행 컨텍스트’의 렉시컬 환경이다.</li>
<li>내부 슬롯에 기억하므로, 함수객체가 존재하는 한, 함수는 상위 스코프를 기억한다.</li>
<li>후에 함수가 호출 되어 함수 코드가 평가되기 시작하면,</li>
<li>함수 렉시컬 환경의 구성 요소인 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.<h1 id="클로저와-렉시컬-환경"><a href="#클로저와-렉시컬-환경" class="headerlink" title="클로저와 렉시컬 환경"></a>클로저와 렉시컬 환경</h1></li>
<li>중첩 함수에서, 외부 함수가 실행이 종료 되었을 때,</li>
<li>외부 함수의 실행 컨텍스트는 스택에서 제거되지만, 렉시컬 환경까지 소멸하는 것은 아니다.(가비지 컬렉터가 처리하지 않는다.)</li>
<li>내부 함수의 [[Environment]]에 의해 참조되고 있기 때문.</li>
<li>내부 함수가 다른 곳(변수 등)에서 참조되고 있다면,</li>
<li>외부 함수 없이 내부 함수를 호출할 수 있고, 이 때 외부 함수 객체의 변수에도 접근할 수 있다.</li>
<li>모든 함수는 상위 스코프를 기억하므로, 이론적으로 모든 함수는 클로저지만,</li>
<li>일반적으로 모든 함수를 클로저라고는 하지 않는다.</li>
<li>클로저는,<ol>
<li>상위 스코프의 식별자를 참조한다.</li>
<li>상위 스코프보다 생명 주기가 길다.</li>
</ol>
</li>
<li>를 만족해야 한다.</li>
<li>클로저에 의해 참조되는 상위 스코프의 변수는 ‘자유 변수’.<h1 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h1></li>
<li>클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 카운트 상태 변경 함수</span><br><span class="line">const increase &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저</span><br><span class="line">  return function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 카운트 상태를 1만큼 증가 시킨다.</span><br><span class="line">    return ++num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 2</span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저인 메서드를 갖는 객체를 반환한다.</span><br><span class="line">  &#x2F;&#x2F; 객체 리터럴은 스코프를 만들지 않는다.</span><br><span class="line">  &#x2F;&#x2F; 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F; num: 0, &#x2F;&#x2F; 프로퍼티는 public하므로 은닉되지 않는다.</span><br><span class="line">    increase() &#123;</span><br><span class="line">      return ++num;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrease() &#123;</span><br><span class="line">      return num &gt; 0 ? --num : 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const Counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; ① 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  function Counter() &#123;</span><br><span class="line">    &#x2F;&#x2F; this.num &#x3D; 0; &#x2F;&#x2F; ② 프로퍼티는 public하므로 은닉되지 않는다.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter.prototype.increase &#x3D; function () &#123;</span><br><span class="line">    return ++num;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Counter.prototype.decrease &#x3D; function () &#123;</span><br><span class="line">    return num &gt; 0 ? --num : 0;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return Counter;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const counter &#x3D; new Counter();</span><br><span class="line"></span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure></li>
<li>변수 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 외부 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.</li>
<li>아래의 클로저는, 내용은 같지만 서로 다른 렉시컬 환경을 참조하는 클로저<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수를 인수로 전달받고 함수를 반환하는 고차 함수</span><br><span class="line">&#x2F;&#x2F; 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.</span><br><span class="line">function makeCounter(predicate) &#123;</span><br><span class="line">&#x2F;&#x2F; 카운트 상태를 유지하기 위한 자유 변수</span><br><span class="line">let counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저를 반환</span><br><span class="line">  return function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.</span><br><span class="line">    counter &#x3D; predicate(counter);</span><br><span class="line">    return counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function increase(n) &#123;</span><br><span class="line">  return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function decrease(n) &#123;</span><br><span class="line">  return --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수로 함수를 생성한다.</span><br><span class="line">&#x2F;&#x2F; makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환한다</span><br><span class="line">const increaser &#x3D; makeCounter(increase); &#x2F;&#x2F; ①</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.</span><br><span class="line">const decreaser &#x3D; makeCounter(decrease); &#x2F;&#x2F; ②</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -1</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -2</span><br></pre></td></tr></table></figure></li>
<li>아래와 같이 수정<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수를 반환하는 고차 함수</span><br><span class="line">&#x2F;&#x2F; 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.</span><br><span class="line">const counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태를 유지하기 위한 자유 변수</span><br><span class="line">  let counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 함수를 인수로 전달받는 클로저를 반환</span><br><span class="line">  return function (predicate) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.</span><br><span class="line">    counter &#x3D; predicate(counter);</span><br><span class="line">    return counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function increase(n) &#123;</span><br><span class="line">  return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function decrease(n) &#123;</span><br><span class="line">  return --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수를 전달하여 호출</span><br><span class="line">console.log(counter(increase)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter(increase)); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 자유 변수를 공유한다.</span><br><span class="line">console.log(counter(decrease)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter(decrease)); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<h1 id="캡슐화와-정보-은닉"><a href="#캡슐화와-정보-은닉" class="headerlink" title="캡슐화와 정보 은닉"></a>캡슐화와 정보 은닉</h1></li>
<li>캡슐화(encapsulation)는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉(information hiding)이라 한다.</li>
<li>즉시 실행 함수를 활용하여 생성자 함수와 프로토타입 프로퍼티 추가를 묶음.</li>
<li>이 경우 클로저를 단 한번 생성하기 대문에, 인스턴스가 여러 개 만들어지면 동일한 상위 스코프를 사용하게 된다.</li>
<li>자바스크립트는 정보 은닉을 완전하게 지원하지 않는다. 인스턴스 메서드를 사용한다면 자유 변수를 통해 private을 흉내 낼 수는 있지만 프로토타입 메서드를 사용하면 이마저도 불가능해진다.</li>
<li>클래스에 private 필드를 정의할 수 있는 표준 사양이 제안되어 있는데, 이건 나중에.<h1 id="자주-발생하는-실수"><a href="#자주-발생하는-실수" class="headerlink" title="자주 발생하는 실수"></a>자주 발생하는 실수</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  funcs[i] &#x3D; function () &#123; return i; &#125;; &#x2F;&#x2F; ①</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var j &#x3D; 0; j &lt; funcs.length; j++) &#123;</span><br><span class="line">  console.log(funcs[j]()); &#x2F;&#x2F; ②</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 레벨 스코프 특성으로 인해 for 문의 초기화 문에서 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상.</li>
<li>아래처럼 수정할 수 있는데,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">  funcs[i] &#x3D; (function (id) &#123; &#x2F;&#x2F; ①</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return id;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var j &#x3D; 0; j &lt; funcs.length; j++) &#123;</span><br><span class="line">  console.log(funcs[j]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let을 사용하면 깔금하게 해결.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  funcs[i] &#x3D; function () &#123; return i; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; funcs.length; i++) &#123;</span><br><span class="line">  console.log(funcs[i]()); &#x2F;&#x2F; 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let/const 선언을 사용하면, 블록 레벨 스코프가 적용 되어, for문의 코드 블록이 실행될 때마다 새로운 렉시컬 환경이 만들어진다.</li>
<li>이 때 코드 블록 내에 정의한 함수가 있다면, 이 함수의 상위 스코프는 새로운 렉시컬 환경이 된다.</li>
<li>독립적인 렉시컬 환경을 각각 갖으므로, 식별자의 값을 유지할 수 있다.</li>
<li>단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.</li>
<li>고차 함수를 사용하는 방법도 있는데, 나중에 다시 배움.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/08/201206-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/201206-this/" class="post-title-link" itemprop="url">201206-this</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-08 14:47:18 / Modified: 14:47:31" itemprop="dateCreated datePublished" datetime="2020-12-08T14:47:18+09:00">2020-12-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ul>
<li>객체는 상태를 나타내는 프로퍼티와, 동작을 나타내는 메서드를 묶은 복합적인 자료구조.</li>
<li>그 중에 메서드는, 자신이 속한 객체의 상태(프로퍼티)를 참조하고 변경할 수 있어야 하는데,</li>
<li>그러려면 메서드가 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야지.</li>
<li>그래서 자바스크립트는 this라는 특수한 식별자를 제공한다.</li>
<li>즉, this는 자신이 속한 객체, 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수.</li>
<li>this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프프로퍼티나 메서드를 참조할 수 있다.</li>
<li>this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있는데,</li>
<li>this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.<h1 id="함수-호출-방식과-this-바인딩"><a href="#함수-호출-방식과-this-바인딩" class="headerlink" title="함수 호출 방식과 this 바인딩"></a>함수 호출 방식과 this 바인딩</h1></li>
<li>함수 호출 방식(일반 함수 호출, 메서드 호출, 생성자 함수 호출, Function.prototype.apply/call/bind 메서드에 의한 간접 호출)에 따라 this 바인딩이 결정.</li>
</ul>
<ol>
<li>일반 함수 호출<ul>
<li>전역 객체가 바인딩 된다.</li>
<li>중첩, 콜백 함수도 일반 함수로 호출이 되면 전역 객체에 바인딩.</li>
<li>여기서 중첩, 콜백 함수의 this가 전역 객체를 바인딩하는 것은 문제가 있다.</li>
<li>이 둘은 보통 헬퍼 함수의 역할을 하는데, 외부 함수와 this 바인딩이 다르면 헬퍼 함수 역할을 하기 힘들어.</li>
<li>그래서 이런 식으로 쓰지.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; this 바인딩(obj)을 변수 that에 할당한다.</span><br><span class="line">    const that &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 콜백 함수 내부에서 this 대신 that을 참조한다.</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(that.value); &#x2F;&#x2F; 100</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Function.protytype.apply/call/bind를 쓰기도 해<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 콜백 함수에 명시적으로 this를 바인딩한다.</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(this.value); &#x2F;&#x2F; 100</span><br><span class="line">    &#125;.bind(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>화살표 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.</span><br><span class="line">    setTimeout(() &#x3D;&gt; console.log(this.value), 100); &#x2F;&#x2F; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>메서드 호출<ul>
<li>메서드를 호출한 객체와 바인딩.</li>
<li>메서드를 소유한 객체와 바인딩되는 게 아님.</li>
<li>왜냐면, 메서드를 소유한 객체라는 건, 사실 그 객체의 프로퍼티 키가 독립적으로 존재하는 함수 객체를 바인딩하고 있는 것일 뿐이니까.</li>
<li>이 독립적인 함수 객체는 여러 곳에 바인딩될 수 있어.</li>
<li>변수든, 다른 메서드든.</li>
<li>즉, this 바인딩은 메서드를 소유한 객체와 되는 게 아니라, 메서드를 호출한 객체와 바인딩.</li>
</ul>
</li>
<li>생성자 함수 호출<ul>
<li>생성자 함수가 생성할 인스턴스와 바인딩.</li>
</ul>
</li>
<li>Function.prototype.apply/call/bind 메서드에 의한 간접 호출<ul>
<li>apply, call, bind 메서드는 Function.prototype의 메서드. -&gt; 모든 함수가 상속받아 사용 가능.</li>
<li>Function.prototype.apply, Function.prototype.call 메서드는 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 ‘호출’한다.(호출하려고 쓰는 메서드임.)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getThisBinding() &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; this로 사용할 객체</span><br><span class="line">const thisArg &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span><br><span class="line">&#x2F;&#x2F; apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.</span><br><span class="line">console.log(getThisBinding.apply(thisArg, [1, 2, 3]));</span><br><span class="line">&#x2F;&#x2F; Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">&#x2F;&#x2F; &#123;a: 1&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.</span><br><span class="line">console.log(getThisBinding.call(thisArg, 1, 2, 3));</span><br><span class="line">&#x2F;&#x2F; Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">&#x2F;&#x2F; &#123;a: 1&#125;</span><br></pre></td></tr></table></figure></li>
<li>apply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우.</li>
<li>arguments 객체는 배열이 아닌 유사 배열 객체기 때문에, 배열의 메서드를 사용할 수 없다.</li>
<li>그때, apply나 call을 써서 배열을 전달해주면,</li>
<li>배열 메서드를 쓸 수 있게 할 수 있다.</li>
<li>자세한 내용은 후에 배열을 다루면서.</li>
<li>Function.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다.</li>
<li>bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  foo(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; bind 메서드로 callback 함수 내부의 this 바인딩을 전달</span><br><span class="line">    setTimeout(callback.bind(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.foo(function () &#123;</span><br><span class="line">  console.log(&#96;Hi! my name is $&#123;this.name&#125;.&#96;); &#x2F;&#x2F; Hi! my name is Lee.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/03/201204-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/201204-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/" class="post-title-link" itemprop="url">201204- 함수와 일급 객체, 프로토타입, 빌트인 객체</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-03 20:36:23 / Modified: 20:36:35" itemprop="dateCreated datePublished" datetime="2020-12-03T20:36:23+09:00">2020-12-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h1 id="일급-객체"><a href="#일급-객체" class="headerlink" title="일급 객체"></a>일급 객체</h1><ul>
<li>일급 객체의 조건<ol>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
</ol>
</li>
<li>자바스크립트의 함수는 위의 조건을 모두 만족하므로, 일급 객체다.</li>
<li>객체왈 동일하게 사용할 수 있단 의미이고,</li>
<li>값과 동일하게 취급,</li>
<li>값을 사용하는 곳이라면 어디든지 리터럴로 정의 가능,</li>
<li>런타임에 함수 객체로 평가.</li>
<li>객체와 같지만, 일반 객체에는 없는 함수 고유의 프로퍼티를 갖는다.<h1 id="함수-객체의-프로퍼티"><a href="#함수-객체의-프로퍼티" class="headerlink" title="함수 객체의 프로퍼티"></a>함수 객체의 프로퍼티</h1></li>
<li>arguments, caller, length, name, propotype.</li>
<li>특히, __proto__는 접근자 프로퍼티로, Object.prototype 객체의 프로퍼티를 상속 받은 것.</li>
<li>Object.prototype의 프로퍼티로 모든 객체가 사용할 수 있다.(프로토타입)</li>
</ul>
<ol>
<li>arguments: 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한(이터러블iterable) 유사 배열 객체. 인수를 프로퍼티 값으로 가지며, 프로퍼티 키는 인수의 순서. length프로퍼티는 인수의 개수, callee 프로퍼티는 arguments 객체를 생성한 함수, 즉 자기 자신. 가변 인자 함수를 구현할 때 유용하다.</li>
<li>caller: 함수 자신을 호출한 함수. 사양에 포함되지 않은 비표준 프로퍼티이며, 앞으로 표준화 예정도 없다.</li>
<li>length: 함수를 정의할 때 선언한 매개변수의 개수.</li>
<li>name: 함수 이름. 익명 함수 표현식의 경우, ES5에서는 빈 문자열. ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.</li>
<li><strong>proto</strong>: [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 ‘접근자 프로퍼티’. </li>
<li>ptrototype: constructor 함수만 갖는 프로퍼티로, 함수가 객체를 생성하는 생성자 함수로 호출될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</li>
</ol>
<hr>
<h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><ul>
<li>자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어.</li>
<li>ES6부터 도입된 클래스. 새로운 객체 생성 메커니즘이다.<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1></li>
<li>실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도.</li>
<li>실체는 특징이나 성질을 나타내는 속성(attribute/property)을 가지고 있고, 이를 통해 실체를 인식, 구분.</li>
<li>이러한 방식으로, 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현하는 것이 추상화.</li>
<li>이 추상화를 통해 객체를 다른 객체와 구별할 수 있다.</li>
<li>즉, 객체는 여러 개의 값(속성)을 하나의 단위로 구성한 복합적인 자료구조.</li>
<li>객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.</li>
<li>이 때,</li>
<li>객체의 속성은 상태(프로퍼티), 동작(메서드)로 구분할 수 있다.</li>
<li>이 상태와 동작을 하나의 논리적인 단위로 묶은 게 함수고, 객체는 다른 객체와 메시지를 주고 받거나 데이터를 처리하거나,</li>
<li>다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다.(상속)<h1 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h1></li>
<li>상속은 객체지향 프로그래밍의 핵심 개념(코드의 재사용으로 개발 비용을 줄일 수 있는 잠재력이 있다)으로, 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.</li>
<li>가령, Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, Cicle.prototype의 모든 프로퍼티와 메서드를 상속받는다.</li>
<li>인스턴스에서 공통적으로 사용될 프로퍼티나 메서드를 Circle.prototype에 구현해두면?</li>
<li>모든 인스턴스가 상속받아 사용할 수 있는 거지.<h1 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h1></li>
<li>상속을 구현(목적)으로 사용.</li>
<li>모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값이 프로토타입의 참조.(null인 경우도 있다.)</li>
<li>동시에 프로토타입은 생성자 함수와 연결되어 있다.</li>
<li>생성자 함수 &lt;-&gt; 프로토타입 &lt;- 객체</li>
<li>객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근할 수 있으며,</li>
<li>프로토타입은 자신의 constructor프로퍼티를 통해 생성자 함수에 접근할 수 있고,</li>
<li>생성자 함수는 prototype프로퍼티를 통해 프로토타입에 접근할 수 있다.<h1 id="prototype-접근자-프로퍼티"><a href="#prototype-접근자-프로퍼티" class="headerlink" title="prototype 접근자 프로퍼티"></a><strong>prototype</strong> 접근자 프로퍼티</h1></li>
</ul>
<ol>
<li><strong>proto</strong> 는 접근자 프로퍼티다.<ul>
<li>getter/setter 함수를 통해 프로토타입을 취득하거나 할당.</li>
<li>프로토타입을 부르거나, 교체할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티는 상속을 통해 사용된다.<ul>
<li>기본적으로 __proto__는 Object.prototype의 프로퍼티.</li>
<li>모든 객체의 프로토타입 체인상 끝에는 Object.prototype이 있으므로,</li>
<li>__proto__를 상속받아 사용할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유.<ul>
<li>__proto__은 순환참조를 막도록 구현되어 있다.</li>
<li>단방향 리크드 리스트로 프로토타입 체인을 구현할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.<ul>
<li>직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 만들 수 있다.</li>
<li>이 경우 __proto__를 사용할 수 없으므로,</li>
<li>Object.getPrototypeOf, Object.setPrototypeOf 메서드를 사용한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 취득</span><br><span class="line">Object.getPrototypeOf(obj); &#x2F;&#x2F; obj.__proto__;</span><br><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 교체</span><br><span class="line">Object.setPrototypeOf(obj, parent); &#x2F;&#x2F; obj.__proto__ &#x3D; parent;</span><br></pre></td></tr></table></figure>
<h1 id="함수-객체의-prototype-프로퍼티"><a href="#함수-객체의-prototype-프로퍼티" class="headerlink" title="함수 객체의 prototype 프로퍼티"></a>함수 객체의 prototype 프로퍼티</h1></li>
</ul>
</li>
</ol>
<ul>
<li>생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</li>
<li>화살표 함수와 메서드 축약 표현으로 정의한 메서드는 non-constructor 함수로, prototype 프로퍼티를 가질 이유가 없지.</li>
<li>생성자 함수를 목적으로 만들지 않은 함수도 prototype 프로퍼티를 가지고는 있다. 의미는 없지만.<h1 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h1></li>
<li>prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</li>
<li>프로토타입 체인 상 자식 역할의 객체도 상속받아 사용할 수 있다.<h1 id="리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h1></li>
<li>일단 결론은, Object.prototype을 프로토타입으로 갖는다.</li>
<li>리터럴이 평가 될 때는 추상연산 OrdinaryObjectCreate가 호출되어 객체 등을 만드는데,</li>
<li>프로퍼티 추가 처리 등의 세부 내용은 다르지만,</li>
<li>추상연산을 호출한다는 점에서 Object() 함수를 이용한 방법과 동일하다.</li>
<li>즉, 리터럴로 만든 객체, 함수, 배열, 정규 표현식은 각각 Object, Function, Array, RegExp 생성자 함수로 만든 각각과 같은 프로토타입을 갖는다.<h1 id="프로토타입의-생성-시점"><a href="#프로토타입의-생성-시점" class="headerlink" title="프로토타입의 생성 시점"></a>프로토타입의 생성 시점</h1></li>
<li>생성자 함수가 생성되는 시점과 같다.</li>
<li>즉 생성자 함수가 생성되면 동시에 프로토타입도 준비하는 건데,</li>
<li>생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분할 수 있다.</li>
</ul>
<ol>
<li>사용자 정의 생성자 함수와 프로토타입 생성 시점<ul>
<li>함수 정의가 평가 되어 함수 객체를 생성하는 시점에 프로토타입도 생성.</li>
<li>그게 언제야?</li>
<li>함수 선언문으로 정의된 생성자 함수는 런타임 이전에 평가.</li>
<li>그때 만드는 거지, 뭐.</li>
<li>이렇게 만들어진 프로토타입의 프로토타입은? Object.prototype.</li>
</ul>
</li>
<li>빌트인 생성자 함수와 프로토타입 생성 시점<ul>
<li>모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성.</li>
<li>이 때 같이 만들어지지.</li>
</ul>
</li>
</ol>
<ul>
<li>즉, 프로토타입은 이미 만들어져 준비되어 있는 거다!<h1 id="객체-생성-방식과-프로토타입의-결정"><a href="#객체-생성-방식과-프로토타입의-결정" class="headerlink" title="객체 생성 방식과 프로토타입의 결정"></a>객체 생성 방식과 프로토타입의 결정</h1></li>
<li>어떤 방식이든 추상연산 OrdinaryObjectCreate를 호출하는 건 동일,</li>
<li>이 때 인수로 주어지는 프로토타입이 다른 거야.<h1 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h1></li>
<li>사용자 정의 생성자 함수로 만들어진 프로토타입은 Object.prototype을 프로토타입으로 갖고,</li>
<li>그 생성자 함수로 만든 객체는 그 함수.prototype을 프로토타입으로 가져,</li>
<li>셋은 연결된다.</li>
<li>이게 프로토타입 체인.</li>
<li>객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 그 프로퍼티가 없으면 상위 프로토타입을 따라 가며 찾는다.</li>
<li>Object.prototype은 프로토타입 체인의 종점인데,</li>
<li>여기까지 가서도 찾는 프로퍼티가 없으면 undefined.</li>
<li>프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이다.</li>
<li>앞서 다뤘던 스코프 체인과 비슷하게 움직이는데,</li>
<li>둘은 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용한다.<h1 id="오버라이딩과-프로퍼티-섀도잉"><a href="#오버라이딩과-프로퍼티-섀도잉" class="headerlink" title="오버라이딩과 프로퍼티 섀도잉"></a>오버라이딩과 프로퍼티 섀도잉</h1></li>
<li>상속받아 사용하던 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가했을 때,</li>
<li>프로토타입 프로퍼티에 덮어쓰는 게 아니라, 인스턴스 프로퍼티로 추가.</li>
<li>사용되어지는 것도 인스턴스 프로퍼티.</li>
<li>삭제하면 없어지는 것도 인스턴스 프로퍼티.</li>
<li>이 때, 인스턴스 프로퍼티가 프로토타입 메서드를 ‘오버라이딩’ 했고, 이렇게 가려지는 현상을 ‘프로퍼티 섀도잉’ 이라고 한다.<h1 id="프로토타입의-교체"><a href="#프로토타입의-교체" class="headerlink" title="프로토타입의 교체"></a>프로토타입의 교체</h1></li>
</ul>
<ol>
<li>생성자 함수에 의한 프로토타입의 교체<ul>
<li>프로토타입으로 쓸 객체를 재할당 하면 되지.</li>
<li>이때 교체한 프로토타입에는 constructor 프로퍼티가 없지.</li>
<li>따라서 인스턴스의 생성자 함수를 찾으면 상위의 Object가 나올 거야.</li>
<li>동적 추가로 새 프로토타입에 constructor 프로퍼티를 만들 수 있다.</li>
</ul>
</li>
<li>인스턴스에 의한 프로토타입의 교체<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(me, parent);</span><br><span class="line">&#x2F;&#x2F; 위 코드는 아래의 코드와 동일하게 동작한다.</span><br><span class="line">&#x2F;&#x2F; me.__proto__ &#x3D; parent;</span><br></pre></td></tr></table></figure>
<ul>
<li>이 경우도 새 프로토타입이 constructor가 없지</li>
<li>그건 위와 같지만,</li>
<li>차이는 생성자 함수의 prototype 프로퍼티가 새 프로토타입을 가리키냐 아니냐.</li>
<li>이것도 재설정 할수 있다.(재할당)</li>
</ul>
</li>
</ol>
<ul>
<li>이처럼 프로토타입 교체를 통해 상속 관계를 변경하는 것은 번거롭다.</li>
<li>직접 상속이나 클래스가 편함.<h1 id="instanceof-연산자"><a href="#instanceof-연산자" class="headerlink" title="instanceof 연산자"></a>instanceof 연산자</h1></li>
<li>좌항에 위차한 객체의 프로토타입 체인에, 우변의 생성자 함수가 있으면 트루, 아니먼 펄스.</li>
<li>프로토타입인지를 확인하는 게 아니라, 프로토타입 체인에 존재하는지를 확인한다.<h1 id="직접-상속"><a href="#직접-상속" class="headerlink" title="직접 상속"></a>직접 상속</h1></li>
</ul>
<ol>
<li>Object.create에 의한 직접 상속<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj &#x3D; Object.create(Object.prototype);</span><br></pre></td></tr></table></figure>
<ul>
<li>new 연산자 없이도 객체를 생성할 수 있다.</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다.</li>
<li>객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.</li>
<li>그런데,</li>
<li>const obj = Object.create(null); 처럼 프로토타입 체인의 종점에 해당하는 객체를 만들 수도 있다.</li>
<li>이때 Object.prototype 빌트인 메서드를 사용할 수 없으므로, 빌트인 메서드는 간접적으로 호출해서 써야 하는데,</li>
<li>이 방법은 나중에.</li>
</ul>
</li>
<li>객체 리터럴 내부에서 <strong>proto</strong> 에 의한 직접 상속<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  y: 20,</span><br><span class="line">  &#x2F;&#x2F; 객체를 직접 상속받는다.</span><br><span class="line">  &#x2F;&#x2F; obj → myProto → Object.prototype → null</span><br><span class="line">  __proto__: myProto</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="정적-프로퍼티-메서드"><a href="#정적-프로퍼티-메서드" class="headerlink" title="정적 프로퍼티/메서드"></a>정적 프로퍼티/메서드</h1></li>
</ol>
<ul>
<li>생성자 함수가 가지고 있는 프로퍼티/메서드.</li>
<li>프로토타입에 있는 프로퍼티/메서드가 아니므로, 인스턴스가 참조/호출할 수 없지만,</li>
<li>직접 호출할 수는 있다.</li>
<li>참고로 프로토타입 프로퍼티/메서드를 표기할 때 prototype을 #으로 표기(예를 들어, Object.prototype.isPrototypeOf를 Object#isPrototypeOf으로 표기)하는 경우도 있으니 알아두도록 하자.<h1 id="프로퍼티-존재-확인"><a href="#프로퍼티-존재-확인" class="headerlink" title="프로퍼티 존재 확인"></a>프로퍼티 존재 확인</h1></li>
</ul>
<ol>
<li>in 연산자<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체에 name 프로퍼티가 존재한다.</span><br><span class="line">console.log(&#39;name&#39; in person);    &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<ul>
<li>객체 내 프로퍼티가 존재하는지 여부 확인.</li>
<li>상속받은 모든 프로퍼티를 확인한다.</li>
<li>같은 동작으로<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflect.has(person, &#39;name&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Object.prototype.hasOwnProperty 메서드<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.hasOwnProperty(&#39;name&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li>상속받은 프로퍼티는 빼고, 객체 고유의 프로퍼티인 경우에만 트루.<h1 id="프로퍼티-열거"><a href="#프로퍼티-열거" class="headerlink" title="프로퍼티 열거"></a>프로퍼티 열거</h1></li>
</ul>
</li>
<li>for…in 문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.</span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">  console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name: Lee</span><br><span class="line">&#x2F;&#x2F; address: Seoul</span><br></pre></td></tr></table></figure>
<ul>
<li>in 연산자처럼 상속받은 프로퍼티까지 열거.</li>
<li>단 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false인 경우는 열거 안함.</li>
<li>상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티 만을 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용해서 방어코드 작성.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;,</span><br><span class="line">  __proto__: &#123; age: 20 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">  &#x2F;&#x2F; 객체 자신의 프로퍼티인지 확인한다.</span><br><span class="line">  if (!person.hasOwnProperty(key)) continue;</span><br><span class="line">  console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name: Lee</span><br><span class="line">&#x2F;&#x2F; address: Seoul</span><br></pre></td></tr></table></figure></li>
<li>for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다.</li>
<li>배열에는 for 문이나 for…of 문 또는 Array.prototype.forEach 메서드를 사용하기를 권장. 배열에서 다시.</li>
</ul>
</li>
<li>Object.keys/values/entries 메서드<ul>
<li>객체 자신의 고유 프로퍼티만 열거.</li>
<li>Object.keys: 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.</li>
<li>Object.values: 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.</li>
<li>Object.entries: 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="빌트인-객체"><a href="#빌트인-객체" class="headerlink" title="빌트인 객체"></a>빌트인 객체</h1><h1 id="자바스크립트-객체의-분류"><a href="#자바스크립트-객체의-분류" class="headerlink" title="자바스크립트 객체의 분류"></a>자바스크립트 객체의 분류</h1><ol>
<li>표준 빌트인 객체: ECMAScript 사양에 정의된 객체. 애플리케이션 전역의 공통 기능을 제공. 전역 객체의 프로퍼티로서 제공된다. 따라서, 별도의 선언없이 언제나 참조할 수 있다.</li>
<li>호스트 객체: 자바스크립트 실행 환경이 추가로 제공하는 객체.</li>
<li>사용자 정의 객체: 사용자가 직접 정의한 객체<h1 id="표준-빌트인-객체"><a href="#표준-빌트인-객체" class="headerlink" title="표준 빌트인 객체"></a>표준 빌트인 객체</h1></li>
</ol>
<ul>
<li>Objet, String, Number, Boolean, Symbol, Date, Math, Array 등, 자바스크립트가 제공하는 표준 빌트인 객체.</li>
<li>Math, Reflect, JSON을 제외한 모든 표준 빌트인 객체는 인스턴스를 생성할 수 있다.</li>
<li>인스턴스를 생성할 수 있단 건, 정적 메서드와 프로토타입 메서드를 제공한다는 거지.</li>
<li>아닌 건 정적 메서드만 제공하는 거고.</li>
<li>표준 빌트인 객체가 생성한 인스턴스의 프로토타입은, 그 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.</li>
<li>이 프로토타입이 다양한 프로토타입 메서드를 제공.<h1 id="원시값과-래퍼-객체"><a href="#원시값과-래퍼-객체" class="headerlink" title="원시값과 래퍼 객체"></a>원시값과 래퍼 객체</h1></li>
<li>원시값을 마치 객체처럼 접근할 수 있는데(ex. str.length),</li>
<li>이 때 자바스크립트 엔진은 일시적으로 원시값을 연관된 객체로 변환.</li>
<li>객체로 아주 바꾸는 건 아니고, 할 일 다 하면 버림.</li>
<li>아무튼 이때 생성되는 임시 객체를 ‘래퍼 객체’라 한다.</li>
<li>객체가 되었으니 프로토타입의 메서드를 갖다 쓸 수도 있지.</li>
<li>문자열, 숫자, 불리언, 심벌이 이렇게 움직이는데,</li>
<li>불리언은 쓸 일이 없고, 심벌은 나중에 배움.</li>
<li>그외 null과 undefined는 래퍼 객체를 생성하지 않는다.<h1 id="전역-객체"><a href="#전역-객체" class="headerlink" title="전역 객체"></a>전역 객체</h1></li>
<li>코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.</li>
<li>프로토타입 체인상 최상위는 아님. 당연하지. 프로토타입이 아닌데.<h1 id="빌트인-전역-프로퍼티"><a href="#빌트인-전역-프로퍼티" class="headerlink" title="빌트인 전역 프로퍼티"></a>빌트인 전역 프로퍼티</h1></li>
<li>전역 객체의 프로퍼티.<br>주로 애플리케이션 전역에서 사용하는 값을 제공.</li>
</ul>
<ol>
<li>Infinity</li>
<li>NaN</li>
<li>undefined<h1 id="빌트인-전역-함수"><a href="#빌트인-전역-함수" class="headerlink" title="빌트인 전역 함수"></a>빌트인 전역 함수</h1></li>
</ol>
<ul>
<li>전역 객체의 메서드</li>
<li>전역에서 호출 가능.</li>
</ul>
<ol>
<li>eval<ul>
<li>금지라는데 일아야 하나?</li>
</ul>
</li>
<li>isFinite<ul>
<li>전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환하고, 무한수이면 false를 반환한다.</li>
<li>NaN으로 평가되면 false.</li>
<li>null은 0으로 변환되므로 true.</li>
</ul>
</li>
<li>isNaN<ul>
<li>전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.</li>
</ul>
</li>
<li>parseFloat<ul>
<li>전달받은 문자열 인수를 실수로 해석(parsing)하여 반환.</li>
</ul>
</li>
<li>parseInt<ul>
<li>전달받은 문자열 인수를 정수(integer)로 해석(parsing)하여 반환.</li>
<li>두 번째 인수로 진법을 나타내는 기수(2 ~ 36)를 전달할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#39;10&#39;을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다</span><br><span class="line">parseInt(&#39;10&#39;, 2); &#x2F;&#x2F; -&gt; 2</span><br></pre></td></tr></table></figure></li>
<li>기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메서드(“28.3.8. Number.prototype.toString” 참고)를 사용.</li>
</ul>
</li>
<li>encodeURI / decodeURI<ul>
<li>encodeURI 함수는 완전한 URI(Uniform Resource Identifier)를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.</li>
</ul>
</li>
<li>encodeURIComponent / decodeURIComponent<ul>
<li>encodeURIComponent 함수는 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. <h1 id="암묵적-전역"><a href="#암묵적-전역" class="headerlink" title="암묵적 전역"></a>암묵적 전역</h1></li>
</ul>
</li>
</ol>
<ul>
<li>선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다.</li>
<li>전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다.</li>
<li>변수는 아니므로, 호이스팅은 발생하지 않는다.</li>
<li>단지 프로퍼티니까, delete 연산자로 삭제할 수 있다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bg-shorthand</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bg-shorthand</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
