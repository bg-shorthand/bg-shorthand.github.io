<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bg-shorthand.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="bg-shorthand-blog">
<meta property="og:url" content="http://bg-shorthand.github.io/index.html">
<meta property="og:site_name" content="bg-shorthand-blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="bg-shorthand">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://bg-shorthand.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>bg-shorthand-blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bg-shorthand-blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/29/201130-let-const%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/29/201130-let-const%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">201130 let, const와 블록 레벨 스코프, 프로퍼티 어트리뷰트</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-29 17:16:06 / Modified: 17:16:27" itemprop="dateCreated datePublished" datetime="2020-11-29T17:16:06+09:00">2020-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록-레벨-스코프"><a href="#let-const와-블록-레벨-스코프" class="headerlink" title="let, const와 블록 레벨 스코프"></a>let, const와 블록 레벨 스코프</h1><h1 id="var-키워드로-선언한-변수의-문제점"><a href="#var-키워드로-선언한-변수의-문제점" class="headerlink" title="var 키워드로 선언한 변수의 문제점"></a>var 키워드로 선언한 변수의 문제점</h1><ol>
<li>변수 중복 선언 허용<ul>
<li>var 키워드로 선언한 변수는 중복 선언을 허용한다.</li>
<li>중복 선언의 경우, 초기화문의 유무에 따라 다르게 동작.</li>
<li>초기화문이 있는 변수 선언문은 자바스크립트에 의해 var 키워드가 없는 것처럼(할당문만 있는 것처럼) 동작하고,</li>
<li>초기화문이 없는 변수 선언문은 무시된다.</li>
<li>변수 중복 선언은 의도치 않게 변수 값이 변경되는 부작용을 낳는다.</li>
</ul>
</li>
<li>함수 레벨 스코프<ul>
<li>var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.</li>
<li>함수 외부(if나 for 문의 블록 안쪽이더라도,)에서 선언한 변수는 모두 전역 변수가 된다.</li>
<li>전역 변수를 남발하게 되고, 중복 선언이 되는 경우가 발생한다.</li>
</ul>
</li>
<li>변수 호이스팅<ul>
<li>호이스팅에 의해 변수 선언문 이전에도 참조할 수 있다.(undefined)</li>
<li>에러는 아니지만, 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.<h1 id="let-키워드"><a href="#let-키워드" class="headerlink" title="let 키워드"></a>let 키워드</h1></li>
</ul>
</li>
</ol>
<ul>
<li>var 키워드의 단점을 보완하기 위해 만들어진 새로운 변수 선언 키워드.</li>
</ul>
<ol>
<li>변수 중복 선언 금지<ul>
<li>중복 선언하면 문법 에러(SyntaxError) 발생.</li>
</ul>
</li>
<li>블록 레벨 스코프</li>
<li>변수 호이스팅<ul>
<li>선언 단계와 초기화 단계가 분리되어 진행.</li>
<li>초기화 단계가 실행되기 이전에 접근하면 참조 에러(ReferenceError). -&gt; 일시적 사각지대.</li>
<li>호이스팅이 일어나지 않는 것은 아니다. 다만 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ul>
</li>
<li>전역 객체와 let<ul>
<li>let 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 아니다.</li>
<li>보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하는데, 이거 뭔지 아직 모름.<h1 id="const-키워드"><a href="#const-키워드" class="headerlink" title="const 키워드"></a>const 키워드</h1></li>
</ul>
</li>
</ol>
<ul>
<li>재할당이 금지됨. -&gt; 값의 불변과 다름.</li>
<li>선언과 동시에 초기화해야 한다. 그렇지 않으면 문법 에러.</li>
<li>재할당이 금지된 것으로, 객체가 할당되었을 경우 값을 변경할 수 있다.<h1 id="var-vs-let-vs-const"><a href="#var-vs-let-vs-const" class="headerlink" title="var vs. let vs. const"></a>var vs. let vs. const</h1></li>
<li>ES6를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.</li>
</ul>
<hr>
<h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><ul>
<li>(객체의) 프로퍼티 각각도 어트리뷰트를 갖고, 객체로 관리된다.<h1 id="내부-슬롯과-내부-메서드"><a href="#내부-슬롯과-내부-메서드" class="headerlink" title="내부 슬롯과 내부 메서드"></a>내부 슬롯과 내부 메서드</h1></li>
<li>자바스크립트 엔진의 구현 알고리즘을 ‘설명’하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티(pseudo property)와 의사 메서드(pseudo method).</li>
<li>예를 들어, 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다.</li>
<li>실제로 그 이름의 내부 슬롯이 있는지는 중요한 게 아니고, 그런 식으로 동작되는 원리가 있다는 게 중요.</li>
<li>원칙적으로 직접 접근할 수 없지만 [[Prototype]] 내부 슬롯의 경우 __proto__를 통해 간접적으로 접근할 수 있다.<h1 id="프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h1></li>
<li>자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</li>
<li>프로퍼티 상태: 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable). -&gt; 자바스크립트 엔진이 프로퍼티를 관리하는 내부 상태 값인 내부 슬롯.</li>
<li>각각에 직접 접근할 수는 없지만, Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyDescriptor(person, &#39;name&#39;));</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure></li>
<li>프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor) 객체. 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터는 undefined.</li>
<li>Object.getOwnPropertyDescriptors는 모든 프로퍼티 어트리뷰트 정보를 제공.(끝에 s. 복수형)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;,</span><br><span class="line">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="데이터-프로퍼티"><a href="#데이터-프로퍼티" class="headerlink" title="데이터 프로퍼티"></a>데이터 프로퍼티</h1></li>
<li>키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.</li>
<li>프로퍼티 어트리뷰트로 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 을 갖는다.</li>
<li>value: 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값. 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다. 이때 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</li>
<li>writable: 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</li>
<li>enumerable: 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티는 for…in 문이나 Object.keys 메서드 등으로 열거할 수 없다.</li>
<li>configurable: 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우 [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. -&gt; 객체 밀봉, 객체 동결.<h1 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h1></li>
<li>자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function)로 구성된 프로퍼티다. getter / setter 함수</li>
<li>프로퍼티 어트리뷰트로 [[Get]], [[Set]], [[Enumerable]], [[Configurable]] 을 갖는다.</li>
<li>get: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수. 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</li>
<li>set: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</li>
<li>객체 안에 접근자 프로퍼티라고 하는 함수가 있고, 이 함수를 통해 프로퍼티를 읽거나 쓸 수 있다.</li>
<li>읽을 때는 getter, 쓸 때는 setter가 쓰인다.<h1 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h1></li>
<li>새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것.</li>
<li>Object.defineProperty<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(person, &#39;firstName&#39;, &#123;</span><br><span class="line">  value: &#39;Ungmo&#39;,</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>정의할 때, 프로퍼티 어트리뷰트를 생략하면, 기본값은 undefined, false.</li>
<li>Object.defineProperties 메서드를 사용하면 여러 개의 프로퍼티를 한 번에 정의할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 데이터 프로퍼티 정의</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    value: &#39;Ungmo&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName: &#123;</span><br><span class="line">    value: &#39;Lee&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 접근자 프로퍼티 정의</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    &#x2F;&#x2F; getter 함수</span><br><span class="line">    get() &#123;</span><br><span class="line">      return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; setter 함수</span><br><span class="line">    set(name) &#123;</span><br><span class="line">      [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="객체-변경-방지"><a href="#객체-변경-방지" class="headerlink" title="객체 변경 방지"></a>객체 변경 방지</h1></li>
<li>프로퍼티 어트리뷰트를 재정의하여, 객체의 변경을 방지할 수 있다.</li>
<li>메서드 제공.</li>
</ul>
<ol>
<li>Object.preventExtensions<ul>
<li>객체 확장 금지.</li>
<li>프로퍼티 추가 금지.(프로퍼티 동적 추가, Object.defineProperty 모두.)</li>
<li>확장 가능한 객체인지 여부는 Object.isExtensible 메서드로 확인할 수 있다.</li>
</ul>
</li>
<li>Object.seal<ul>
<li>객체 밀봉. 읽기와 쓰기만 가능.(열거, 재정의 불가.)</li>
<li>밀봉된 객체인지 여부는 Object.isSealed 메서드로 확인 할 수 있다.</li>
</ul>
</li>
<li>Object.freeze<ul>
<li>객체 동결. 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의, 프로퍼티 값 갱신 금지. -&gt; 읽기만 가능.</li>
<li>동결된 객체인지 여부는 Object.isFrozen 메서드로 확인 할 수 있다.<h1 id="불변-객체"><a href="#불변-객체" class="headerlink" title="불변 객체"></a>불변 객체</h1></li>
</ul>
</li>
</ol>
<ul>
<li>위 세 메서드는 얕은 변경 방지로, 직속 프로퍼티만 변경 방지 되고 중첩 객체까지는 영향을 주지 못한다.(얕은 복사?)</li>
<li>중첩 객체까지 동결하여 불변 객체를 구현하려면, 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(target) &#123;</span><br><span class="line">  &#x2F;&#x2F; 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.</span><br><span class="line">  if (target &amp;&amp; typeof target &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; !Object.isFrozen(target)) &#123;</span><br><span class="line">    Object.freeze(target);</span><br><span class="line">    &#x2F;*</span><br><span class="line">      모든 프로퍼티를 순회하며 재귀적으로 동결한다.</span><br><span class="line">      Object.keys 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.</span><br><span class="line">      (&quot;19.15.2. Object.keys&#x2F;values&#x2F;entries 메서드&quot; 참고)</span><br><span class="line">      forEach 메서드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.</span><br><span class="line">      (&quot;27.9.2. Array.prototype.forEach&quot; 참고)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    Object.keys(target).forEach(key &#x3D;&gt; deepFreeze(target[key]));</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#123; city: &#39;Seoul&#39; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/26/201127-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/201127-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" class="post-title-link" itemprop="url">스코프, 전역 객체의 문제점</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-26 11:22:17 / Modified: 11:22:56" itemprop="dateCreated datePublished" datetime="2020-11-26T11:22:17+09:00">2020-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><ul>
<li>자바스크립트의 스코프는 다른 언어의 스코프와 구별되는 특징이 있어 주의가 필요하다.</li>
<li>모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.</li>
<li>이것이 스코프.</li>
<li>즉, 스코프는 식별자가 유효한 범위.</li>
<li>자바스크립트 엔진의 입장에서 보자면, ‘식별자를 검색할 때 사용하는 규칙’이라고도 볼 수 있다.</li>
<li>자바스크립트 엔진은 코드를 실행할 때 (암묵적 타입 변환 등에서 살펴봤듯이,) 코드의 문맥을 고려한다.</li>
<li>‘코드가 어디서 실행되며 주변에 어떤 코드가 있는지’를 렉시컬 환경이라고 부른다. = 코드의 문맥</li>
<li>이를 구현한 것이 ‘실행 컨텍스트’</li>
<li>그건 나중에 살펴볼 거고, 아무튼,</li>
<li>컴퓨터를 사용할 때 디렉토리가 다르면 같은 이름을 쓸 수 있는 것처럼,</li>
<li>식별자 이름 역시 스코프가 다르면 같은 이름을 사용할 수 있다.</li>
<li>즉, 스코프는 ‘네임스페이스(개체를 구분할 수 있는 범위)’다.</li>
<li>정리.<ol>
<li>식별자의 입장에서, 스코프는 ‘식별자가 유효한 범위’</li>
<li>자바스크립트 엔진의 입장에서, ‘식별자를 검색할 때 사용하는 규칙.’</li>
<li>같은 이름의 식별자를 구분하게 하는 ‘네임 스페이스’</li>
</ol>
</li>
<li>근데, var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용. 개판. let, const는 허용 안함.<h1 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h1></li>
</ul>
<ol>
<li>전역 스코프: 코드의 가장 바깥 영역 -&gt; 전역 변수<ul>
<li>전역 변수는 어디서든지 참조할 수 있다.</li>
</ul>
</li>
<li>지역 스코프: 함수 몸체 내부 -&gt; 지역 변수<ul>
<li>지역은 ‘함수 몸체 내부’</li>
<li>지역에 변수를 선언하면 그 지역을 ‘지역 스코프’로 갖는 ‘지역 변수’가 된다.</li>
<li>지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</li>
<li>상위 지역 스코프는 스코프는 유효하지 않아, 식별자가 같더라도 참조하지 않는다. -&gt; 스코프 체인<h1 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h1></li>
</ul>
</li>
</ol>
<ul>
<li>함수는 중첩이 가능하므로, 지역 역시 중첩이 가능하고, 지역 스코프도 중첩이 됨.</li>
<li>이말인 즉슨, 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 것.</li>
<li>상위 스코프 / 하위 스코프</li>
<li>최상위 스코프는 뭐야? 전역 스코프.</li>
<li>이렇게 스코프가 계층적으로 연결된 것을 ‘스코프 체인’이라고 한다.</li>
<li>스코프 체인은 ‘물리적인 실체’로 존재한다.<ul>
<li>스코프 체인, 렉시컬 환경, 실행 컨텍스트.</li>
<li>이런 자료 구조를 갖추고 관리한다는 말 같은데,</li>
<li>아직은 정확히 몰라.<h1 id="스코프-체인에-의한-변수-함수-검색"><a href="#스코프-체인에-의한-변수-함수-검색" class="headerlink" title="스코프 체인에 의한 변수, 함수 검색"></a>스코프 체인에 의한 변수, 함수 검색</h1></li>
</ul>
</li>
<li>자바스크립트 엔진은 변수를 참조할 때, 변수가 ‘선언’된 위치에서부터 ‘상위’스코프로 이동하며 변수 식별자를 검색한다.</li>
<li>‘상위’스코프로 이동하며 식별자를 검색한다 -&gt; 유효한 스코프는 자신과 하위 스코프다.</li>
<li>상속의 개념으로 생각할 수도 있다.</li>
<li>호이스팅? -&gt; 호이스팅 역시 스코프 단위로 동작한다.</li>
<li>함수의 경우,</li>
<li>자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.(함수 선언문)</li>
<li>그렇다면 똑같지 뭐.</li>
<li>자바스크립트 엔진은 코드 실행 전, 모든 (전역)선언문을 찾는다.<h1 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h1></li>
<li>대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 모든 코드 블록이 지역 스코프를 만든다. 이게 ‘블록 레벨 스코프’.</li>
<li>하지만 var키워드로 선언된 변수는 오로지 함수의 코드블록(함수 몸체)만을 지역 스코프로 인정한다. 이게 ‘함수 레벨 스코프’.<ul>
<li>예를 들어, if문의 코드 블록에서 var키워드로 선언된 변수는 전역 변수.</li>
<li>말만 들어도 개판이네,</li>
<li>let, const 키워드는 블록 레벨 스코프를 지원.<h1 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h1></li>
</ul>
</li>
<li>상위 스코프를 결정하는 두 가지 방식.<ol>
<li>함수를 어디서 ‘호출’ 했는지<ul>
<li>함수를 정의하는 시점에서, 이 함수가 어디서 호출될지 알 수 없다. 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 ‘동적 스코프’.</li>
</ul>
</li>
<li>함수를 어디서 ‘정의’ 했는지<ul>
<li>함수를 정의하는 순간 상위 스코프가 결정되므로 ‘정적 스코프’. 이를 ‘렉시컬 스코프’라고 부른다.</li>
<li>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h1 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1><ul>
<li>전역 변수의 무분별한 사용은 위험.</li>
<li>이름이 중복되기도 쉽고, 그 과정에서 값이 변하기도 할 테고.</li>
<li>전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면, 지역 변수를 사용해야 한다.<h1 id="지역-변수의-생명-주기"><a href="#지역-변수의-생명-주기" class="headerlink" title="지역 변수의 생명 주기"></a>지역 변수의 생명 주기</h1></li>
<li>변수에 생명 주기가 없다면, 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.</li>
<li>어우, 이러면 안 되지.</li>
<li>전역 변수는 애플리케이션이 종료되면 죽고, 함수 내부에서 선언된 지역 변수는 함수가 호출되면 태어났다가 종료하면 죽는다.</li>
<li>함수 몸체의 문들은 함수가 호출되어야만 하나씩 실행되기 때문.</li>
<li>즉, 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치.</li>
<li>스코프, 렉시컬 환경는 물리적 실체가 있는데, 함수가 종료되어도 누군가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존.</li>
<li>지역 변수가 함수보다 더 오래 사는 건데, 클로저가 뭔데.ㅠㅠ<h1 id="전역-변수의-생명-주기"><a href="#전역-변수의-생명-주기" class="headerlink" title="전역 변수의 생명 주기"></a>전역 변수의 생명 주기</h1></li>
<li>전역 코드는 함수 호출과 같이 특별한 진입점이 없으므로 코드가 로드되면 곧바로 해석, 실행.</li>
<li>마지막 문이 실행되면 종료.</li>
<li>var 키워드로 선언한 전역 변수는 이 전역에서, ‘전역 객체’의 프로퍼티가 된다.<ul>
<li>전역 객체: 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체.</li>
<li>클라이언트 사이드 환경(브라우저)에서는 window,</li>
<li>서버 사이드 환경(Node.js)에서는 global 객체를 의마하나,</li>
<li>ES11부터 globalThis로 통일.</li>
<li>이 객체는 프로퍼티로 ‘표준 빌트인 객체’, ‘호스트 객체’, ‘var 키워드로 선언한 전역 변수와 전역 함수’ 등이 있다.</li>
<li>이것도 나중에.</li>
</ul>
</li>
<li>전역 객체는 웹페이지가 닫히면 꺼지고, 전역 변수도 그때 사라져.<h1 id="전역-변수의-문제점-1"><a href="#전역-변수의-문제점-1" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1></li>
</ul>
<ol>
<li>암묵적 결합<ul>
<li>모든 코드가 전역 변수를 참조하고 변경할 수 있는 ‘암묵적 결합’</li>
<li>변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험.</li>
</ul>
</li>
<li>긴 생명 주기<ul>
<li>메모리 리소스도 오랜 기간 소비.</li>
<li>전역 변수의 상태를 변경할 수 있는 시간과 기회도 많아 위험.</li>
<li>이름도 중복될 가능성. -&gt; 의도치 않는 재할당의 위험.</li>
</ul>
</li>
<li>스코프 체인 상에서 종점에 존재<ul>
<li>검색 속도가 가장 느리다.</li>
<li>크진 않지만 차이가 있긴 있어.</li>
</ul>
</li>
<li>네임스페이스 오염<ul>
<li>자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.<h1 id="전역-변수의-사용을-억제하는-방법"><a href="#전역-변수의-사용을-억제하는-방법" class="headerlink" title="전역 변수의 사용을 억제하는 방법"></a>전역 변수의 사용을 억제하는 방법</h1></li>
</ul>
</li>
<li>즉시 실행 함수<ul>
<li>즉시 실행 함수를 통해 스코프를 인위적으로 만들 수도 있지.</li>
</ul>
</li>
<li>네임스페이스 객체<ul>
<li>전역 객체의 역할을 할 객체를 생성할 수 있어.</li>
<li>근데 어차피 네임스페이스 객체도 전역 변수에 할당되는 거잖아?</li>
<li>유용하지 않음.</li>
</ul>
</li>
<li>모듈 패턴<ul>
<li>모듈 패턴을 이해하려면 클로저를 먼저 이해해야 하므로 지금은 클로저라는 기능을 통해 전역 변수를 억제할 수 있다는 데 주목하자.</li>
</ul>
</li>
<li>ES6 모듈<ul>
<li>파일 자체의 독자적인 모듈 스코프를 제공.</li>
<li>모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다. script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다.</li>
<li>IE를 포함한 구형 브라우저에서는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.</li>
<li>후에 다시.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/24/201125-%ED%95%A8%EC%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/201125-%ED%95%A8%EC%88%98/" class="post-title-link" itemprop="url">함수</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-24 14:27:03" itemprop="dateCreated datePublished" datetime="2020-11-24T14:27:03+09:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-26 11:22:35" itemprop="dateModified" datetime="2020-11-26T11:22:35+09:00">2020-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5);</span><br></pre></td></tr></table></figure>
<ul>
<li>일련의 과정을 문(statement)로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.</li>
<li>함수 정의 통해 생성, 함수 호출을 통해 실행.</li>
<li>호출의 인수(argument)가 매개변수(parameter)를 통해 함수 몸체(문)의 과정을 실행하고 결과값 출력.</li>
<li>return이 없거나 값이 없으면, undefined 출력.<h1 id="함수의-사용-이유"><a href="#함수의-사용-이유" class="headerlink" title="함수의 사용 이유"></a>함수의 사용 이유</h1></li>
<li>코드의 재사용.</li>
<li>함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</li>
<li>적절한 함수 이름을 통해 코드의 가독성을 향상.<h1 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h1></li>
<li>자바스크립트의 함수는 객체 타입의 ‘값’이므로, 리터럴로 생성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 이름<ul>
<li>식별자다. 식별자 네이밍 규칙을 준수해야 한다.</li>
<li>함수 몸체 내에서만 참조할 수 있는 식별자다.(밖에서 부르는 식별자를 가지려면 변수 식별자에 할당이 필요하다.)</li>
<li>함수 이름은 생략할 수 있다. 기명함수, 익명 함수.</li>
</ul>
</li>
<li>매개변수 목록<ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고, 쉼표로 구분</li>
<li>각 매개변수에는 지정한 인수가 순서대로 할당. 즉, 매개 변수 목록은 ‘순서’에 의미가 있다.</li>
<li>매개변수는 몸체 내에서 변수와 동일하게 취급.(암묵적으로 선언과 할당을 실행한다.) -&gt; 식별자 네이밍 규칙을 준수해야 한다.</li>
</ul>
</li>
<li>함수 몸체<ul>
<li>실행된 문들을 묶은 코드 블록.</li>
<li>함수 호출에 의해 실행된다.</li>
</ul>
</li>
<li>함수 리터럴도 ‘리터럴’이므로 값으로 평가 가능. 그 값은 ‘객체’이고, 즉, 함수는 객체.</li>
<li>리터럴만 된 코드의 함수를 호출할 수는 없다.(식별자가 없잖아.)</li>
<li>함수 객체 값을 만들기 위한 수단.</li>
<li>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.<h1 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h1></li>
</ul>
<ol>
<li>함수 선언문<ul>
<li>함수 이름을 생략할 수 없다는 것만 빼면 함수 리터럴과 형태가 같다.</li>
<li>차이는 값으로 평가되느냐, 되지 않느냐.</li>
<li>자바스크립트 엔진은 문맥(값이 들어가야 할 자린지 아닌지)에 따라 둘을 구분한다.</li>
<li>함수 선언문의 함수 이름은 자바스크립트 엔진이 암묵적으로 식별자로 생성해 선언, 할당한다.</li>
<li>선언문이므로, 호이스팅된다.</li>
</ul>
</li>
<li>함수 표현식<ul>
<li>자바스크립트의 함수는 객체 타입의 값이므로, 함수를 값처럼 자유롭게 사용할 수 있다.</li>
<li>변수에 함수(리터럴)를 할당하는 모양새.</li>
<li>함수 이름은 생략하는 것이 일반적이다.(호출하는데는 식별자만 변수 식별자만 있으면 되니까.)</li>
<li>호이스팅으로 함수 선언문과 차이를 보인다.</li>
<li>함수를 호출하기 전에 반드시 함수를 선언해야한다는 규칙을, 호이스팅은 무시하므로, 선언문 대신 함수 표현식(var가 아닌)을 사용하는 걸 권장.</li>
</ul>
</li>
<li>Function 생성자 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Function 함수로 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.</li>
<li>클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.</li>
</ul>
</li>
<li>화살표 함수.<ul>
<li>이후 자세히.<h1 id="함수-호출"><a href="#함수-호출" class="headerlink" title="함수 호출"></a>함수 호출</h1><h1 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h1></li>
</ul>
</li>
</ol>
<ul>
<li>인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.</li>
<li>매개변수는 함수 몸체 내부에서만 참조할 수 있다. 즉, 매개변수의 스코프는 함수 내부다.</li>
<li>매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.<ul>
<li>인수가 더 적을 때, 전달되지 않은 매개변수는 undefined.</li>
<li>인수가 더 많을 때, 무시.(버려지는 것처럼 보이지만, 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관.)</li>
</ul>
</li>
<li>인수 확인<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(2));        &#x2F;&#x2F; NaN</span><br><span class="line">console.log(add(&#39;a&#39;, &#39;b&#39;)); &#x2F;&#x2F; &#39;ab&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.</li>
<li>자바스크립트는 동적 타입 언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.</li>
<li>따라서, 의도하지 않은 동작을 할 수도 있다.</li>
<li>이 때, 인수 확인이 필요하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  if (typeof x !&#x3D;&#x3D; &#39;number&#39; || typeof y !&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.</span><br><span class="line">    throw new TypeError(&#39;인수는 모두 숫자 값이어야 합니다.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>타입스크립트를 사용하는 것도 방법.</li>
<li>인수가 전달되지 않은 경우, 단축 평가(or 옵셔널 체이닝 연산자 ?.)를 사용해 매개변수에 기본값을 할당할 수도 있다.</li>
<li>매개변수의 기본값도 사용 가능.<h1 id="매개변수의-최대-개수"><a href="#매개변수의-최대-개수" class="headerlink" title="매개변수의 최대 개수"></a>매개변수의 최대 개수</h1></li>
</ul>
</li>
<li>매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 함수의 사용법을 이해하기 어렵게 만들고 실수를 발생시킬 가능성을 높인다.</li>
<li>또한 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받는다. 즉, 유지보수성이 나빠진다.</li>
<li>이상적인 매개변수 개수는 0개이며 적을 수록 좋다.</li>
<li>매개변수의 개수가 많다는 것은 함수가 여러가지 일을 한다는 증거이므로 바람직하지 않다. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.</li>
<li>매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.</li>
<li>객체를 인수로 전달했을 때, 주의할 것은 부수 효과.<h1 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h1></li>
<li>반환문은 값을 반환하고, 이 값으로 평가되는 함수 호출은 평가식이다.</li>
<li>반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.(이후 문은 무시.)</li>
<li>반환문이 생략되면, 함수 몸체의 마지막 문까지 실행 후, undefined를 반환.</li>
<li>반환문과 뒤의 표현식에 줄바꿈이 있으면 세미콜론이 자동 추가 되어, 아래 쓰인 표현식이 무시된다.<h1 id="참조에-의한-전달과-외부-상태의-변경"><a href="#참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="참조에 의한 전달과 외부 상태의 변경"></a>참조에 의한 전달과 외부 상태의 변경</h1></li>
<li>인수 -&gt; 매개변수 -&gt; 함수 몸체 에서, 원시값은 ‘값에 의한 전달’, 객체는 ‘참조에 의한 전달’</li>
<li>특히 객체를 매개변수로 사용할 경우, 함수 몸체에서 참조값을 통해 객체를 변경할 경우 원본이 훼손된다. -&gt; 부수효과 발생.</li>
<li>이런 변경을 어떻게 추적하겠어.(옵저버 패턴을 통해 객체의 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응?)</li>
<li>이 때, 객체를 불변 객체로 만들어 사용해, 방어적 복사를 통한 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체할 수 있다.</li>
<li>이것도 힘드니까 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는, ‘순수 함수’를 지향하는 게 필요.<h1 id="다양한-함수의-형태"><a href="#다양한-함수의-형태" class="headerlink" title="다양한 함수의 형태"></a>다양한 함수의 형태</h1></li>
</ul>
<ol>
<li>즉시 실행 함수(생성과 동시에 ())<ul>
<li>리터럴을 ()그룹 연산자로 감싼 형태.(값이 들어갈 자리. -&gt; 자바스크립트 엔진이 함수 선언문이 아닌 리터럴로 읽을 수 있도록. -&gt; 다른 연산자도 사용할 수 있지만, 일반적이지 않다.)</li>
<li>감싸지 않으면 엔진이 함수 선언문이라고 읽는다. -&gt; 중괄호 뒤에 세미콜론이 찍히고, -&gt; 뒤의 ()은 그룹 연산자로 읽어, 에러.</li>
<li>즉시 실행하며, 일반 함수처럼 값을 반환할 수 있고, 인수를 전달할 수도 있다.</li>
<li>즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수 있는 변수나 함수 이름의 충동을 방지할 수 있다 -&gt; 전역 변수 사용 억제 방법.</li>
</ul>
</li>
<li>재귀 함수<ul>
<li>함수가 자기 자신을 호출(재귀 호출)할 때, 재귀 호출을 수행하는 함수.</li>
<li>반복되는 처리를 위하 새용한다.</li>
<li>함수 몸체에서, 함수 이름으로 호출한다.</li>
<li>탈출 조건이 반드시 있어야 한다. -&gt; 없으면 스택 오버플로 에러.</li>
<li>따라서, 반복문을 대체할 수 있지만, 주의해서 사용해야 해.</li>
<li>반복문을 사용하는 것보다 직관적으로 이해하기 쉬울 때만 한정적으로 사용.</li>
</ul>
</li>
<li>중첩 함수<ul>
<li>일반적으로 중첩 함수는 외부 함수를 돕는 헬퍼 함수의 역항르 한다.</li>
<li>함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하지만,</li>
<li>호이스팅으로 인해 혼란이 발생할 수 있으므로, if문이나 for문 등의 코드 블록에서 정의하는 것은 바람직하지 않다.</li>
</ul>
</li>
<li>콜백 함수<ul>
<li>함수를 인수로 사용, 매개변수를 통해 함수 안에 함수를(중첩 함수)를 만든다.</li>
<li>공통적으로 수행해야 할 함수(고차함수)에 일부분만 다른 함수들(콜백함수)를 조합해 사용.</li>
<li>고차 함수의 몸체에는 콜백 함수의 호출 시점이 명시.</li>
<li>이 때 필요에 따라 인수를 전달.</li>
<li>콜백 함수가 고차 함수 내부에만 호출된다면, 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.(즉시 실행 함수).</li>
<li>다른 곳에서도 호출할 필요가 있다면, 콜백 함수를 정의한 후, 함수 참조(식별자)를 고차 함수에 전달.</li>
<li>콜백 함수는 비동기 처리, 배열 고차 함수 등에 활용된다.(아직은 뭔지 모름)</li>
</ul>
</li>
<li>순수 함수와 비순수 함수<ul>
<li>순수 함수: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수</li>
<li>비순수 함수:  외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수 -&gt; 외부 상태에 따라 반환값이 달라진다.</li>
<li>함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이라 할 수 있다. 자바스크립트는 멀티 패러다임 언어이므로 객체지향 프로그래밍뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/22/201123-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/201123-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/" class="post-title-link" itemprop="url">201123 객체 리터럴, 원시값과 객체의 비교</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-22 19:10:43 / Modified: 19:11:10" itemprop="dateCreated datePublished" datetime="2020-11-22T19:10:43+09:00">2020-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="객체 리터럴"></a>객체 리터럴</h1><hr>
<h1 id="객체란"><a href="#객체란" class="headerlink" title="객체란?"></a>객체란?</h1><ul>
<li>원시값을 제외한 나머지 값들.</li>
<li>자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든 것이 객체다.</li>
<li>원시값과 달리, 객체는 변경 가능한 값이다.</li>
<li>객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.</li>
<li>모든 값은 프로퍼티 값이 될 수 있다.</li>
<li>함수 역시 값으로 취급할 수 있으므로 프로퍼티 값이 될 수 있고,</li>
<li>프로퍼티 값이 함수일 때, 일반 함수와 구분하기 위해 메서드(method)라 부른다.</li>
<li>프로퍼티는 객체의 ‘상태’를 나타내는 값이고,</li>
<li>메서드는 프로퍼티를 참조하고 조작할 수 있는 ‘동작’이므로</li>
<li>객체는 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.</li>
<li>객체와 함수는 분리할 수 없는 개념이다.</li>
<li>함수로 객체를 생성하기도 하며, 함수 자체가 객체이기도 하다.</li>
<li>프로그래밍 언어 자체에는 순서가 없고 서로 물고 물리는 순환 구조가 있어서 잘 이해되지 않는 개념이 나오면 멈추지 말고 일단은 다음으로 넘어가는 것도 한 가지 방법이다.<h1 id="자바스크립트의-객체-생성-방법"><a href="#자바스크립트의-객체-생성-방법" class="headerlink" title="자바스크립트의 객체 생성 방법"></a>자바스크립트의 객체 생성 방법</h1></li>
</ul>
<ol>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메서드</li>
<li>클래스 (ES6)</li>
</ol>
<ul>
<li>다양한 생성 방법을 지원하지만, 객체 리터럴 외의 생성 방식은 모두 함수를 사용해 객체를 생성한다.</li>
<li>이러한 방법은 함수를 배우고 나서 알아본다.<h1 id="객체-리터럴에-의한-객체-생성"><a href="#객체-리터럴에-의한-객체-생성" class="headerlink" title="객체 리터럴에 의한 객체 생성"></a>객체 리터럴에 의한 객체 생성</h1></li>
<li>가장 일반적이고 간단한 방법</li>
<li>중괄호{} 내에 0개 이상의 프로퍼티를 정의한다.</li>
<li>할당이 이루어지는 시점에 객체 리터럴을 해석해 객체를 생성한다.</li>
<li>중괄호 내에 프로퍼티가 없으면 빈 객체.</li>
<li>중괄호는 코드 블록이 아니고, 값으로 표현되는 표현식. -&gt; 중괄호 뒤에 세미콜론을 붙인다.</li>
<li>객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식이다.</li>
<li>객체 생성과 동시에 프로퍼티를 만들 수 있고,</li>
<li>객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.<h1 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h1></li>
<li>객체를 구성하는 단위. 프로퍼티는 키와 값으로 구성된다. 프로퍼티의 나열은 쉼표,를 사용한다.</li>
<li>프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값.<ul>
<li>프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 하지만, 반드시 식별자 네이밍 규칙을 따라야 하는 것은 아님.</li>
<li>기본적으로 문자열을 사용하므로, ‘’ 로 묶어서 표시하지만,</li>
<li>식별자 네이밍 규칙을 따르는 이름은 따옴표 생략 가능.</li>
<li>문자열로 평가될 수 있는 표현식을 사용해 만들 경우, 표현식을 대괄호[]로 묶어야 한다.</li>
<li>빈 문자열을 사용해도 되지만 권장 안함.</li>
<li>문자열이나 심벌 값 외에 값을 사용하면 암묵적 타입 변환.</li>
<li>예약어도 사용 가능하지만 권장 안함.</li>
<li>이미 존재하는 프로퍼티 키를 중복 선언하면 이전의 값을 덮어씀.(갱신)</li>
<li>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성, 프로퍼티 값 할당.</li>
<li>delete 연산자로 프로퍼티 삭제 가능.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete person.age;</span><br></pre></td></tr></table></figure>
<ul>
<li>존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시.</li>
</ul>
</li>
</ul>
</li>
<li>프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값.<h1 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h1></li>
<li>자바스크립트의 함수는 객체(일급 객체)다.</li>
<li>값으로 취급할 수 있고, 프로퍼티 값으로도 사용 가능.</li>
<li>프로퍼티 값이 함수일 때, 일반 함수와 구분하기 위해 메서드(method)라 부른다.<h1 id="프로퍼티-접근"><a href="#프로퍼티-접근" class="headerlink" title="프로퍼티 접근"></a>프로퍼티 접근</h1></li>
</ul>
<ol>
<li>마침표 표기법: 마침표 프로퍼티 접근 연산자(.)를 사용.</li>
<li>대괄호 표기법: 대괄호 프로퍼티 접근 연산자([])를 사용.</li>
</ol>
<ul>
<li>프로퍼티 키가 식별자 네이밍 규칙을 준수하면 둘 다 사용 가능.</li>
<li>대괄호 표기법에서는 반드시 따옴표로 감싼 문자열로 표시.<ul>
<li>문자열을 다 읽을 수 있는 거니까, 네이밍 규칙을 준수 안한 프로퍼티 키는 대괄호 표기법으로 접근 가능.</li>
</ul>
</li>
<li>아니면 식별자로 해석해 식별자를 찾음.</li>
<li>객체에 존재하지 않는 프로퍼티에 접근하면 undefined.<h1 id="ES6에-추가된-객체-리터럴의-확장-기능"><a href="#ES6에-추가된-객체-리터럴의-확장-기능" class="headerlink" title="ES6에 추가된 객체 리터럴의 확장 기능"></a>ES6에 추가된 객체 리터럴의 확장 기능</h1></li>
</ul>
<ol>
<li>프로퍼티 축약 표현<ul>
<li>프로퍼티 값이 변수이고, 변수 이름을 프로퍼터 키로 사용할 때, 프로퍼티 키를 생략할 수 있다. -&gt; 프로퍼티 키는 변수 이름으로 자동 생성.</li>
</ul>
</li>
<li>계산된 프로퍼티 이름<ul>
<li>문자열 또는 문자열로 평가되는 표현식을 대괄호로 묶어 프로퍼티 키를 생성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj[prefix + &#39;-&#39; + ++i] &#x3D; i;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i,</span><br><span class="line">  [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i,</span><br><span class="line">  [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>메서드 축약 표현<ul>
<li>funktion 키워드를 축약할 수 있다.</li>
<li>메서드 축약 표현으로 정의한 메서드는 일반 메서드와 다르게 동작하는데,</li>
<li>이건 다음에 계속.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="원시값과-객체의-비교"><a href="#원시값과-객체의-비교" class="headerlink" title="원시값과 객체의 비교"></a>원시값과 객체의 비교</h1><ol>
<li>원시값은 변경 불가능한 값. 객체는 변경 가능한 값.</li>
<li>원시값을 할당한 변수(확보된 메모리 공간)에는 실제 값이 저장, 객체를 할당한 변수(확보된 메모리 공간)에는 참조값이 저장.</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달(값에 의한 전달), 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달(참조에 의한 전달).<h1 id="원시값"><a href="#원시값" class="headerlink" title="원시값"></a>원시값</h1></li>
<li>변경 불가능한 값: 불변성<ul>
<li>값 자체를 변경할 수는 없지만, 변수 값은 변경할 수 있다. -&gt; 재할당</li>
<li>상수는 재할당이 금지된 변수. 상수와 변경 불가능한 값이 같은 게 아님.</li>
<li>재할당 외에는 변수 값을 변경할 수 있는 방법이 없다.</li>
</ul>
</li>
<li>문자열과 불변성<ul>
<li>문자열은 유사 배체 객체면서, 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다. 단 변경은 할 수 없다.</li>
</ul>
</li>
<li>값에 의한 전달<ul>
<li>변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)이라 한다.</li>
<li>엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.</li>
<li>값에 의한 전달을 생각할 수 있는 두 가지 방법<ol>
<li>새로운 80을 생성(복사)해서 메모리 주소를 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 다르다.</li>
<li>score의 변수값 80의 메모리 주소를 그대로 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.</li>
</ol>
<ul>
<li>어떤 방식이든 간에,</li>
<li>결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.<h1 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h1></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다.</li>
<li>프로퍼티의 값에도 제약이 없다. -&gt; 원시값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.</li>
<li>원시값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에 따라 크기가 매우 클 수도 있다. 객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이 드는 일이다. -&gt; 객체는 원시값과는 다른 방식으로 동작하도록 설계되어 있다.</li>
</ul>
<ol>
<li>변경 가능한 값<ul>
<li>객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장된다. 변수는 이 참조값을 통해 객체에 접근할 수 있다. -&gt;  “변수는 객체를 참조하고 있다” 또는 “변수는 객체를 가리키고(point) 있다”라고 표현한다.</li>
<li>객체의 값을 변경하면, 참조값은 그대로 두고 참조값이 참조하는 값을 변경.</li>
<li>객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일이다. -&gt; 원시값처럼 이전 값을 복사해서 새롭게 생성한다면 명확하고 신뢰성이 확보되겠지만 객체는 크기가 매우 클 수도 있고, 원시값처럼 크기가 일정하지도 않으며, 프로퍼티 값이 객체일 수도 있어서 복사(deep copy)해서 생성하는 비용이 많이 든다. -&gt; 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다. -&gt; 이러한 구조적 단점에 따른 부작용, 여러 개의 식별자가 하나의 객체를 공유할 수 있다.<ul>
<li>얕은 복사와 깊은 복사<ol>
<li>얕은 복사: 참조값만 복사해 새로운 메모리에 저장하여 쓰고, 객체는 복사없이 사용.</li>
<li>깊은 복사: 객체까지 모두 복사해 참조값과 복사 모두 새로운 메모리를 만듦. -&gt; 완전한 복사본을 만듦.<ul>
<li>둘 다 원본과 참조값은 다름.</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>참조에 의한 전달<ul>
<li>객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조값이 복사되어 전달. 이를 ‘참조에 의한 전달’이라 한다.</li>
<li>얕은 복사.(동일)</li>
<li>따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제)하면 서로 영향을 주고받는다.<h1 id="값에-의한-전달-참조에-의한-전달"><a href="#값에-의한-전달-참조에-의한-전달" class="headerlink" title="값에 의한 전달, 참조에 의한 전달"></a>값에 의한 전달, 참조에 의한 전달</h1></li>
</ul>
</li>
</ol>
<ul>
<li>사실 ‘값에 의한 전달’과 ‘참조에 의한 전달’은 둘 다 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.</li>
<li>다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시값이냐 참조값이냐의 차이만 있을 뿐.</li>
<li>엄격히 말하면, 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있다.</li>
<li>‘공유에 의한 전달’이라는 표현도 있지만, 이 또한 에크마스크립트 사양에 정의된 공식 용어는 아니며, 자바스크립트의 동작 방식을 정확히 설명하지는 못한다.</li>
<li>다만, 전달되는 값의 종류에 원시값인지 참조값인지 구별해서 강조하는 의미에서 “값에 의한 전달”과 “참조에 의한 전달”로 구분하여 부르기로 한다.</li>
<li>자바스크립트에는 포인터(pointer)가 존재하지 않기 때문에 포인터가 존재하는 다른 프로그래밍 언어의 “참조에 의한 전달”과 의미가 정확히 일치하지 않다는 점에 주의.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/19/201119-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%A0%9C%EC%96%B4%EB%AC%B8-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/201119-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%A0%9C%EC%96%B4%EB%AC%B8-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80/" class="post-title-link" itemprop="url">연산자, 제어문, 타입 변환, 단축 평가</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-19 19:22:36 / Modified: 19:23:13" itemprop="dateCreated datePublished" datetime="2020-11-19T19:22:36+09:00">2020-11-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1바이트가-8비트인-이유"><a href="#1바이트가-8비트인-이유" class="headerlink" title="1바이트가 8비트인 이유"></a>1바이트가 8비트인 이유</h1><ul>
<li>내가 순서대로 말해볼게, 들어봐.<ol>
<li>1바이트=8비트 라고 결정되지 않은 때가 있었어.</li>
<li>처음 아이디어는 1바이트에 한 글자를 표현할 수 있도록 하고 싶었지.</li>
<li>영어 대소문자와 숫자, 공백과 몇 개의 특수문자, 그 외 출력 불가능한 제어 문자들(?)을 표현하려면 100개 남짓의 가짓수가 필요하겠지?</li>
<li>컴퓨터는 2진수로 값을 저장하니까, 2의 7승(128)이면 다 담을 수 있지.</li>
<li>그래서 1바이트-&gt;표현하고 싶은 글자들 중 하나-&gt;7비트 였는데,</li>
<li>후에 영어가 아닌 다른 언어도 넣고 싶어서 8비트로 확장했어.</li>
<li>그때부터 규격이 정해지고 표준화 됨.</li>
<li>ㅇㅇ?</li>
<li>근데 세상엔 너무 많은 언어가 있잖아.</li>
<li>2의 8승으로 그게 다 표현 안 되지.</li>
<li>그래서,</li>
<li>세계 모든 언어를 같은 방법으로 인코딩하고 싶은 유니코드는, 한 글자를 표현하기 위해 2바이트를 써.</li>
<li>2바이트, 8비트<em>8비트, 2의8승</em>2의8승 = 65536.</li>
<li>더 필요할 거 같은데, 그 이후로 어떻게 됐지?</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/ASCII">https://ko.wikipedia.org/wiki/ASCII</a></li>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C">https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C</a></li>
<li><a target="_blank" rel="noopener" href="https://zepeh.tistory.com/313">https://zepeh.tistory.com/313</a></li>
<li><a target="_blank" rel="noopener" href="https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C">https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C</a></li>
<li><a target="_blank" rel="noopener" href="https://whatisthenext.tistory.com/103">https://whatisthenext.tistory.com/103</a></li>
</ul>
<hr>
<h1 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h1><ul>
<li>하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다.</li>
<li>피연산자: 연산의 대상, 표현식이어야 함,</li>
<li>피연산자와 연산자로 만들어진 문도 값으로 평가될 수 있어 표현식.<h1 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h1></li>
<li>수학적 연산으로 숫자 값을 만든다.</li>
<li>수학적 연산이 불가할 경우, NaN값.</li>
<li>피연산자의 개수에 따라 이항 산술 연산자, 단항 산술 연산자.</li>
</ul>
<ol>
<li>이항 산술 연산자<ul>
<li>+, -, / *, %</li>
<li>새로운 값을 만들어낸다.</li>
<li>피연산자의 값을 변경하는 ‘부수 효과’ 없음.</li>
</ul>
</li>
<li>단항 산술 연산자<ul>
<li>++, –, +, -</li>
<li>++, – 는 피연산자의 값을 변경, ‘부수 효과’.</li>
<li>+는 아무 효과도 없어 보이지만, 숫자 타입이 아닌 값을 숫자 타입으로 바꿈. 단, 피연산자의 값을 변경하지는 않음.</li>
<li>-도 +와 같이 피연산자의 값을 숫자 타입으로 바꿈.</li>
</ul>
</li>
<li>문자열 연결 연산자<ul>
<li>+</li>
<li>피연산자 중 하나가 문자열 타입일 때, 나머지도 문자열로 바꾸고 합침.</li>
<li>문자열 연결 연산자.</li>
<li>단항 산술 연산자의 +, -와 함께, ‘암묵적 타입 변환’을 일으킴.<h1 id="할당-연산자"><a href="#할당-연산자" class="headerlink" title="할당 연산자"></a>할당 연산자</h1></li>
</ul>
</li>
</ol>
<ul>
<li>=, +=, -=, *=, /=, %=, **=</li>
<li>우항의 결과를 좌항의 변수에 할당.</li>
<li>할당문은 값으로 평가되는 표현식인 문.<h1 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h1></li>
<li>좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환.</li>
</ul>
<ol>
<li>동등/일치 비교 연산자<ul>
<li>==, ===</li>
<li>동등 비교 연산자(==)는 암묵적 타입 변환을 통해 두 피연산자의 타입을 일치 시킨 후 비교.</li>
<li>일치 피교 연산자(===)는 암묵적 타입 변환을 하지 않고, 두 피연산자를 비교. 타입이 다르면 false.</li>
<li>일치 피교 연산자로 비교했을 때, NaN값은 자신과 일치하지 않는 유일한 값.</li>
<li>0도 양의 0과 음의 0을 같다고 비교함.</li>
<li>메소드인 Object.is()을 쓰면 +0과 -0도 동일, NaN도 자신과 동일하다고 표시함.</li>
<li>!=, !==</li>
</ul>
</li>
<li>대소 관계 비교 연산자<ul>
<li>&lt;, &gt;, &lt;=, &gt;= <h1 id="삼항-조건-연산자"><a href="#삼항-조건-연산자" class="headerlink" title="삼항 조건 연산자"></a>삼항 조건 연산자</h1></li>
</ul>
</li>
</ol>
<ul>
<li>조건식의 평가 결과(불리언으로 평가)에 따라 반환할 값을 결정.</li>
<li>(조건식) ? (트루일 때 반환 값) : (펄스일 때 반환 값)</li>
<li>조건식을 사용하므로, 조건문.</li>
<li>if…else 문과 유사하게 사용 가능.</li>
<li>단, 삼항 조건 연산자는 값으로 평가 가능, if…else 문은 값으로 평가 불가.</li>
<li>삼항 조건 연산자는 표현식, if…else문은 평가식이 아님.</li>
<li>그래서, 값을 결정해야 한다면 삼항 조건 연산자를 사용하고,</li>
<li>조건에 따라 수행해야 할 문이 많은 경우에는 if…else.<h1 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h1></li>
<li>||, &amp;&amp;, !</li>
<li>!는 피연산자를 불리언 속성으로 변환, 부정하여 반환.</li>
<li>불리언 속성이 아닌 값을 불리언 속성으로 바꿀 수 있다. -&gt; !!값</li>
<li>||, &amp;&amp;는 불리언 값만 반환하는 게 아니야,<ol>
<li>양쪽의 피연산자 중 하나를 반환.</li>
<li>불리언 타입이 아닌 값은 불리언 타입으로 변환하여 평가, 피연산자 중 하나를 반환.</li>
<li>단축 평가<h1 id="쉼표-연산자"><a href="#쉼표-연산자" class="headerlink" title="쉼표 연산자"></a>쉼표 연산자</h1></li>
</ol>
</li>
<li>,</li>
<li>왼쪽부터 평가를 시작해 마지막 피연산자의 값을 반환.<h1 id="그룹-연산자"><a href="#그룹-연산자" class="headerlink" title="그룹 연산자"></a>그룹 연산자</h1></li>
<li>(, )</li>
<li>연산자 우선순위가 가장 높다.</li>
<li>연산자 우선순위를 명시적으로 표시할 수 있다.<h1 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h1></li>
<li>typeof</li>
<li>데이터 타입을 문자열로 반환.</li>
<li>null 타입은 undefined로 반환하는데, 버그임.</li>
<li>선언되지 않은 식별자를 연산하면 undefined를 반환.<h1 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h1></li>
<li>**</li>
<li>Math.pow()</li>
<li>이항 연산자 중에서 우선순위가 가장 높다.</li>
<li>할당 연산자와 함께 쓸 수 있따. **=</li>
<li>음수의 거듭제곱의 경우 음수를 ()로 묶어줘서 사용.<h1 id="그외-연산자"><a href="#그외-연산자" class="headerlink" title="그외 연산자"></a>그외 연산자</h1></li>
<li>?., ??, delete, new, instanceof, in</li>
<li>다른 주제와 연관되어 있으므로, 그때 다시.<h1 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h1></li>
<li>() 가 제일 높고,</li>
<li>그 아래로 단항 산술 연산자</li>
<li>이항 산술 연산자(그 중에 **이 가장 높다.)</li>
<li>비교 연산자</li>
<li>동등/일치 연산자</li>
<li>논리 연산자</li>
<li>삼항</li>
<li>할당</li>
<li>-&gt; 외우기 어려움. (, ) 로 명시적으로 표시가 필요하다.</li>
</ul>
<hr>
<h1 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h1><ul>
<li>위에서 아래로 한 줄씩 진행되는 코드 진행 방향을 제어.</li>
<li>조건문, 반복문</li>
<li>코드 흐름이 왔다갔다 하면 가독성이 떨어지는데, 후에 살펴볼 고차 함수가 이를 해결하려 노력.</li>
<li>하지만 일단 이거부터 해야지.<h1 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h1></li>
<li>0개 이상의 문을 중괄호({, })로 묶은 것, 코드 블록, 블록.</li>
<li>블록문을 하나의 실행 단위로 취급한다.</li>
<li>자체 종결성을 갖기 때문에 뒤에 ;을 붙이지 않는다.</li>
<li>일반적으로 제어문이나 함수에 사용한다.</li>
<li>제어문과 함수의 형식에 중괄호가 있는 게 아니라, 블록문이 따로 있는 거.</li>
<li>그러니까 제어문과 함수에서 한 줄의 문만 있을 땐 블록문을 안 써도 되지.<h1 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h1></li>
<li>조건식의 평가 결과에 따라 블록의 실행을 결정.</li>
<li>if…else문과 switch…case문.</li>
</ul>
<ol>
<li>if…else<ul>
<li>조건식을 불리언 타입으로 평가하여 트루면 if의 블록 실행, 펄스면 else의 블록 실행.</li>
<li>평가된 조건식의 값이 불리언 타입이 아니더라도, 불리언 타입으로 암묵적 변환.</li>
<li>조건식을 추가하고 싶으면 else if를 사용.</li>
<li>삼항 조건 연산자로 바꿔 쓸 수 있다.</li>
</ul>
</li>
<li>switch<ul>
<li>조건식을 평가하여, 그 값과 일치하는 case로 실행 흐름을 옮긴다.</li>
<li>: 이후의 문들을 실행하고,</li>
<li>break로 빠져나간다.<ol>
<li>break가 없을 경우,</li>
<li>가장 아래의 default를 실행.</li>
<li>이것을 폴스루(fall through)라고 한다.</li>
<li>이걸 이용할 수도 있는데,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var year &#x3D; 2000; &#x2F;&#x2F; 2000년은 윤년으로 2월이 29일이다.</span><br><span class="line">var month &#x3D; 2;</span><br><span class="line">var days &#x3D; 0;</span><br><span class="line"></span><br><span class="line">switch (month) &#123;</span><br><span class="line">  case 1: case 3: case 5: case 7: case 8: case 10: case 12:</span><br><span class="line">    days &#x3D; 31;</span><br><span class="line">    break;</span><br><span class="line">  case 4: case 6: case 9: case 11:</span><br><span class="line">    days &#x3D; 30;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    &#x2F;&#x2F; 윤년 계산 알고리즘</span><br><span class="line">    &#x2F;&#x2F; 1. 연도가 4로 나누어떨어지는 해(2000, 2004, 2008, 2012, 2016, 2020...)는 윤년이다.</span><br><span class="line">    &#x2F;&#x2F; 2. 연도가 4로 나누어떨어지더라도 연도가 100으로 나누어떨어지는 해(2000, 2100, 2200...)는 평년이다.</span><br><span class="line">    &#x2F;&#x2F; 3. 연도가 400으로 나누어떨어지는 해(2000, 2400, 2800...)는 윤년이다.</span><br><span class="line">    days &#x3D; ((year % 4 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D;&#x3D; 0) || (year % 400 &#x3D;&#x3D;&#x3D; 0)) ? 29 : 28;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    console.log(&#39;Invalid month&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>case, default, break 등 다양한 키워드가 사용되고, 폴 스루가 적용되는 등, if…else보다 문법적으로 어려워.</li>
<li>if…else를 쓸 수 있으면 쓰는데, 조건이 너무 많은 경우에는 switch가 가독성이 좋다.<h1 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h1></li>
</ul>
</li>
</ol>
<ul>
<li>조건식이 참일 경우, 거짓이 될 때까지 블록을 반복.</li>
<li>for, while, do…while</li>
</ul>
<ol>
<li>for문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>선언문, 조건식, 증감식은 모두 옵션으로 안 써도 돼. 안 쓰면 무한 루프.</li>
<li>for문 안에 for문으로 중첩 가능.</li>
</ul>
</li>
<li>while 문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (count &lt; 3) &#123;</span><br><span class="line">  console.log(count); &#x2F;&#x2F; 0 1 2</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>블록 안에 if문, break문으로 탈출 가능.</li>
</ul>
</li>
<li>do…while 문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  console.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; while (count &lt; 3); &#x2F;&#x2F; 0 1 2</span><br></pre></td></tr></table></figure>
<ul>
<li>do를 먼저 실행하므로, 무조건 한 번은 실행.</li>
</ul>
</li>
<li>break 문<ul>
<li>레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출</li>
<li>그 외의 문에서 사용하면 문법 에러.</li>
<li>레이블 문<ul>
<li>식별자가 붙은 문</li>
<li>식별자: 문;</li>
<li>문 앞에 식별자: 를 붙여 이름을 붙인다.</li>
<li>변수처럼 다시 부르기 위한 용도는 아니고, break 문을 사용하기 위한 별칭으로 사용.</li>
</ul>
</li>
<li>레이블 for문(식별자가 달린 for문)을 탈출할 때 유용하지만, 다른 경우는 사용을 권장하지 않아.</li>
<li>그외 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문.</li>
</ul>
</li>
<li>continue 문<ul>
<li>반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동.</li>
<li>반복문 자체를 탈출하지는 않음.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h1><ul>
<li>명시적 타입 변환과 암묵적 타입 변환</li>
<li>숫자 타입, 문자열 타입, 불리언 타입으로 변환.</li>
<li>기존 원시값을 직접 변환하는 것은 아니고, 다른 타입의 새로운 원시값을 생성.</li>
<li>재할당되지도 않고 한번 쓰고 버리므로, 재사용하기 위해서는 할당이 필요.</li>
<li>암묵적 타입 변경은 개발자의 의지가 코드에 명백히 나타나지 않는다.</li>
<li>그러면 데이터 타입의 추측이 어려워지고,</li>
<li>오류를 생산할 가능성이 높아진다.</li>
<li>암묵적 타입 변환이 이루어지지 않도록 코딩할 수도 있겠지만, 가독성 상 암묵적 타입 변환을 잘 이해하는 편이 좋다.<h1 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h1></li>
<li>자바스크립트 엔진이 개발자의 의도와 상관없이 코드의 문맥을 고려해 데이터 타입을 강제 변환.</li>
<li>가급적 에러를 발생시키지 않기 위해</li>
</ul>
<ol>
<li>문자열 타입으로 변환<ul>
<li>문자열 연결 연산자 1 + ‘2’</li>
<li>템플릿 리터널의 표현식 삽입 ‘1 + 1 = &amp;{1 + 1}’ -&gt; 숫자 타입으로 평가된 표현식을 문자열 타입으로 변환.</li>
<li>참고<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 숫자 타입</span><br><span class="line">0 + &#39;&#39;         &#x2F;&#x2F; -&gt; &quot;0&quot;</span><br><span class="line">-0 + &#39;&#39;        &#x2F;&#x2F; -&gt; &quot;0&quot;</span><br><span class="line">1 + &#39;&#39;         &#x2F;&#x2F; -&gt; &quot;1&quot;</span><br><span class="line">-1 + &#39;&#39;        &#x2F;&#x2F; -&gt; &quot;-1&quot;</span><br><span class="line">NaN + &#39;&#39;       &#x2F;&#x2F; -&gt; &quot;NaN&quot;</span><br><span class="line">Infinity + &#39;&#39;  &#x2F;&#x2F; -&gt; &quot;Infinity&quot;</span><br><span class="line">-Infinity + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;-Infinity&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 타입</span><br><span class="line">true + &#39;&#39;  &#x2F;&#x2F; -&gt; &quot;true&quot;</span><br><span class="line">false + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;false&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 타입</span><br><span class="line">null + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;null&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; undefined 타입</span><br><span class="line">undefined + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 심벌 타입</span><br><span class="line">(Symbol()) + &#39;&#39; &#x2F;&#x2F; -&gt; TypeError: Cannot convert a Symbol value to a string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 타입</span><br><span class="line">(&#123;&#125;) + &#39;&#39;           &#x2F;&#x2F; -&gt; &quot;[object Object]&quot;</span><br><span class="line">Math + &#39;&#39;           &#x2F;&#x2F; -&gt; &quot;[object Math]&quot;</span><br><span class="line">[] + &#39;&#39;             &#x2F;&#x2F; -&gt; &quot;&quot;</span><br><span class="line">[10, 20] + &#39;&#39;       &#x2F;&#x2F; -&gt; &quot;10,20&quot;</span><br><span class="line">(function()&#123;&#125;) + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;function()&#123;&#125;&quot;</span><br><span class="line">Array + &#39;&#39;          &#x2F;&#x2F; -&gt; &quot;function Array() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>숫자 타입으로 변환<ul>
<li>+를 제외한 이항 산술 연산자 -,*,/,%</li>
<li>단항 산술 연산자 +</li>
<li>비교 연산자 &gt;,&lt; -&gt; 크기를 비교에 불리언 값을 반환. 크기를 비교하려면 피연산자 모두 숫자 타입이어야지.</li>
<li>참고<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 문자열 타입</span><br><span class="line">+&#39;&#39;       &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+&#39;0&#39;      &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+&#39;1&#39;      &#x2F;&#x2F; -&gt; 1</span><br><span class="line">+&#39;string&#39; &#x2F;&#x2F; -&gt; NaN</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 타입</span><br><span class="line">+true     &#x2F;&#x2F; -&gt; 1</span><br><span class="line">+false    &#x2F;&#x2F; -&gt; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 타입</span><br><span class="line">+null     &#x2F;&#x2F; -&gt; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; undefined 타입</span><br><span class="line">+undefined &#x2F;&#x2F; -&gt; NaN</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 심벌 타입</span><br><span class="line">+Symbol() &#x2F;&#x2F; -&gt; ypeError: Cannot convert a Symbol value to a number</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 타입</span><br><span class="line">+&#123;&#125;             &#x2F;&#x2F; -&gt; NaN</span><br><span class="line">+[]             &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+[10, 20]       &#x2F;&#x2F; -&gt; NaN</span><br><span class="line">+(function()&#123;&#125;) &#x2F;&#x2F; -&gt; NaN</span><br></pre></td></tr></table></figure>
<ul>
<li>객체, 빈 배열이 아닌 배열, undefined는 NaN으로 반환</li>
</ul>
</li>
</ul>
</li>
<li>불리언 타입으로 변환<ul>
<li>if문, for문, 삼항 조건 연산자 등의 조건식</li>
<li>falsy 값 여섯 개<ol>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>’’ (빈 문자열)</li>
</ol>
</li>
<li>나머지는 모두 truthy값<h1 id="명시적-타입-변환"><a href="#명시적-타입-변환" class="headerlink" title="명시적 타입 변환"></a>명시적 타입 변환</h1></li>
</ul>
</li>
</ol>
<ul>
<li>개발자의 의도에 따라 명시적으로 타입을 변경</li>
<li>빌트인 생성자 함수를 new 연산자 없이 호출하는 방법, 빌트인 메서드를 사용, 암묵적 타입 변환을 이용.</li>
</ul>
<ol>
<li>문자열 타입으로 변환<ol>
<li>String(1);</li>
<li>(1).toString();</li>
<li>1 + ‘’;</li>
</ol>
</li>
<li>숫자 타입으로 변환<ol>
<li>Number(‘0’);</li>
<li>parseInt(‘0’);</li>
<li>+’0’;</li>
</ol>
</li>
<li>불리언 타입으로 변환<ol>
<li>Boolean(‘x’);</li>
<li>!!’x’;</li>
</ol>
</li>
</ol>
<hr>
<h1 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h1><ul>
<li>논리 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Cat&#39; &amp;&amp; &#39;Dog&#39; &#x2F;&#x2F; -&gt; &quot;Dog&quot;</span><br></pre></td></tr></table></figure></li>
<li>논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환.</li>
<li>이 단축 평가로 if문을 대체할 수 있다.</li>
<li>if문의 조건이 truthy값일 때 무얼 해야 한다면 &amp;&amp; -&gt; 앞의 피연산자가 트루일 때, 뒤 피연산자를 반환하니까.</li>
<li>if문의 조건이 falsy값일 때 무얼 해야 한다면 || -&gt; 앞의 피연산자가 펄스일 때, 뒤 피연산자를 반환하니까.<ul>
<li>삼항 조건 연산자는 if…else문을 대체할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (done) message &#x3D; &#39;완료&#39;;</span><br><span class="line">else      message &#x3D; &#39;미완료&#39;;</span><br><span class="line">console.log(message); &#x2F;&#x2F; 완료</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if...else 문은 삼항 조건 연산자로 대체 가능하다.</span><br><span class="line">message &#x3D; done ? &#39;완료&#39; : &#39;미완료&#39;;</span><br><span class="line">console.log(message); &#x2F;&#x2F; 완료</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>객체와 함수에서의 단축 평가 사용<ol>
<li>객체를 가리키기를 기대하는 변수가 null 또는 undefined이 아닌지 확인하고 프로퍼티를 참조할 때.<ul>
<li>값이 null, undefined인 변수를 객체인 줄 알고 프로퍼티를 참조하면, 타입 에러TypeError, 프로그램 강제 종료.</li>
<li>이 때, &amp;&amp; 단축 평가를 사용하는 거지.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var elem &#x3D; null;</span><br><span class="line">var value &#x3D; elem &amp;&amp; elem.value;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>함수 매개변수에 기본값을 설정할 때.<ul>
<li>함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다. -&gt; 에러</li>
<li>이 때, || 단축 평가를 먼저 하고 함수 내용을 쓰는 거지.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getStringLength(str) &#123;</span><br><span class="line">  str &#x3D; str || &#39;&#39;;</span><br><span class="line">  return str.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>인수를 전달 받지 못한 경우, str은 false가 되고, 뒤 피연산자인 ‘’를 반환.<h1 id="옵셔널-체이닝-연산자"><a href="#옵셔널-체이닝-연산자" class="headerlink" title="옵셔널 체이닝 연산자"></a>옵셔널 체이닝 연산자</h1></li>
</ul>
</li>
</ol>
</li>
<li>?.</li>
<li>좌항의 피연산자가 null 또는 undefined일 경우, undefined를 반환.</li>
<li>그렇지 않으면 우항의 프로퍼티 참조를 계속.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; elem?.value;</span><br></pre></td></tr></table></figure></li>
<li>이전에는 &amp;&amp; 단축 평가를 사용했다.</li>
<li>&amp;&amp; 단축 평가는 null, undefined 외에도 falsy값이면 우항의 프로퍼티 참조를 계속 하는데,</li>
<li>falsy값인 0이나 ‘’(빈 문자열)은 객체로 평가될 때도 있어서 오류를 일으킴<h1 id="null-병합-연산자"><a href="#null-병합-연산자" class="headerlink" title="null 병합 연산자"></a>null 병합 연산자</h1></li>
<li>좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고,</li>
<li>그렇지 않으면 좌항의 피연산자를 반환.</li>
<li>변수의 기본값을 설정할 때 유용.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; null ?? &#39;default string&#39;;</span><br></pre></td></tr></table></figure></li>
<li>이전에는 || 연산자를 써서 사용했음</li>
<li>이거 뭔지 잘 모르겠는데?</li>
</ul>
<hr>
<h1 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h1><ol>
<li>표준 빌트인 생성자 함수와 빌트인 메서드<ul>
<li>표준 빌트인(built-in) 생성자 함수와 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 함수이다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이며 new 연산자와 함께 호출한다. 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 빌트인 객체의 메서드다.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/17/201117-%EB%B3%80%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/201117-%EB%B3%80%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/" class="post-title-link" itemprop="url">201117- 변수, 표현식과 문, 데이터 타입</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-17 19:43:50 / Modified: 19:44:14" itemprop="dateCreated datePublished" datetime="2020-11-17T19:43:50+09:00">2020-11-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><ul>
<li>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름<ol>
<li>아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고 그 결과를 출력(output)하는 것이 전부다.</li>
<li>변수는 그 데이터를 관리하기 위한 핵심 개념<h2 id="변수가-필요한-이유"><a href="#변수가-필요한-이유" class="headerlink" title="변수가 필요한 이유"></a>변수가 필요한 이유</h2></li>
</ol>
</li>
</ul>
<ol>
<li>데이터 관리는 값을 메모리셀에 저장하는 것.</li>
<li>근데 그 메모리셀에 메모리 주소로 직접 접근하는 건 위험해.</li>
<li>실수로 운영체제가 사용하고 있는 메모리를 수정하거나 지우면 어떡해?</li>
<li>그러니까 직접 접근하지 않고,</li>
<li>메모리 공간을 식별하기 위한 이름을 붙여 관리.</li>
<li>그게 변수임.<ul>
<li>따라서 변수는, 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>
<li>프로그래밍 언어에서 값을 저장하고 참조(읽어 들이는)하는 메커니즘으로,</li>
<li>값의 위치를 가리키는 상징적인 ‘이름’</li>
<li>메모리 주소가 아닌 다른 명명을 한다는 것은,</li>
<li>사람이 이해할 수 있는 언어로 저장된 값의 의미를 명확히 할 수 있다는 것.</li>
<li>명확한 네이밍으로 코드를 이해하기 쉽게 해야겠지?</li>
<li>협업과 품질 향상에 도움<h2 id="할당과-참조"><a href="#할당과-참조" class="headerlink" title="할당과 참조"></a>할당과 참조</h2></li>
</ul>
</li>
<li>할당: 변수에 값을 저장하는 것</li>
<li>참조: 변수에 저장된 값을 읽어 들이는 것<h2 id="식별자"><a href="#식별자" class="headerlink" title="식별자"></a>식별자</h2></li>
</ol>
<ul>
<li>어떤 값을 구별해서 식별할 수 있는 고유한 이름</li>
<li>변수에서만 사용되는 용어가 아니라, 변수, 함수, 클래스 등의 이름을 모두 지칭함.(자바스크립트에서는 함수도 값)</li>
<li>메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름<ol>
<li>변수의 식별자는 메모리 주소와 매핑(그래야 거기 저장된 값을 찾지)</li>
<li>네이밍 규칙을 준수해야 함<h2 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h2></li>
</ol>
</li>
<li>변수를 생성하는 것.</li>
<li>값을 저장하기 위한 메모리 공간을 확보하고, 그 주소에 변수 이름을 연결,</li>
<li>값을 저장할 수 있게 준비하는 것.</li>
<li>변수를 사용하려면 꼭 필요해. 선언하지 않은 식별자에 접근하면 참조 에러(ReferenceError)<ol>
<li>확보된 메모리 공간은 해제되기 전까지 보호되므로, 안전하게 사용 가능.</li>
<li>var, let, const 키워드를 사용.</li>
<li>변수 선언에 의해 준비된 메모리 공간에는, undefined 라는 값이 암묵적으로 할당</li>
<li>즉, 변수 선언은 두 단계를 거침<ol>
<li>선언 단계: 메모리 공간 확보, 변수 이름 연결, 자바스크립트 엔진에 변수의 존재를 알림.</li>
<li>초기화 단계: 암묵적으로 undefined라는 값을 할당.</li>
</ol>
</li>
<li>초기화 단계를 거치지 않으면, 이전에 저장되어 있던 값(쓰레기 값)이 남아 있을 수 있다.<h2 id="변수-선언의-실행-시점"><a href="#변수-선언의-실행-시점" class="headerlink" title="변수 선언의 실행 시점"></a>변수 선언의 실행 시점</h2></li>
</ol>
</li>
<li>변수 선언은 런타임 이전 단계에서 먼저 실행됨.<ol>
<li>자바스크립트 엔진은 소스코드를 실행하기 앞서 소스코드 평가 과정을 거침.</li>
<li>이 과정에서 변수 선언을 포함한 모든 선언문을 먼저 실행.</li>
<li>따라서, 변수 선언이 어느 위치에 있든 변수 참조 가능</li>
<li>이처럼 변수 선언문이 선두로 끌어올려지는 것처럼 동작하는 자바스크립트 특유의 동작을 ‘호이스팅’이라고 함<h2 id="변수-선언과-할당의-단축-그리고-호이스팅"><a href="#변수-선언과-할당의-단축-그리고-호이스팅" class="headerlink" title="변수 선언과 할당의 단축, 그리고 호이스팅"></a>변수 선언과 할당의 단축, 그리고 호이스팅</h2></li>
</ol>
</li>
</ul>
<ol>
<li>변수 선언과 할당은 하나의 문으로 단축해 쓸 수 있음.</li>
<li>하지만 동작은 나눠서 해.</li>
<li>호이스팅에 의해 변수 선언’만’ 먼저 실행</li>
<li>근데 말이야,</li>
<li>할당은 이전의 undefined 값을 지우고 할당 하는 게 아니라, 새로운 메모리 공간을 확보하고 거기에 저장(이게 무슨 의미지? 선언과 할당이 명확히 구분되어 동작한단 의미?)<h2 id="값의-재할당"><a href="#값의-재할당" class="headerlink" title="값의 재할당"></a>값의 재할당</h2></li>
<li>var 키워드로 선언한 변수는 값이 변할 수 있는 변수.</li>
<li>할당과 마찬가지로 새로운 메모리 공간을 확보하고 거기에 저장</li>
<li>불필요해진 이전의 메모리 공간은 가비지 콜렉터에 의해 자동 해제<ul>
<li>가비지 콜렉터: 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release)하는 기능</li>
<li>가비지 콜렉터가 내장된 언어를 ‘매니지드 언어’, 없는 언어를 ‘언매니지드 언어’라고 함.</li>
<li>매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다. 일정한 생산성을 확보할 수 있지만, 성능 면에서는 손실을 감수할 수밖에 없다.</li>
<li>언매니지드 언어는 개발자가 직접 메모리를 할당, 해제할 수 있는 메모리 제어 기능을 제공. 개발자의 역량에 따라 최적의 성능을 기대할 수 있지만, 반대의 경우 폭망.<h2 id="식별자-네이밍-규칙"><a href="#식별자-네이밍-규칙" class="headerlink" title="식별자 네이밍 규칙"></a>식별자 네이밍 규칙</h2></li>
</ul>
</li>
<li>식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.</li>
<li>단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.</li>
<li>예약어는 식별자로 사용할 수 없다.</li>
<li>유니코드 문자 사용으로 한글 등도 사용가능하지만 권장 안함</li>
<li>대소문자를 구분함</li>
<li>명확한 의미의 이름을 사용.</li>
<li>네이밍 컨벤션은 어떤 것을 사용해도 좋으나, 통일은 해야지.</li>
<li>일반적으로, 변수나 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용<h3 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h3></li>
<li>키워드: 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행</li>
<li>예약어: 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. 자바스크립트의 예약어는 다음과 같다.<ul>
<li>await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* switch this throw true try typeof var void while with yield*</li>
<li><ul>
<li>식별자로 사용 가능하나 Strict Mode에서는 사용 불가</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="표현식과-문"><a href="#표현식과-문" class="headerlink" title="표현식과 문"></a>표현식과 문</h1><h2 id="값"><a href="#값" class="headerlink" title="값"></a>값</h2><ul>
<li>식(표현식, expression)이 평가(evaluate)되어 생성된 결과<ol>
<li>‘표현식’을 ‘평가’하다</li>
<li>변수에 할당되는 것이 ‘값’<h2 id="값을-생성하는-방법"><a href="#값을-생성하는-방법" class="headerlink" title="값을 생성하는 방법"></a>값을 생성하는 방법</h2></li>
</ol>
</li>
</ul>
<ol>
<li>리터럴<ul>
<li>사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(‘’, “”, ., [], {}, // 등)를 사용해 값을 생성하는 표기 방식</li>
<li>자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성. -&gt; 리터럴은 값을 생성하기 위해 미리 약속된 표기법</li>
<li>리터럴을 통해 생성할 수 있는 값<ol>
<li>정수 리터럴 (ex. 100)</li>
<li>부동소수점 리터럴 (ex. 1.5)</li>
<li>2진수 리터럴 (ex. 0b01000001 -&gt; 0b로 시작)</li>
<li>8진수 리터럴 (ex. 0o101 -&gt; 0o로 시작)</li>
<li>16진수 리터럴 (ex. 0x41 -&gt; 0x로 시작)</li>
<li>문자 리터럴 (ex. ‘hello’ “world”)</li>
<li>불리언 리터럴 (ex. true false)</li>
<li>null 리터럴</li>
<li>undefined 리터럴</li>
<li>객체 리터럴 (ex. { name: ‘Lee’, address: ‘Seoul’ })</li>
<li>배열 리터럴 (ex. [ 1, 2, 3 ])</li>
<li>함수 리터럴 (ex. function() {})</li>
<li>정규표현식 리터럴 (ex. /[A-Z]+/g)</li>
</ol>
</li>
</ul>
</li>
<li>표현식 <ul>
<li>값으로 평가될 수 있는 문(statement)</li>
<li>값으로 평가되면 표현식 -&gt; 리터럴도 값으로 평가되므로, 리터럴도 표현식이다. -&gt; 식별자 ‘참조’ 역시 값으로 평가되므로 표현식</li>
<li>표현식과 값은 동치, 즉 표현식은 값처럼 사용될 수 있다 -&gt; 문법적으로 값이 위치해야 할 위치에 표현식이 위치 가능.<h2 id="문-statement"><a href="#문-statement" class="headerlink" title="문(statement)"></a>문(statement)</h2></li>
</ul>
</li>
</ol>
<ul>
<li>프로그램을 구성하는 기본 단위이자 최소 실행 단위</li>
<li>문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍<ol>
<li>문은 여러 토큰으로 이루어진다.<ul>
<li>토큰: 문법적 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</li>
<li>키워드, 식별자, 연산자, 리터럴, 세미콜론 따위</li>
</ul>
</li>
<li>문은 ‘명령문’이라고도 부른다 -&gt; 문이 실행되면 명령이 실행되고, 무언가 일어남.</li>
<li>선언문, 할당문, 조건문, 반복문 등으로 구분</li>
<li>세미콜론(;)<ul>
<li>문의 종료를 표시</li>
<li>자바스크립트 엔진은 세미콜론으로 문의 종료를 파악하고 순차적으로 실행</li>
<li>단, 문을 중괄호로 묶은 블록 뒤에는 세미콜론 표시 안함 -&gt; 코드 블록은 언제나 자체 종결성을 갖기 때문</li>
<li>세미콜론은 생략 가능. 자바스크립트 엔진의 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문<h2 id="표현식과-문-1"><a href="#표현식과-문-1" class="headerlink" title="표현식과 문"></a>표현식과 문</h2></li>
</ul>
</li>
</ol>
</li>
<li>표현식은 문의 일부분일 수도, 그 자체로 문일 수도 있다.</li>
<li>문이 값으로 평가 되면 표현식. 아닐 수도 있지</li>
<li>확인하는 가장 간단한 방법은 문을 변수에 할당해 보는 것. -&gt; 값으로 평가되는 표현식이면 할당이 될 거고, 값으로 평가되지 않으면 에러.<h2 id="용어-1"><a href="#용어-1" class="headerlink" title="용어"></a>용어</h2></li>
</ul>
<ol>
<li>완료 값: 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 완료 값이라 한다. 완료 값은 표현식의 평가 결과가 아니다.</li>
</ol>
<hr>
<h1 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h1><ul>
<li>값의 종류</li>
<li>원시 타입: 숫자, 문자열, 불리언, undefined, null, 심벌</li>
<li>객체 타입: 객체, 함수, 배열 등 (함수도 값이다!)<h2 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h2></li>
<li>변경 불가능한 값</li>
<li>변수에 다른 원시타입을 할당하는 경우는 기존의 값이 변경되는게 아니라 새로운 값이 생성되어 할당되는 것.<ol>
<li>숫자 타입<ul>
<li>자바스크립트는 정수와 실수를 구분하지 않고 하나의 숫자 타입만 제공</li>
<li>2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않으므로, 이들 값을 참조하면 모두 10진수로 해석</li>
<li>숫자 타입의 세 가지 특별한 값<ol>
<li>10/0 -&gt; infinity: 양의 무한대</li>
<li>10/-0 -&gt; -infinity: 음의 무한대</li>
<li>1*”string” -&gt; NaN: 산술 연산 불가(NAN, Nan 등과 다름. 자바스크립트 엔진은 대소문자를 구별하므로, 이와 같은 표현은 식별자로 해석)</li>
</ol>
</li>
</ul>
</li>
<li>문자열 타입<ul>
<li>유니코드 문자로, 전 세계 대부분의 문자를 표현 가능</li>
<li>‘’, “”, `` 으로 감싸 표현 가능. 일반적으론 ‘’</li>
<li>키워드, 식별자 등과 구분하기 위해 감싸서 표현</li>
<li>자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다</li>
<li>문자열 연산자 + 로 연결 가능</li>
<li>템플릿 리터럴<ul>
<li>멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능을 제공</li>
<li>런타임에 문자열로 변환되어 처리</li>
<li>백틱(``)을 사용해 표현<ol>
<li>이스케이프 시퀀스를 사용하지 않고도 줄바꿈, 공백 등이 그대로 적용</li>
<li>${ } 을 통해 표현식 삽입 가능. 안의 표현식은 강제로 문자열로 바뀜(표현식 삽입은 반드시 템플릿 리터럴 에서만. 일반 문자열에서는 ${}도 문자열로 취급)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>불리언<ul>
<li>true, false</li>
</ul>
</li>
<li>undefined<ul>
<li>var 키워드로 선언한 변수는 undefined 로 암묵적 초기화</li>
<li>엔진이 변수를 초기화 하는데 쓰는 undefined를 개발자가 의도적으로 할당하면 취지와 어긋나,</li>
<li>권장하지 않음.</li>
<li>변수에 값이 없다는 걸 명시하고 싶을 땐, null을 써</li>
</ul>
</li>
<li>null<ul>
<li>변수에 값이 없다는 걸 명시</li>
<li>이전에 할당 되어 있던 값에 대한 참조를 명시적으로 제거</li>
<li>값은 가비지 가비지 콜렉터가 지움</li>
</ul>
</li>
<li>symbol 타입<ul>
<li>다른 값과 중복되지 않는 유일무이한 값</li>
<li>주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용<h2 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h2></li>
</ul>
</li>
</ol>
</li>
<li>데이터는 크기가 정해져 있지 않고 변수에 할당될 때 값이 직접 해당 변수에 저장될 수 없으며, 변수에는 데이터에 대한 참조만 저장된다. 참조는 참조 타입 데이터의 주소이지 해당 데이터의 값이 아니다.</li>
<li>객체에 대해서는 후에 자세히 알아볼 텐데, 중요한 것은 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것.</li>
<li>이거 궁금한데, 일단 원시 타입 여섯 개의 데이터 타입 외의 값은 모두 객체<h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2></li>
</ul>
<ol>
<li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해<h2 id="동적-타입-언어인-자바스크립트"><a href="#동적-타입-언어인-자바스크립트" class="headerlink" title="동적 타입 언어인 자바스크립트"></a>동적 타입 언어인 자바스크립트</h2></li>
<li>정적 타입 언어와 동적 타입 언어<ul>
<li>정적 타입 언어: 변수를 선언할 때, 데이터 타입을 먼저 선언 -&gt; 컴파일 때 타입이 맞는지를 확인하고, 안 맞으면 에러, -&gt; 더욱 안정적인 코드의 구현 가능</li>
<li>동적 타입 언어: 데이터 타입 선언이 따로 없음, 값에 따라 데이터 타입이 결정<ul>
<li>할당에 의해 타입이 결정(타입 추론)</li>
<li>재할당으로 언제든 변수의 타입이 바뀔 수 있다-&gt; 동적 타입 언어</li>
<li>변수는 기본적으로 타입을 갖지 않지만, 연결된 값에 따라 타입을 갖게 됨</li>
<li>변수에 자유롭게 할당을 할 수 있어 편리하지만, 단점이 있지</li>
</ul>
</li>
</ul>
</li>
<li>동적 타입 언어의 단점<ul>
<li>동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다</li>
<li>개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다</li>
<li>유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어진다</li>
</ul>
</li>
<li>단점으로 인해 주의해야 할 점<ul>
<li>변수는 꼭 필요한 경우에 한해 제한적으로 사용</li>
<li>변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제</li>
<li>전역 변수는 최대한 사용하지 않도록</li>
<li>변수보다는 상수를 사용해 값의 변경을 억제</li>
<li>변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍<h2 id="용어-2"><a href="#용어-2" class="headerlink" title="용어"></a>용어</h2></li>
</ul>
</li>
<li>이스케이프 시퀀스: 문자열에서, 줄바꿈 등의 공백(white space)을 표현하는 방법. (ex. \0)</li>
<li>라인 피드와 캐리지 리턴<ul>
<li>라인 피드(LF, Line Feed): 커서를 정지한 상태에서 종이를 한 줄 올리는 것</li>
<li>캐리지 리턴(CR, Carriage Return): 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것</li>
<li>개행 방식의 차이</li>
<li>운영체제마다 다른 개행 방식을 따르는데,</li>
<li>대부분의 텍스트 에디터는 운영체제에 맞게 개행 방식을 바꿔줘</li>
<li>자바스크립트에서 라인 피드와 캐리지 리턴은 모두 개행을 의미한다. 하지만 캐리지 리턴(\r)으로 개행하는 경우는 거의 없고 일반적으로 라인 피드(\n)를 사용해 개행한다.</li>
</ul>
</li>
<li>트레이드 오프: 두 개의 정책 목표 가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적 관계</li>
<li>은 탄환: 고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/16/201116-pixel-compiled-language-interpreter-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/201116-pixel-compiled-language-interpreter-language/" class="post-title-link" itemprop="url">201116-pixel, compiled language, interpreter language</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-16 20:21:32 / Modified: 21:15:40" itemprop="dateCreated datePublished" datetime="2020-11-16T20:21:32+09:00">2020-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>아래 내용을 TIL로 정리하기 </li>
<li>4,5,6장 예습 내용</li>
<li>pixel이 무엇인지 - 절대값일까 상대값일까</li>
<li>컴파일러 언어와 인터프리터 언어의 특징과 차이</li>
</ul>
<h1 id="What-is-‘pixel’"><a href="#What-is-‘pixel’" class="headerlink" title="What is ‘pixel’"></a>What is ‘pixel’</h1><ol>
<li>A ‘pixel’ (short for ‘picture element’) is a tiny square of colour.<ul>
<li>픽셀(그림 요소의 약칭)은 색의 가장 작은 사각형이다.</li>
<li>색을 표현하는 가장 작은 요소.</li>
</ul>
</li>
<li>PIXEL DIMENSIONS are the horizontal and vertical measurements of an image expressed in pixels.<ul>
<li>픽셀 디멘션은 픽셀로 표현된 이미지의 수평/수직 측정이다.</li>
<li>픽셀의 가로/세로 수로 이미지의 크기를 측정한다.</li>
<li>ex. 1024*720</li>
<li>픽셀은 스크린의 작은 LED와 비슷하다. 1024*720은 가로에 1024개의 픽셀, 세로에 720개의 픽셀이 있다는 뜻.</li>
</ul>
</li>
<li>그럼 픽셀의 사이즈는 고정?<ul>
<li>Pixels do not have a fixed size. Their size is relative to the screen’s resolution.</li>
<li>픽셀의 사이즈는 고정되어 있지 않다.</li>
<li>픽셀의 사이즈는 화면의 해상도에 비례한다.</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.judyofthewoods.net/money/pixels_resolution_dpi.html">http://www.judyofthewoods.net/money/pixels_resolution_dpi.html</a><h2 id="근데-하드웨어-픽셀과-소프트웨어-픽셀-css-pixel-이-달라-위는-하드웨어-픽셀"><a href="#근데-하드웨어-픽셀과-소프트웨어-픽셀-css-pixel-이-달라-위는-하드웨어-픽셀" class="headerlink" title="근데, 하드웨어 픽셀과 소프트웨어 픽셀(css pixel)이 달라(위는 하드웨어 픽셀)"></a>근데, 하드웨어 픽셀과 소프트웨어 픽셀(css pixel)이 달라(위는 하드웨어 픽셀)</h2><ol>
<li>The CSS resolution is used for measurements in the CSS Rules, and the Screen Device Resolution is the actual number of pixels on the screen.<ul>
<li>css 해상도는 css 규칙의 측정, 스크린 디바이스 해상도는 스크린에 실제로 표시되는 픽셀 수.</li>
</ul>
</li>
<li>Besides the two resolution types, there is also Density Display, which defines the ratio between the Screen Resolution and the CSS Resolution, and is different in high-density screens.<ul>
<li>그래서 배율도 있음.</li>
<li>For example: In the iPhone 11, for every CSS pixel we have 2 device pixels, which means the density display is 2x.</li>
</ul>
</li>
<li>하드웨어 픽셀과 소프트웨어 픽셀이 달라.<ul>
<li>100px*100px 사각형이 있다 치자,</li>
<li>이 사각형은 어느 디바이스에서든 같은 똑같이 가로세로 100px짜리 여야 한다.</li>
<li>따라서 위 예시인 iPhone11은, 이 사각형을 50*50으로 그려야 해.(왜냐면 1 디바이스 픽셀이 2 css픽셀이니까)</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@elad/understanding-the-difference-between-css-resolution-and-device-resolution-28acae23da0b">https://medium.com/@elad/understanding-the-difference-between-css-resolution-and-device-resolution-28acae23da0b</a></li>
</ol>
</li>
</ol>
<hr>
<h1 id="컴파일러-언어와-인터프리터-언어의-특징과-차이"><a href="#컴파일러-언어와-인터프리터-언어의-특징과-차이" class="headerlink" title="컴파일러 언어와 인터프리터 언어의 특징과 차이"></a>컴파일러 언어와 인터프리터 언어의 특징과 차이</h1><ol>
<li>컴파일러 언어: 코드를 전부 읽고 처리.(번역)<ul>
<li>코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한번에 기계어(CPU가 바로 실행할 수 있는 기계어)로 변환한 후 실행한다.     -&gt; 코드 전체를 읽고 실행.</li>
<li>컴파일 단계와 실행 단계가 분리되어 있다. 명시적인 컴파일 단계를 거치고, 명시적으로 실행 파일을 실행한다. -&gt; 파싱 단계와 실행 단계 구분,</li>
<li>실행 파일을 생성한다.     -&gt; 파싱과 실행이 구분되므로, 실행 파일을 만들겠지.</li>
<li>실행에 앞서 컴파일은 단 한번 수행된다.    -&gt; 여러 번 할 필요 없지</li>
<li>컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠르다.     -&gt; 한번만 하니까 빠르겠지.<ol>
<li>컴파일: 사람이 이해하는 언어를 컴퓨터가 이해할 수 있는 언어로 바꿔주는 과정.</li>
<li>머신 코드: 기계어(컴퓨터(CPU)가 별다른 해석(컴파일) 없이 읽을 수 있는 프로그래밍 언어)</li>
</ol>
</li>
</ul>
</li>
<li>인터프리터 언어: 코드를 한 줄씩 읽어가며 처리.(통역)<ul>
<li>코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간 코드(intermediate code)인 바이트코드(특정한 하드웨어가 아니라 가상 머신에서 실행하도록 만든 바이너리 코드)로 변환한 후 실행한다.  -&gt; 한 줄씩 읽고 실행.</li>
<li>인터프리트 단계와 실행 단계가 분리되어 있지 않다. 인터프리터는 한 줄씩 바이트코드로 변환하고 즉시 실행한다. -&gt; 한 줄씩 읽고 실행하니까, 파싱과 실행 단계가 구분되지 않음.</li>
<li>실행 파일을 생성하지 않는다. -&gt; 그래서 따로 실행 파일을 만들지도 않고,</li>
<li>코드가 실행될 때마다 인터프리트 과정이 반복 수행된다. -&gt; 읽고 실행하는 과정이 반복.</li>
<li>인터프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다. -&gt; 반복해서 실행하니까 느리지.<ol>
<li>런타임: 컴퓨터가 실행되는 동안 프로세스나 프로그램을 위한 소프트웨어 서비스를 제공하는 가상 머신의 상태</li>
<li>문 단위: 프로그램을 구성하는 기본 단위이자 최소 실행 단위</li>
<li>바이트코드: 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법. 소프트웨어로 처리되는 표현법으로, 보통 기계어보다 추상적.</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/05/201105-html-css-practice-responsive-web-page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/05/201105-html-css-practice-responsive-web-page/" class="post-title-link" itemprop="url">201105-html css practice-responsive web page</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-05 21:54:52" itemprop="dateCreated datePublished" datetime="2020-11-05T21:54:52+09:00">2020-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-16 20:24:35" itemprop="dateModified" datetime="2020-11-16T20:24:35+09:00">2020-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/html-css/" itemprop="url" rel="index"><span itemprop="name">html/css</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="html-css-practice"><a href="#html-css-practice" class="headerlink" title="html/css practice"></a>html/css practice</h1><ul>
<li>반응형 웹페이지 실습.</li>
</ul>
<hr>
<h2 id="기본적인-내용은-같다-기획-단계에서-익숙해질-수-있도록-많은-연습만이-살-길"><a href="#기본적인-내용은-같다-기획-단계에서-익숙해질-수-있도록-많은-연습만이-살-길" class="headerlink" title="기본적인 내용은 같다. 기획 단계에서 익숙해질 수 있도록 많은 연습만이 살 길."></a>기본적인 내용은 같다. 기획 단계에서 익숙해질 수 있도록 많은 연습만이 살 길.</h2><hr>
<h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ol>
<li>전체 아웃라인의 렌더링이 flex-direction: column처럼 보이지만, row로 하는 이유(요소의 width: 100%)<ul>
<li>이후에 혹시 모를 수정에 쉽게 대응하기 위해.</li>
<li>ex. 수직으로 정렬된 마지막 요소가 수평 정렬로 수정될 때 -&gt; width 값만 수정해주면 된다.</li>
<li>일반적인 흐름이 수평 정렬이므로, 후에도 수평 정렬로 수정될 가능성이 높음.</li>
</ul>
</li>
<li>:checked -&gt; 체크박스에서 체크된 상태를 선택.</li>
<li>aria-live: 새롭게 갱신된 정보를 읽을 수 있게 함.</li>
<li>role=”dialog”: 모달 창이 떴을 때, 모달 창으로 자연스럽게 탭 이동.<ul>
<li>위 값이 없을 때는 모달 아래를 전부 이동 한 후, 모달로 넘어온다.</li>
</ul>
</li>
<li>aria-modal=”true”</li>
<li>aria-current: page -&gt; 현재 페이지임을 표시<ul>
<li>aria 뭐야, 아.</li>
</ul>
</li>
<li>Post HTML</li>
<li>a 안에 figure은 가능하지만, button 안에 figure은 불가.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/02/201102-html%20css%20practice-responsive%20web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/201102-html%20css%20practice-responsive%20web/" class="post-title-link" itemprop="url">201102-html css practice-responsive web page</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-02 21:54:52" itemprop="dateCreated datePublished" datetime="2020-11-02T21:54:52+09:00">2020-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-16 20:24:28" itemprop="dateModified" datetime="2020-11-16T20:24:28+09:00">2020-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/html-css/" itemprop="url" rel="index"><span itemprop="name">html/css</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="html-css-practice"><a href="#html-css-practice" class="headerlink" title="html/css practice"></a>html/css practice</h1><ul>
<li>반응형 샘플, 추천 메뉴/인포 영역</li>
</ul>
<hr>
<h2 id="반응형-페이지-기획하기"><a href="#반응형-페이지-기획하기" class="headerlink" title="반응형 페이지 기획하기"></a>반응형 페이지 기획하기</h2><ol>
<li>마크업<ul>
<li>후에 숨겨야 하는 요소도 빠짐없이 마크업.</li>
<li>공통적으로 디자인하기 위해, 묶어야 할 요소들은 무엇인지 고려.</li>
</ul>
</li>
<li>스타일 기획 방법<ol>
<li>작은 화면에서 큰 화면으로, 혹은 큰 화면에서 작은 화면으로.<ul>
<li>기본이 되는 화면을 선택해 먼저 스타일 하고,</li>
<li>수정이 되는 것들만 따로 수정.</li>
</ul>
</li>
<li>공통된 것들을 먼저 체크해 스타일 하고, 후에 다른 것들 추가.</li>
<li>어느 쪽이든 헷갈리지 않게 차근차근.<ul>
<li>기준을 정해야 하는 듯.</li>
<li>많이 해 봐야 익숙해지지.</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ol>
<li>position과 transform 조합.<ul>
<li>position을 %값으로 줘서 부모 영역과 유기적으로 움직일 수 있게 배치한 후,</li>
<li>transform 으로 세밀하게 조정.</li>
</ul>
</li>
<li>video 태그의 속성 중에서, autoplay 는 크롬에서 안 됨.<ul>
<li>접근성의 문제.</li>
<li>스크린리더의 소리와 겹치면 문제가 되기 때문에,</li>
<li>기본값으로 mute를 주면 쓸 수 있음.</li>
</ul>
</li>
<li>video 아래 태그.<ul>
<li>source: 브라우저가 지원하는 동영상 포맷이 각각 다를 때, source를 사용해 여러 포맷을 제공했었다.</li>
<li>track: 자막 -&gt; 동영상에는 자막이 필수.</li>
</ul>
</li>
<li>.responsive: 이미지나 동영상에서 width: 100%를 준다.<ul>
<li>부모 요소의 크기에 맞추어 크기가 조절될 수 있게.</li>
<li>이미지는 height: auto;가 필요하지만, 동영상은 필요 없음.</li>
</ul>
</li>
<li>margin, padding 에서 height 값을 %로 줬을 때, 기준은 부모 요소의 가로.</li>
<li>svg 코드<ul>
<li>이미지가 아닌 코드로 삽입되어 있을 때,</li>
<li>css나 js에서 제어가 용이하다.</li>
<li>svg 코드만 묶어 스프라이트 파일을 만들 수도 있다.</li>
<li>성능이 향상됨</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/02/201101-html-css-practice-responsive-web-page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/201101-html-css-practice-responsive-web-page/" class="post-title-link" itemprop="url">201101-html css practice-responsive web page</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-02 20:14:09 / Modified: 20:14:38" itemprop="dateCreated datePublished" datetime="2020-11-02T20:14:09+09:00">2020-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/html-css/" itemprop="url" rel="index"><span itemprop="name">html/css</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTML-CSS-PRACTICE-반응형-페이지"><a href="#HTML-CSS-PRACTICE-반응형-페이지" class="headerlink" title="HTML/CSS PRACTICE 반응형 페이지"></a>HTML/CSS PRACTICE 반응형 페이지</h1><ul>
<li>반응형 페이지 이디야 샘플 헤더 부분</li>
</ul>
<hr>
<h2 id="반응형-페이지에-대해"><a href="#반응형-페이지에-대해" class="headerlink" title="반응형 페이지에 대해"></a>반응형 페이지에 대해</h2><ol>
<li>모바일 디바이스의 등장으로 다양한 크기의 화면에 대응할 필요성<ul>
<li>초기에는 모바일용 웹페이지를 따로 제작했지만,</li>
<li>이후에는 한 화면이 크기에 맞춰 재구성될 수 있도록.</li>
<li>One Source Multi Use</li>
</ul>
</li>
<li>Flexible / Adaptive<ul>
<li>화면에 맞추어 늘어나거나 줄어드는 구성인지(Flexible)</li>
<li>일정 크기 안에서는 고정된 구성인지(Adaptive)</li>
<li>샘플 및 실습은 고정형(Adaptive)로.</li>
<li>어느 게 맞다 틀리다는 아님. 컨텐츠에 따라 다를 수 있다.</li>
<li>상황에 따라 마크업을 따로 해야하는 경우도 있음.</li>
</ul>
</li>
<li>반응형 페이지의 기획<ul>
<li>큰 화면에서 작은 화면으로, 혹은 작은 화면에서 큰 화면으로.</li>
<li>경우에 따라 둘 다 사용할 수 있지만,</li>
<li>일반적으로 작은 화면에서 큰 화면으로 기획하는 것이 용이하다.</li>
</ul>
</li>
<li>반응형 페이지의 레이아웃<ul>
<li>Flexible 페이지일 때,</li>
<li>px 등의 단위로 레이아웃을 고정하지 않고,</li>
<li>%, vw, vh 등으로 레이아웃을 지정한다.</li>
<li>백분율 계산 = target/context</li>
</ul>
</li>
<li>@media all and (~)</li>
<li>img {max-width: 100%} -&gt; 크기가 변하는 이미지에서, 원본 사이즈보다는 커지지 않게.(이미지 깨짐 방지)</li>
<li>반응형 페이지에서 고려할 점<ol>
<li>성능/속도 및 대역폭<ul>
<li>적절한 크기의 이미지 등으로 성능이 저하되지 않도록 한다.</li>
</ul>
</li>
<li>고해상도 디스플레이<ul>
<li>최신의 모바일 기기에서, 스크린 크기와 상관없는 배율을 고려해, 고해상도의 이미지를 사용해야 한다.</li>
<li>그렇다고 다 고화질로 쓰면 또 성능 저하.</li>
</ul>
</li>
<li>아트 디렉션 처리<ul>
<li>크게 볼 때는 의미 전달이 잘 되던 이미지가,</li>
<li>작게 보면 어떤 의미인지 알 수 없을 때.</li>
<li>적당한 내용을 잘라내어(cropped) 보여줄 필요가 있다.</li>
<li>기획이 필요.</li>
</ul>
</li>
<li>모든 화면에서 이미지가 깨지지 않도록, svg 포맷을 고려.</li>
<li>해결 방안.<ol>
<li>img -&gt; srcset</li>
<li>picture tag</li>
<li>divece-pixel-ratio</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="html-주요-주석"><a href="#html-주요-주석" class="headerlink" title="html 주요 주석"></a>html 주요 주석</h2><ol>
<li>viewport meta<ul>
<li>width=device-width 디바이스 크기에 맞춘다는 의미</li>
<li>initial-scale=1.0 배율<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>여러가지 css를 링크<ul>
<li>기본적으로 들어가는 css(노멀라이즈, 리셋 등)</li>
<li>크기에 맞춰 적용할 css(데스크탑 대응, 모바일 대응 등)</li>
</ul>
</li>
<li>닫기 버튼의 x는 알파벳 x 아니고 특문.<ul>
<li>크기도 다르고, 배치도 다르다.</li>
</ul>
</li>
<li>svg 포멧을 코드로 넣을 때,<ul>
<li>img 태그와 달리 alt를 넣지 않음.</li>
<li>title을 넣어준다.<h2 id="html-전체-코드"><a href="#html-전체-코드" class="headerlink" title="html 전체 코드"></a>html 전체 코드</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;</span><br><span class="line">  &lt;title&gt;이디야 커피(Ediya Coffee)&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;이디야 커피 브랜드 사이트 (학습용) 홈페이지입니다.&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;이디야, 커피, 브랜드, 사이트, 학습용, 홈페이지, 이듬, 블렌디드 러닝&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;이듬(E.UID)&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;link rel&#x3D;&quot;preload&quot; as&#x3D;&quot;style&quot; href&#x3D;&quot;&#x2F;&#x2F;spoqa.github.io&#x2F;spoqa-han-sans&#x2F;css&#x2F;SpoqaHanSans-kr.css&quot; &#x2F;&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;preload&quot; as&#x3D;&quot;style&quot; href&#x3D;&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;normalize&#x2F;8.0.1&#x2F;normalize.min.css&quot; &#x2F;&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;preload&quot; as&#x3D;&quot;style&quot; href&#x3D;&quot;.&#x2F;style&#x2F;style.css&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 스타일링 --&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;style&#x2F;style.css&quot; &#x2F;&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;shortcut icon&quot; href&#x3D;&quot;.&#x2F;images&#x2F;favicon.png&quot; type&#x3D;&quot;image&#x2F;x-icon&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;app-header-container&quot;&gt;</span><br><span class="line">    &lt;header class&#x3D;&quot;app-header&quot;&gt;</span><br><span class="line">      &lt;h1 class&#x3D;&quot;brand&quot;&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;.&#x2F;index.html&quot;&gt;&lt;img src&#x3D;&quot;.&#x2F;images&#x2F;brand.svg&quot; alt&#x3D;&quot;Ediya Coffee&quot; class&#x3D;&quot;respons&quot; &#x2F;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;button is-open-menu&quot; aria-label&#x3D;&quot;메뉴 열기&quot; title&#x3D;&quot;메뉴 열기&quot;&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;ir&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;nav class&#x3D;&quot;app-navigation&quot;&gt;</span><br><span class="line">        &lt;h2 class&#x3D;&quot;a11y-hidden&quot;&gt;메인 메뉴&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ul class&#x3D;&quot;reset-list&quot;&gt;</span><br><span class="line">          &lt;li&gt;&lt;a href&#x3D;&quot;.&#x2F;views&#x2F;login-fds.html&quot;&gt;로그인&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;&lt;a href&#x3D;&quot;.&#x2F;views&#x2F;signup-fds.html&quot;&gt;회원 가입&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;&lt;a href&#x3D;&quot;.&#x2F;views&#x2F;ui-design.html&quot;&gt;이디야 디자인&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;&lt;a href&#x3D;&quot;.&#x2F;views&#x2F;beverage-fds.html&quot;&gt;이디야 음료&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;&lt;a href&#x3D;&quot;.&#x2F;views&#x2F;news-fds.html&quot;&gt;이디야 뉴스&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">          &lt;li&gt;&lt;a href&#x3D;&quot;.&#x2F;views&#x2F;store-fds.html&quot;&gt;매장 찾기&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;button is-close-menu&quot; title&#x3D;&quot;메뉴 닫기&quot; aria-label&#x3D;&quot;메뉴 닫기&quot;&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;close&quot; aria-hidden&#x3D;&quot;true&quot;&gt;×&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;nav&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="css-주요-주석"><a href="#css-주요-주석" class="headerlink" title="css 주요 주석"></a>css 주요 주석</h2><ol>
<li>공통으로 적용할 부분과 모바일, 데스크탑에서 따로 적용할 부분을 구분.</li>
<li>작성 내용을 주석으로 잘 적어 두어야 나중에 쉽게 찾을 수 있다.(유지보수 용이)</li>
<li>width: 100%;<ul>
<li>position: fixed, left: 0, right: 0, 하는 방법도 있음.</li>
<li>단 브라우저 호환이 안 될 수도 있음.</li>
</ul>
</li>
<li>backdrop-filter</li>
<li>명도 차이가 분명하지 않아 접근성 기준에 맞지 않을 때,<ul>
<li>텍스트를 이미지로 넣는 편법도 있다.</li>
</ul>
</li>
<li>margin: -1;<ul>
<li>네거티브 마진 검색해 볼 것.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 숨김 제목 및 콘텐츠 *&#x2F;</span><br><span class="line">.a11y-hidden,</span><br><span class="line">legend &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  position: absolute !important;</span><br><span class="line">  clip: rect(0, 0, 0, 0);</span><br><span class="line">  clip-path: polygon(0 0, 0 0, 0 0);</span><br><span class="line">  width: 1px;</span><br><span class="line">  height: 1px;</span><br><span class="line">  margin: -1px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2></li>
</ul>
</li>
<li>모든 웹페이지에게 반응형이 필요한 건 아니다.<ul>
<li>너무 복잡한 ui의 페이지는, 모바일에 맞는 콘텐츠만 가져다 따로 다시 만들 수 있다.</li>
</ul>
</li>
<li>읽지 말아야 하는 이미지(아이콘 등)을 마크업해야 하는 경우<ul>
<li>alt 값을 null 준다. (alt=””)</li>
<li>alt를 넣었기 때문에 정량적으로는 접근성에 충족. 하지만 값은 없음.</li>
</ul>
</li>
<li>rwd breakpoints 2020 검색<ul>
<li>2020년 일반적인 디바이스 크기 확인.</li>
<li>breakpoints 반응형 페이지가 구성을 확인할 구간.</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://troy.labs.daum.net/">http://troy.labs.daum.net/</a></li>
<li>프로젝트를 할 때 고려해야 할 것<ul>
<li>퍼포먼스, 접근성, 검색최적화.</li>
<li>어떤 것을 고려하여 제작했는지 문서화도 중요.(md 파일 정리.)</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bg-shorthand</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bg-shorthand</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
