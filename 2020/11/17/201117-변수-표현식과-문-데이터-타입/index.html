<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bg-shorthand.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="변수 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고 그 결과를 출력(output)하는 것이 전부다. 변수는 그 데이터를 관리하기 위한 핵심 개념변수가 필요한 이유     데이터 관리는 값을 메모리셀에 저장하는 것. 근데 그 메모리">
<meta property="og:type" content="article">
<meta property="og:title" content="201117- 변수, 표현식과 문, 데이터 타입">
<meta property="og:url" content="http://bg-shorthand.github.io/2020/11/17/201117-%EB%B3%80%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/index.html">
<meta property="og:site_name" content="bg-shorthand-blog">
<meta property="og:description" content="변수 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고 그 결과를 출력(output)하는 것이 전부다. 변수는 그 데이터를 관리하기 위한 핵심 개념변수가 필요한 이유     데이터 관리는 값을 메모리셀에 저장하는 것. 근데 그 메모리">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-17T10:43:50.000Z">
<meta property="article:modified_time" content="2020-11-17T10:44:14.273Z">
<meta property="article:author" content="bg-shorthand">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://bg-shorthand.github.io/2020/11/17/201117-%EB%B3%80%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>201117- 변수, 표현식과 문, 데이터 타입 | bg-shorthand-blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bg-shorthand-blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/17/201117-%EB%B3%80%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          201117- 변수, 표현식과 문, 데이터 타입
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-17 19:43:50 / Modified: 19:44:14" itemprop="dateCreated datePublished" datetime="2020-11-17T19:43:50+09:00">2020-11-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><ul>
<li>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름<ol>
<li>아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고 그 결과를 출력(output)하는 것이 전부다.</li>
<li>변수는 그 데이터를 관리하기 위한 핵심 개념<h2 id="변수가-필요한-이유"><a href="#변수가-필요한-이유" class="headerlink" title="변수가 필요한 이유"></a>변수가 필요한 이유</h2></li>
</ol>
</li>
</ul>
<ol>
<li>데이터 관리는 값을 메모리셀에 저장하는 것.</li>
<li>근데 그 메모리셀에 메모리 주소로 직접 접근하는 건 위험해.</li>
<li>실수로 운영체제가 사용하고 있는 메모리를 수정하거나 지우면 어떡해?</li>
<li>그러니까 직접 접근하지 않고,</li>
<li>메모리 공간을 식별하기 위한 이름을 붙여 관리.</li>
<li>그게 변수임.<ul>
<li>따라서 변수는, 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>
<li>프로그래밍 언어에서 값을 저장하고 참조(읽어 들이는)하는 메커니즘으로,</li>
<li>값의 위치를 가리키는 상징적인 ‘이름’</li>
<li>메모리 주소가 아닌 다른 명명을 한다는 것은,</li>
<li>사람이 이해할 수 있는 언어로 저장된 값의 의미를 명확히 할 수 있다는 것.</li>
<li>명확한 네이밍으로 코드를 이해하기 쉽게 해야겠지?</li>
<li>협업과 품질 향상에 도움<h2 id="할당과-참조"><a href="#할당과-참조" class="headerlink" title="할당과 참조"></a>할당과 참조</h2></li>
</ul>
</li>
<li>할당: 변수에 값을 저장하는 것</li>
<li>참조: 변수에 저장된 값을 읽어 들이는 것<h2 id="식별자"><a href="#식별자" class="headerlink" title="식별자"></a>식별자</h2></li>
</ol>
<ul>
<li>어떤 값을 구별해서 식별할 수 있는 고유한 이름</li>
<li>변수에서만 사용되는 용어가 아니라, 변수, 함수, 클래스 등의 이름을 모두 지칭함.(자바스크립트에서는 함수도 값)</li>
<li>메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름<ol>
<li>변수의 식별자는 메모리 주소와 매핑(그래야 거기 저장된 값을 찾지)</li>
<li>네이밍 규칙을 준수해야 함<h2 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h2></li>
</ol>
</li>
<li>변수를 생성하는 것.</li>
<li>값을 저장하기 위한 메모리 공간을 확보하고, 그 주소에 변수 이름을 연결,</li>
<li>값을 저장할 수 있게 준비하는 것.</li>
<li>변수를 사용하려면 꼭 필요해. 선언하지 않은 식별자에 접근하면 참조 에러(ReferenceError)<ol>
<li>확보된 메모리 공간은 해제되기 전까지 보호되므로, 안전하게 사용 가능.</li>
<li>var, let, const 키워드를 사용.</li>
<li>변수 선언에 의해 준비된 메모리 공간에는, undefined 라는 값이 암묵적으로 할당</li>
<li>즉, 변수 선언은 두 단계를 거침<ol>
<li>선언 단계: 메모리 공간 확보, 변수 이름 연결, 자바스크립트 엔진에 변수의 존재를 알림.</li>
<li>초기화 단계: 암묵적으로 undefined라는 값을 할당.</li>
</ol>
</li>
<li>초기화 단계를 거치지 않으면, 이전에 저장되어 있던 값(쓰레기 값)이 남아 있을 수 있다.<h2 id="변수-선언의-실행-시점"><a href="#변수-선언의-실행-시점" class="headerlink" title="변수 선언의 실행 시점"></a>변수 선언의 실행 시점</h2></li>
</ol>
</li>
<li>변수 선언은 런타임 이전 단계에서 먼저 실행됨.<ol>
<li>자바스크립트 엔진은 소스코드를 실행하기 앞서 소스코드 평가 과정을 거침.</li>
<li>이 과정에서 변수 선언을 포함한 모든 선언문을 먼저 실행.</li>
<li>따라서, 변수 선언이 어느 위치에 있든 변수 참조 가능</li>
<li>이처럼 변수 선언문이 선두로 끌어올려지는 것처럼 동작하는 자바스크립트 특유의 동작을 ‘호이스팅’이라고 함<h2 id="변수-선언과-할당의-단축-그리고-호이스팅"><a href="#변수-선언과-할당의-단축-그리고-호이스팅" class="headerlink" title="변수 선언과 할당의 단축, 그리고 호이스팅"></a>변수 선언과 할당의 단축, 그리고 호이스팅</h2></li>
</ol>
</li>
</ul>
<ol>
<li>변수 선언과 할당은 하나의 문으로 단축해 쓸 수 있음.</li>
<li>하지만 동작은 나눠서 해.</li>
<li>호이스팅에 의해 변수 선언’만’ 먼저 실행</li>
<li>근데 말이야,</li>
<li>할당은 이전의 undefined 값을 지우고 할당 하는 게 아니라, 새로운 메모리 공간을 확보하고 거기에 저장(이게 무슨 의미지? 선언과 할당이 명확히 구분되어 동작한단 의미?)<h2 id="값의-재할당"><a href="#값의-재할당" class="headerlink" title="값의 재할당"></a>값의 재할당</h2></li>
<li>var 키워드로 선언한 변수는 값이 변할 수 있는 변수.</li>
<li>할당과 마찬가지로 새로운 메모리 공간을 확보하고 거기에 저장</li>
<li>불필요해진 이전의 메모리 공간은 가비지 콜렉터에 의해 자동 해제<ul>
<li>가비지 콜렉터: 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release)하는 기능</li>
<li>가비지 콜렉터가 내장된 언어를 ‘매니지드 언어’, 없는 언어를 ‘언매니지드 언어’라고 함.</li>
<li>매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다. 일정한 생산성을 확보할 수 있지만, 성능 면에서는 손실을 감수할 수밖에 없다.</li>
<li>언매니지드 언어는 개발자가 직접 메모리를 할당, 해제할 수 있는 메모리 제어 기능을 제공. 개발자의 역량에 따라 최적의 성능을 기대할 수 있지만, 반대의 경우 폭망.<h2 id="식별자-네이밍-규칙"><a href="#식별자-네이밍-규칙" class="headerlink" title="식별자 네이밍 규칙"></a>식별자 네이밍 규칙</h2></li>
</ul>
</li>
<li>식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.</li>
<li>단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.</li>
<li>예약어는 식별자로 사용할 수 없다.</li>
<li>유니코드 문자 사용으로 한글 등도 사용가능하지만 권장 안함</li>
<li>대소문자를 구분함</li>
<li>명확한 의미의 이름을 사용.</li>
<li>네이밍 컨벤션은 어떤 것을 사용해도 좋으나, 통일은 해야지.</li>
<li>일반적으로, 변수나 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용<h3 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h3></li>
<li>키워드: 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행</li>
<li>예약어: 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. 자바스크립트의 예약어는 다음과 같다.<ul>
<li>await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* switch this throw true try typeof var void while with yield*</li>
<li><ul>
<li>식별자로 사용 가능하나 Strict Mode에서는 사용 불가</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="표현식과-문"><a href="#표현식과-문" class="headerlink" title="표현식과 문"></a>표현식과 문</h1><h2 id="값"><a href="#값" class="headerlink" title="값"></a>값</h2><ul>
<li>식(표현식, expression)이 평가(evaluate)되어 생성된 결과<ol>
<li>‘표현식’을 ‘평가’하다</li>
<li>변수에 할당되는 것이 ‘값’<h2 id="값을-생성하는-방법"><a href="#값을-생성하는-방법" class="headerlink" title="값을 생성하는 방법"></a>값을 생성하는 방법</h2></li>
</ol>
</li>
</ul>
<ol>
<li>리터럴<ul>
<li>사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(‘’, “”, ., [], {}, // 등)를 사용해 값을 생성하는 표기 방식</li>
<li>자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성. -&gt; 리터럴은 값을 생성하기 위해 미리 약속된 표기법</li>
<li>리터럴을 통해 생성할 수 있는 값<ol>
<li>정수 리터럴 (ex. 100)</li>
<li>부동소수점 리터럴 (ex. 1.5)</li>
<li>2진수 리터럴 (ex. 0b01000001 -&gt; 0b로 시작)</li>
<li>8진수 리터럴 (ex. 0o101 -&gt; 0o로 시작)</li>
<li>16진수 리터럴 (ex. 0x41 -&gt; 0x로 시작)</li>
<li>문자 리터럴 (ex. ‘hello’ “world”)</li>
<li>불리언 리터럴 (ex. true false)</li>
<li>null 리터럴</li>
<li>undefined 리터럴</li>
<li>객체 리터럴 (ex. { name: ‘Lee’, address: ‘Seoul’ })</li>
<li>배열 리터럴 (ex. [ 1, 2, 3 ])</li>
<li>함수 리터럴 (ex. function() {})</li>
<li>정규표현식 리터럴 (ex. /[A-Z]+/g)</li>
</ol>
</li>
</ul>
</li>
<li>표현식 <ul>
<li>값으로 평가될 수 있는 문(statement)</li>
<li>값으로 평가되면 표현식 -&gt; 리터럴도 값으로 평가되므로, 리터럴도 표현식이다. -&gt; 식별자 ‘참조’ 역시 값으로 평가되므로 표현식</li>
<li>표현식과 값은 동치, 즉 표현식은 값처럼 사용될 수 있다 -&gt; 문법적으로 값이 위치해야 할 위치에 표현식이 위치 가능.<h2 id="문-statement"><a href="#문-statement" class="headerlink" title="문(statement)"></a>문(statement)</h2></li>
</ul>
</li>
</ol>
<ul>
<li>프로그램을 구성하는 기본 단위이자 최소 실행 단위</li>
<li>문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍<ol>
<li>문은 여러 토큰으로 이루어진다.<ul>
<li>토큰: 문법적 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</li>
<li>키워드, 식별자, 연산자, 리터럴, 세미콜론 따위</li>
</ul>
</li>
<li>문은 ‘명령문’이라고도 부른다 -&gt; 문이 실행되면 명령이 실행되고, 무언가 일어남.</li>
<li>선언문, 할당문, 조건문, 반복문 등으로 구분</li>
<li>세미콜론(;)<ul>
<li>문의 종료를 표시</li>
<li>자바스크립트 엔진은 세미콜론으로 문의 종료를 파악하고 순차적으로 실행</li>
<li>단, 문을 중괄호로 묶은 블록 뒤에는 세미콜론 표시 안함 -&gt; 코드 블록은 언제나 자체 종결성을 갖기 때문</li>
<li>세미콜론은 생략 가능. 자바스크립트 엔진의 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문<h2 id="표현식과-문-1"><a href="#표현식과-문-1" class="headerlink" title="표현식과 문"></a>표현식과 문</h2></li>
</ul>
</li>
</ol>
</li>
<li>표현식은 문의 일부분일 수도, 그 자체로 문일 수도 있다.</li>
<li>문이 값으로 평가 되면 표현식. 아닐 수도 있지</li>
<li>확인하는 가장 간단한 방법은 문을 변수에 할당해 보는 것. -&gt; 값으로 평가되는 표현식이면 할당이 될 거고, 값으로 평가되지 않으면 에러.<h2 id="용어-1"><a href="#용어-1" class="headerlink" title="용어"></a>용어</h2></li>
</ul>
<ol>
<li>완료 값: 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 완료 값이라 한다. 완료 값은 표현식의 평가 결과가 아니다.</li>
</ol>
<hr>
<h1 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h1><ul>
<li>값의 종류</li>
<li>원시 타입: 숫자, 문자열, 불리언, undefined, null, 심벌</li>
<li>객체 타입: 객체, 함수, 배열 등 (함수도 값이다!)<h2 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h2></li>
<li>변경 불가능한 값</li>
<li>변수에 다른 원시타입을 할당하는 경우는 기존의 값이 변경되는게 아니라 새로운 값이 생성되어 할당되는 것.<ol>
<li>숫자 타입<ul>
<li>자바스크립트는 정수와 실수를 구분하지 않고 하나의 숫자 타입만 제공</li>
<li>2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않으므로, 이들 값을 참조하면 모두 10진수로 해석</li>
<li>숫자 타입의 세 가지 특별한 값<ol>
<li>10/0 -&gt; infinity: 양의 무한대</li>
<li>10/-0 -&gt; -infinity: 음의 무한대</li>
<li>1*”string” -&gt; NaN: 산술 연산 불가(NAN, Nan 등과 다름. 자바스크립트 엔진은 대소문자를 구별하므로, 이와 같은 표현은 식별자로 해석)</li>
</ol>
</li>
</ul>
</li>
<li>문자열 타입<ul>
<li>유니코드 문자로, 전 세계 대부분의 문자를 표현 가능</li>
<li>‘’, “”, `` 으로 감싸 표현 가능. 일반적으론 ‘’</li>
<li>키워드, 식별자 등과 구분하기 위해 감싸서 표현</li>
<li>자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다</li>
<li>문자열 연산자 + 로 연결 가능</li>
<li>템플릿 리터럴<ul>
<li>멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능을 제공</li>
<li>런타임에 문자열로 변환되어 처리</li>
<li>백틱(``)을 사용해 표현<ol>
<li>이스케이프 시퀀스를 사용하지 않고도 줄바꿈, 공백 등이 그대로 적용</li>
<li>${ } 을 통해 표현식 삽입 가능. 안의 표현식은 강제로 문자열로 바뀜(표현식 삽입은 반드시 템플릿 리터럴 에서만. 일반 문자열에서는 ${}도 문자열로 취급)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>불리언<ul>
<li>true, false</li>
</ul>
</li>
<li>undefined<ul>
<li>var 키워드로 선언한 변수는 undefined 로 암묵적 초기화</li>
<li>엔진이 변수를 초기화 하는데 쓰는 undefined를 개발자가 의도적으로 할당하면 취지와 어긋나,</li>
<li>권장하지 않음.</li>
<li>변수에 값이 없다는 걸 명시하고 싶을 땐, null을 써</li>
</ul>
</li>
<li>null<ul>
<li>변수에 값이 없다는 걸 명시</li>
<li>이전에 할당 되어 있던 값에 대한 참조를 명시적으로 제거</li>
<li>값은 가비지 가비지 콜렉터가 지움</li>
</ul>
</li>
<li>symbol 타입<ul>
<li>다른 값과 중복되지 않는 유일무이한 값</li>
<li>주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용<h2 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h2></li>
</ul>
</li>
</ol>
</li>
<li>데이터는 크기가 정해져 있지 않고 변수에 할당될 때 값이 직접 해당 변수에 저장될 수 없으며, 변수에는 데이터에 대한 참조만 저장된다. 참조는 참조 타입 데이터의 주소이지 해당 데이터의 값이 아니다.</li>
<li>객체에 대해서는 후에 자세히 알아볼 텐데, 중요한 것은 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것.</li>
<li>이거 궁금한데, 일단 원시 타입 여섯 개의 데이터 타입 외의 값은 모두 객체<h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2></li>
</ul>
<ol>
<li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해<h2 id="동적-타입-언어인-자바스크립트"><a href="#동적-타입-언어인-자바스크립트" class="headerlink" title="동적 타입 언어인 자바스크립트"></a>동적 타입 언어인 자바스크립트</h2></li>
<li>정적 타입 언어와 동적 타입 언어<ul>
<li>정적 타입 언어: 변수를 선언할 때, 데이터 타입을 먼저 선언 -&gt; 컴파일 때 타입이 맞는지를 확인하고, 안 맞으면 에러, -&gt; 더욱 안정적인 코드의 구현 가능</li>
<li>동적 타입 언어: 데이터 타입 선언이 따로 없음, 값에 따라 데이터 타입이 결정<ul>
<li>할당에 의해 타입이 결정(타입 추론)</li>
<li>재할당으로 언제든 변수의 타입이 바뀔 수 있다-&gt; 동적 타입 언어</li>
<li>변수는 기본적으로 타입을 갖지 않지만, 연결된 값에 따라 타입을 갖게 됨</li>
<li>변수에 자유롭게 할당을 할 수 있어 편리하지만, 단점이 있지</li>
</ul>
</li>
</ul>
</li>
<li>동적 타입 언어의 단점<ul>
<li>동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다</li>
<li>개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다</li>
<li>유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어진다</li>
</ul>
</li>
<li>단점으로 인해 주의해야 할 점<ul>
<li>변수는 꼭 필요한 경우에 한해 제한적으로 사용</li>
<li>변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제</li>
<li>전역 변수는 최대한 사용하지 않도록</li>
<li>변수보다는 상수를 사용해 값의 변경을 억제</li>
<li>변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍<h2 id="용어-2"><a href="#용어-2" class="headerlink" title="용어"></a>용어</h2></li>
</ul>
</li>
<li>이스케이프 시퀀스: 문자열에서, 줄바꿈 등의 공백(white space)을 표현하는 방법. (ex. \0)</li>
<li>라인 피드와 캐리지 리턴<ul>
<li>라인 피드(LF, Line Feed): 커서를 정지한 상태에서 종이를 한 줄 올리는 것</li>
<li>캐리지 리턴(CR, Carriage Return): 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것</li>
<li>개행 방식의 차이</li>
<li>운영체제마다 다른 개행 방식을 따르는데,</li>
<li>대부분의 텍스트 에디터는 운영체제에 맞게 개행 방식을 바꿔줘</li>
<li>자바스크립트에서 라인 피드와 캐리지 리턴은 모두 개행을 의미한다. 하지만 캐리지 리턴(\r)으로 개행하는 경우는 거의 없고 일반적으로 라인 피드(\n)를 사용해 개행한다.</li>
</ul>
</li>
<li>트레이드 오프: 두 개의 정책 목표 가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적 관계</li>
<li>은 탄환: 고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/16/201116-pixel-compiled-language-interpreter-language/" rel="prev" title="201116-pixel, compiled language, interpreter language">
      <i class="fa fa-chevron-left"></i> 201116-pixel, compiled language, interpreter language
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/19/201119-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%A0%9C%EC%96%B4%EB%AC%B8-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80/" rel="next" title="연산자, 제어문, 타입 변환, 단축 평가">
      연산자, 제어문, 타입 변환, 단축 평가 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%EB%B3%80%EC%88%98"><span class="nav-number">1.</span> <span class="nav-text">변수</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%B3%80%EC%88%98%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0"><span class="nav-number">1.1.</span> <span class="nav-text">변수가 필요한 이유</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%95%A0%EB%8B%B9%EA%B3%BC-%EC%B0%B8%EC%A1%B0"><span class="nav-number">1.2.</span> <span class="nav-text">할당과 참조</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%8B%9D%EB%B3%84%EC%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">식별자</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8"><span class="nav-number">1.4.</span> <span class="nav-text">변수 선언</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8%EC%9D%98-%EC%8B%A4%ED%96%89-%EC%8B%9C%EC%A0%90"><span class="nav-number">1.5.</span> <span class="nav-text">변수 선언의 실행 시점</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8%EA%B3%BC-%ED%95%A0%EB%8B%B9%EC%9D%98-%EB%8B%A8%EC%B6%95-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85"><span class="nav-number">1.6.</span> <span class="nav-text">변수 선언과 할당의 단축, 그리고 호이스팅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EA%B0%92%EC%9D%98-%EC%9E%AC%ED%95%A0%EB%8B%B9"><span class="nav-number">1.7.</span> <span class="nav-text">값의 재할당</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99"><span class="nav-number">1.8.</span> <span class="nav-text">식별자 네이밍 규칙</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EC%9A%A9%EC%96%B4"><span class="nav-number">1.8.1.</span> <span class="nav-text">용어</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8"><span class="nav-number">2.</span> <span class="nav-text">표현식과 문</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EA%B0%92"><span class="nav-number">2.1.</span> <span class="nav-text">값</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EA%B0%92%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95"><span class="nav-number">2.2.</span> <span class="nav-text">값을 생성하는 방법</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%AC%B8-statement"><span class="nav-number">2.3.</span> <span class="nav-text">문(statement)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-1"><span class="nav-number">2.4.</span> <span class="nav-text">표현식과 문</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%9A%A9%EC%96%B4-1"><span class="nav-number">2.5.</span> <span class="nav-text">용어</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85"><span class="nav-number">3.</span> <span class="nav-text">데이터 타입</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85"><span class="nav-number">3.1.</span> <span class="nav-text">원시 타입</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EA%B0%9D%EC%B2%B4-%ED%83%80%EC%9E%85"><span class="nav-number">3.2.</span> <span class="nav-text">객체 타입</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1"><span class="nav-number">3.3.</span> <span class="nav-text">데이터 타입의 필요성</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4%EC%9D%B8-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8"><span class="nav-number">3.4.</span> <span class="nav-text">동적 타입 언어인 자바스크립트</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%9A%A9%EC%96%B4-2"><span class="nav-number">3.5.</span> <span class="nav-text">용어</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bg-shorthand</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bg-shorthand</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
