<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bg-shorthand.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="bg-shorthand-blog">
<meta property="og:url" content="http://bg-shorthand.github.io/page/2/index.html">
<meta property="og:site_name" content="bg-shorthand-blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="bg-shorthand">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://bg-shorthand.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>bg-shorthand-blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bg-shorthand-blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/10/201210-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%A1%9C%EC%A0%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/201210-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%A1%9C%EC%A0%80/" class="post-title-link" itemprop="url">201210-실행 컨텍스트, 클로저</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-10 12:49:10 / Modified: 12:49:28" itemprop="dateCreated datePublished" datetime="2020-12-10T12:49:10+09:00">2020-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h1><h1 id="소스코드의-타입"><a href="#소스코드의-타입" class="headerlink" title="소스코드의 타입"></a>소스코드의 타입</h1><ol>
<li>전역 코드: 전역 변수를 관리하기 위한 전역 스코프 생성. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결 -&gt; 전역 실행 컨텍스트 생성</li>
<li>지역 스코프 생성, 지역 변수, 매개변수, 아규먼츠 객체 관리, 지역 스코프를 스코프 체인에 연결. -&gt; 함수 실행 컨텍스트 생성</li>
<li>eval 코드: 뭐.</li>
<li>모듈 코드: 나중에 보나?<h1 id="소스코드의-평가와-실행"><a href="#소스코드의-평가와-실행" class="headerlink" title="소스코드의 평가와 실행"></a>소스코드의 평가와 실행</h1></li>
<li>실행 전, 소스코드의 평가.<ul>
<li>변수, 함수 등의 선언문만 먼저 실행.</li>
<li>식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록.</li>
</ul>
</li>
<li>실행(런타임)<ul>
<li>참조는 스코프에서 검색해 취득하고,</li>
<li>변수 값이 변경과 같은 실행 결과는 다시 스코프에 등록.<h1 id="실행-컨텍스트의-역할"><a href="#실행-컨텍스트의-역할" class="headerlink" title="실행 컨텍스트의 역할"></a>실행 컨텍스트의 역할</h1></li>
</ul>
</li>
</ol>
<ul>
<li>코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</li>
<li>즉,<ol>
<li>식별자를 스코프에 따라 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.</li>
<li>스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다.</li>
<li>현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</li>
</ol>
</li>
<li>이 일을 하는 게 실행 컨텍스트.</li>
<li>식별자를 등록, 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘이다.</li>
<li>식별자와 스코프는 실행 컨텍스트의 ‘렉시컬 환경’으로 관리.</li>
<li>코드 실행 순서는 ‘실행 컨텍스트 스택’으로 관리<h1 id="실행-컨텍스트-스택"><a href="#실행-컨텍스트-스택" class="headerlink" title="실행 컨텍스트 스택"></a>실행 컨텍스트 스택</h1></li>
<li>스택 자료구조.(선입후출)</li>
<li>실행되는 실행 컨텍스트가 추가(push), 실행 끝나면 삭제(pop).</li>
<li>전역 코드와 함수 코드로 구분되어서 진행 되고,</li>
<li>각 코드는 실행 전에 평가 단계를 거친다.</li>
<li>선입후출 구조로, 나중에 실행된 코드가 종료되면, 이전에 실행되던 코드로 돌아간다.</li>
<li>스택의 최상위에 존재하는 실행 컨텍스트가 현재 진행 중인 코드의 실행 컨텍스트. 이걸 ‘실행 중인 실행 컨텍스트’라고 부른다.<h1 id="렉시컬-환경"><a href="#렉시컬-환경" class="headerlink" title="렉시컬 환경"></a>렉시컬 환경</h1></li>
<li>식별자와 식별자에 비인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조.</li>
<li>즉, 식별자와 스코프를 관리한단 거지.</li>
<li>두 개를 관리해야 하네? 두 개의 컴포넌트.<ol>
<li>환경 레코드: 식별자를 등록하고 식별자에 바인딩된 값을 구분하는 저장소.</li>
<li>외부 렉시컬 환경에 대한 참조: 단방향 링크드 리스트인 스코프 체인 구현.<h1 id="실행-컨텍스트의-생성과-식별자-검색-과정"><a href="#실행-컨텍스트의-생성과-식별자-검색-과정" class="headerlink" title="실행 컨텍스트의 생성과 식별자 검색 과정"></a>실행 컨텍스트의 생성과 식별자 검색 과정</h1></li>
</ol>
</li>
</ul>
<ol>
<li>전역 객체 생성<ul>
<li>전역 객체는 전역 코드가 평가되기 이전에 생성. 빌트인 전역 프로퍼티/함수/객체 등이 있고, 동작 환경에 따라 호스트 객체를 포함.</li>
<li>이 전역 객체도 Object.prototype을 상속 받는다.</li>
</ul>
</li>
<li>전역 코드 평가<ol>
<li>전역 실행 컨텍스트 생성</li>
<li>전역 렉시컬 환경 생성<ol>
<li>전역 환경 레코드 생성</li>
<li>객체 환경 레코드 생성</li>
<li>선언적 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
<li>전역 코드 실행</li>
<li>(함수 호출을 만나면) 함수 코드 평가<ol>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ol>
<li>함수 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
<li>함수 코드 실행</li>
<li>함수 코드 실행 종료</li>
<li>전역 코드 실행 종료<h1 id="실행-컨텍스트와-블록-레벨-스코프"><a href="#실행-컨텍스트와-블록-레벨-스코프" class="headerlink" title="실행 컨텍스트와 블록 레벨 스코프"></a>실행 컨텍스트와 블록 레벨 스코프</h1></li>
</ol>
<ul>
<li>소스코드는 전역 코드와 함수 코드로 구분하니까,</li>
<li>블록 레벨 스코프의 코드 블록은 따로 실행 컨텍스트를 만들지 않는다.</li>
<li>근데 let/const는 블록 레벨 스코프를 만들잖아?</li>
<li>이를 위해 블록 레벨 스코프는,</li>
<li>선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.</li>
<li>즉, 실행 컨텍스트는 그대로 둔 상태에서,</li>
<li>연결되어 있던 렉시컬 환경을 ‘선언적 환경 레코드를 갖는 렉시컬 환경’으로 교체.</li>
<li>새로 연결된 렉시컬 환경은 기존의 렉시컬 환경을 상위 스코프로 갖는다.</li>
<li>코드 블록이 끝나면, 이전의 렉시컬 환경으로 복귀.</li>
<li>만약 코드 블록 내에 함수가 있다면, 이 함수의 상위 스코프는 코드 블록이 생성한 렉시컬 환경(선언적 환경 레코드를 갖는 렉시컬 환경).</li>
</ul>
<hr>
<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><ul>
<li>중첩 함수에서,</li>
<li>내부 함수가 외부 함수보다 오래 살아남으며,</li>
<li>외부 함수가 갖는 식별자를 내부 함수가 참조할 때,</li>
<li>그 내부 함수를 클로저라고 부른다.<h1 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h1></li>
<li>렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.<h1 id="함수-객체의-내부-슬롯-Envirobnment"><a href="#함수-객체의-내부-슬롯-Envirobnment" class="headerlink" title="함수 객체의 내부 슬롯 [[Envirobnment]]"></a>함수 객체의 내부 슬롯 [[Envirobnment]]</h1></li>
<li>함수 객체는 호출과 상관없이, 자신이 정의된 환경, 상위 스코프를 기억해야 한다.</li>
<li>이를 위해 함수 객체는 함수 정의가 평가 될 때,(런타임 이전에) 내부 슬롯 [[Environment]] 에 상위 스코프의 참조를 저장한다.</li>
<li>이 상위 스코프는 ‘현재 실행 중인 실행 컨텍스트’의 렉시컬 환경이다.</li>
<li>내부 슬롯에 기억하므로, 함수객체가 존재하는 한, 함수는 상위 스코프를 기억한다.</li>
<li>후에 함수가 호출 되어 함수 코드가 평가되기 시작하면,</li>
<li>함수 렉시컬 환경의 구성 요소인 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.<h1 id="클로저와-렉시컬-환경"><a href="#클로저와-렉시컬-환경" class="headerlink" title="클로저와 렉시컬 환경"></a>클로저와 렉시컬 환경</h1></li>
<li>중첩 함수에서, 외부 함수가 실행이 종료 되었을 때,</li>
<li>외부 함수의 실행 컨텍스트는 스택에서 제거되지만, 렉시컬 환경까지 소멸하는 것은 아니다.(가비지 컬렉터가 처리하지 않는다.)</li>
<li>내부 함수의 [[Environment]]에 의해 참조되고 있기 때문.</li>
<li>내부 함수가 다른 곳(변수 등)에서 참조되고 있다면,</li>
<li>외부 함수 없이 내부 함수를 호출할 수 있고, 이 때 외부 함수 객체의 변수에도 접근할 수 있다.</li>
<li>모든 함수는 상위 스코프를 기억하므로, 이론적으로 모든 함수는 클로저지만,</li>
<li>일반적으로 모든 함수를 클로저라고는 하지 않는다.</li>
<li>클로저는,<ol>
<li>상위 스코프의 식별자를 참조한다.</li>
<li>상위 스코프보다 생명 주기가 길다.</li>
</ol>
</li>
<li>를 만족해야 한다.</li>
<li>클로저에 의해 참조되는 상위 스코프의 변수는 ‘자유 변수’.<h1 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h1></li>
<li>클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 카운트 상태 변경 함수</span><br><span class="line">const increase &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저</span><br><span class="line">  return function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 카운트 상태를 1만큼 증가 시킨다.</span><br><span class="line">    return ++num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 2</span><br><span class="line">console.log(increase()); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저인 메서드를 갖는 객체를 반환한다.</span><br><span class="line">  &#x2F;&#x2F; 객체 리터럴은 스코프를 만들지 않는다.</span><br><span class="line">  &#x2F;&#x2F; 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F; num: 0, &#x2F;&#x2F; 프로퍼티는 public하므로 은닉되지 않는다.</span><br><span class="line">    increase() &#123;</span><br><span class="line">      return ++num;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrease() &#123;</span><br><span class="line">      return num &gt; 0 ? --num : 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const Counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; ① 카운트 상태 변수</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  function Counter() &#123;</span><br><span class="line">    &#x2F;&#x2F; this.num &#x3D; 0; &#x2F;&#x2F; ② 프로퍼티는 public하므로 은닉되지 않는다.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter.prototype.increase &#x3D; function () &#123;</span><br><span class="line">    return ++num;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Counter.prototype.decrease &#x3D; function () &#123;</span><br><span class="line">    return num &gt; 0 ? --num : 0;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return Counter;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const counter &#x3D; new Counter();</span><br><span class="line"></span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.increase()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter.decrease()); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure></li>
<li>변수 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 외부 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.</li>
<li>아래의 클로저는, 내용은 같지만 서로 다른 렉시컬 환경을 참조하는 클로저<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수를 인수로 전달받고 함수를 반환하는 고차 함수</span><br><span class="line">&#x2F;&#x2F; 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.</span><br><span class="line">function makeCounter(predicate) &#123;</span><br><span class="line">&#x2F;&#x2F; 카운트 상태를 유지하기 위한 자유 변수</span><br><span class="line">let counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 클로저를 반환</span><br><span class="line">  return function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.</span><br><span class="line">    counter &#x3D; predicate(counter);</span><br><span class="line">    return counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function increase(n) &#123;</span><br><span class="line">  return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function decrease(n) &#123;</span><br><span class="line">  return --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수로 함수를 생성한다.</span><br><span class="line">&#x2F;&#x2F; makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환한다</span><br><span class="line">const increaser &#x3D; makeCounter(increase); &#x2F;&#x2F; ①</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.</span><br><span class="line">const decreaser &#x3D; makeCounter(decrease); &#x2F;&#x2F; ②</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -1</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -2</span><br></pre></td></tr></table></figure></li>
<li>아래와 같이 수정<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수를 반환하는 고차 함수</span><br><span class="line">&#x2F;&#x2F; 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.</span><br><span class="line">const counter &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 카운트 상태를 유지하기 위한 자유 변수</span><br><span class="line">  let counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 함수를 인수로 전달받는 클로저를 반환</span><br><span class="line">  return function (predicate) &#123;</span><br><span class="line">    &#x2F;&#x2F; 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.</span><br><span class="line">    counter &#x3D; predicate(counter);</span><br><span class="line">    return counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function increase(n) &#123;</span><br><span class="line">  return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수</span><br><span class="line">function decrease(n) &#123;</span><br><span class="line">  return --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 보조 함수를 전달하여 호출</span><br><span class="line">console.log(counter(increase)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter(increase)); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 자유 변수를 공유한다.</span><br><span class="line">console.log(counter(decrease)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(counter(decrease)); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<h1 id="캡슐화와-정보-은닉"><a href="#캡슐화와-정보-은닉" class="headerlink" title="캡슐화와 정보 은닉"></a>캡슐화와 정보 은닉</h1></li>
<li>캡슐화(encapsulation)는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉(information hiding)이라 한다.</li>
<li>즉시 실행 함수를 활용하여 생성자 함수와 프로토타입 프로퍼티 추가를 묶음.</li>
<li>이 경우 클로저를 단 한번 생성하기 대문에, 인스턴스가 여러 개 만들어지면 동일한 상위 스코프를 사용하게 된다.</li>
<li>자바스크립트는 정보 은닉을 완전하게 지원하지 않는다. 인스턴스 메서드를 사용한다면 자유 변수를 통해 private을 흉내 낼 수는 있지만 프로토타입 메서드를 사용하면 이마저도 불가능해진다.</li>
<li>클래스에 private 필드를 정의할 수 있는 표준 사양이 제안되어 있는데, 이건 나중에.<h1 id="자주-발생하는-실수"><a href="#자주-발생하는-실수" class="headerlink" title="자주 발생하는 실수"></a>자주 발생하는 실수</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  funcs[i] &#x3D; function () &#123; return i; &#125;; &#x2F;&#x2F; ①</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var j &#x3D; 0; j &lt; funcs.length; j++) &#123;</span><br><span class="line">  console.log(funcs[j]()); &#x2F;&#x2F; ②</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 레벨 스코프 특성으로 인해 for 문의 초기화 문에서 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상.</li>
<li>아래처럼 수정할 수 있는데,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">  funcs[i] &#x3D; (function (id) &#123; &#x2F;&#x2F; ①</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return id;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var j &#x3D; 0; j &lt; funcs.length; j++) &#123;</span><br><span class="line">  console.log(funcs[j]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let을 사용하면 깔금하게 해결.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const funcs &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  funcs[i] &#x3D; function () &#123; return i; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; funcs.length; i++) &#123;</span><br><span class="line">  console.log(funcs[i]()); &#x2F;&#x2F; 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let/const 선언을 사용하면, 블록 레벨 스코프가 적용 되어, for문의 코드 블록이 실행될 때마다 새로운 렉시컬 환경이 만들어진다.</li>
<li>이 때 코드 블록 내에 정의한 함수가 있다면, 이 함수의 상위 스코프는 새로운 렉시컬 환경이 된다.</li>
<li>독립적인 렉시컬 환경을 각각 갖으므로, 식별자의 값을 유지할 수 있다.</li>
<li>단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.</li>
<li>고차 함수를 사용하는 방법도 있는데, 나중에 다시 배움.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/08/201206-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/201206-this/" class="post-title-link" itemprop="url">201206-this</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-08 14:47:18 / Modified: 14:47:31" itemprop="dateCreated datePublished" datetime="2020-12-08T14:47:18+09:00">2020-12-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ul>
<li>객체는 상태를 나타내는 프로퍼티와, 동작을 나타내는 메서드를 묶은 복합적인 자료구조.</li>
<li>그 중에 메서드는, 자신이 속한 객체의 상태(프로퍼티)를 참조하고 변경할 수 있어야 하는데,</li>
<li>그러려면 메서드가 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야지.</li>
<li>그래서 자바스크립트는 this라는 특수한 식별자를 제공한다.</li>
<li>즉, this는 자신이 속한 객체, 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수.</li>
<li>this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프프로퍼티나 메서드를 참조할 수 있다.</li>
<li>this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있는데,</li>
<li>this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.<h1 id="함수-호출-방식과-this-바인딩"><a href="#함수-호출-방식과-this-바인딩" class="headerlink" title="함수 호출 방식과 this 바인딩"></a>함수 호출 방식과 this 바인딩</h1></li>
<li>함수 호출 방식(일반 함수 호출, 메서드 호출, 생성자 함수 호출, Function.prototype.apply/call/bind 메서드에 의한 간접 호출)에 따라 this 바인딩이 결정.</li>
</ul>
<ol>
<li>일반 함수 호출<ul>
<li>전역 객체가 바인딩 된다.</li>
<li>중첩, 콜백 함수도 일반 함수로 호출이 되면 전역 객체에 바인딩.</li>
<li>여기서 중첩, 콜백 함수의 this가 전역 객체를 바인딩하는 것은 문제가 있다.</li>
<li>이 둘은 보통 헬퍼 함수의 역할을 하는데, 외부 함수와 this 바인딩이 다르면 헬퍼 함수 역할을 하기 힘들어.</li>
<li>그래서 이런 식으로 쓰지.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; this 바인딩(obj)을 변수 that에 할당한다.</span><br><span class="line">    const that &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 콜백 함수 내부에서 this 대신 that을 참조한다.</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(that.value); &#x2F;&#x2F; 100</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Function.protytype.apply/call/bind를 쓰기도 해<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 콜백 함수에 명시적으로 this를 바인딩한다.</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(this.value); &#x2F;&#x2F; 100</span><br><span class="line">    &#125;.bind(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>화살표 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  value: 100,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    &#x2F;&#x2F; 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.</span><br><span class="line">    setTimeout(() &#x3D;&gt; console.log(this.value), 100); &#x2F;&#x2F; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>메서드 호출<ul>
<li>메서드를 호출한 객체와 바인딩.</li>
<li>메서드를 소유한 객체와 바인딩되는 게 아님.</li>
<li>왜냐면, 메서드를 소유한 객체라는 건, 사실 그 객체의 프로퍼티 키가 독립적으로 존재하는 함수 객체를 바인딩하고 있는 것일 뿐이니까.</li>
<li>이 독립적인 함수 객체는 여러 곳에 바인딩될 수 있어.</li>
<li>변수든, 다른 메서드든.</li>
<li>즉, this 바인딩은 메서드를 소유한 객체와 되는 게 아니라, 메서드를 호출한 객체와 바인딩.</li>
</ul>
</li>
<li>생성자 함수 호출<ul>
<li>생성자 함수가 생성할 인스턴스와 바인딩.</li>
</ul>
</li>
<li>Function.prototype.apply/call/bind 메서드에 의한 간접 호출<ul>
<li>apply, call, bind 메서드는 Function.prototype의 메서드. -&gt; 모든 함수가 상속받아 사용 가능.</li>
<li>Function.prototype.apply, Function.prototype.call 메서드는 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 ‘호출’한다.(호출하려고 쓰는 메서드임.)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getThisBinding() &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; this로 사용할 객체</span><br><span class="line">const thisArg &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span><br><span class="line">&#x2F;&#x2F; apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.</span><br><span class="line">console.log(getThisBinding.apply(thisArg, [1, 2, 3]));</span><br><span class="line">&#x2F;&#x2F; Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">&#x2F;&#x2F; &#123;a: 1&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.</span><br><span class="line">console.log(getThisBinding.call(thisArg, 1, 2, 3));</span><br><span class="line">&#x2F;&#x2F; Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">&#x2F;&#x2F; &#123;a: 1&#125;</span><br></pre></td></tr></table></figure></li>
<li>apply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우.</li>
<li>arguments 객체는 배열이 아닌 유사 배열 객체기 때문에, 배열의 메서드를 사용할 수 없다.</li>
<li>그때, apply나 call을 써서 배열을 전달해주면,</li>
<li>배열 메서드를 쓸 수 있게 할 수 있다.</li>
<li>자세한 내용은 후에 배열을 다루면서.</li>
<li>Function.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다.</li>
<li>bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  foo(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; bind 메서드로 callback 함수 내부의 this 바인딩을 전달</span><br><span class="line">    setTimeout(callback.bind(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.foo(function () &#123;</span><br><span class="line">  console.log(&#96;Hi! my name is $&#123;this.name&#125;.&#96;); &#x2F;&#x2F; Hi! my name is Lee.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/03/201204-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/201204-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/" class="post-title-link" itemprop="url">201204- 함수와 일급 객체, 프로토타입, 빌트인 객체</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-03 20:36:23 / Modified: 20:36:35" itemprop="dateCreated datePublished" datetime="2020-12-03T20:36:23+09:00">2020-12-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h1 id="일급-객체"><a href="#일급-객체" class="headerlink" title="일급 객체"></a>일급 객체</h1><ul>
<li>일급 객체의 조건<ol>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
</ol>
</li>
<li>자바스크립트의 함수는 위의 조건을 모두 만족하므로, 일급 객체다.</li>
<li>객체왈 동일하게 사용할 수 있단 의미이고,</li>
<li>값과 동일하게 취급,</li>
<li>값을 사용하는 곳이라면 어디든지 리터럴로 정의 가능,</li>
<li>런타임에 함수 객체로 평가.</li>
<li>객체와 같지만, 일반 객체에는 없는 함수 고유의 프로퍼티를 갖는다.<h1 id="함수-객체의-프로퍼티"><a href="#함수-객체의-프로퍼티" class="headerlink" title="함수 객체의 프로퍼티"></a>함수 객체의 프로퍼티</h1></li>
<li>arguments, caller, length, name, propotype.</li>
<li>특히, __proto__는 접근자 프로퍼티로, Object.prototype 객체의 프로퍼티를 상속 받은 것.</li>
<li>Object.prototype의 프로퍼티로 모든 객체가 사용할 수 있다.(프로토타입)</li>
</ul>
<ol>
<li>arguments: 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한(이터러블iterable) 유사 배열 객체. 인수를 프로퍼티 값으로 가지며, 프로퍼티 키는 인수의 순서. length프로퍼티는 인수의 개수, callee 프로퍼티는 arguments 객체를 생성한 함수, 즉 자기 자신. 가변 인자 함수를 구현할 때 유용하다.</li>
<li>caller: 함수 자신을 호출한 함수. 사양에 포함되지 않은 비표준 프로퍼티이며, 앞으로 표준화 예정도 없다.</li>
<li>length: 함수를 정의할 때 선언한 매개변수의 개수.</li>
<li>name: 함수 이름. 익명 함수 표현식의 경우, ES5에서는 빈 문자열. ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.</li>
<li><strong>proto</strong>: [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 ‘접근자 프로퍼티’. </li>
<li>ptrototype: constructor 함수만 갖는 프로퍼티로, 함수가 객체를 생성하는 생성자 함수로 호출될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</li>
</ol>
<hr>
<h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><ul>
<li>자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어.</li>
<li>ES6부터 도입된 클래스. 새로운 객체 생성 메커니즘이다.<h1 id="객체-지향-프로그래밍"><a href="#객체-지향-프로그래밍" class="headerlink" title="객체 지향 프로그래밍"></a>객체 지향 프로그래밍</h1></li>
<li>실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도.</li>
<li>실체는 특징이나 성질을 나타내는 속성(attribute/property)을 가지고 있고, 이를 통해 실체를 인식, 구분.</li>
<li>이러한 방식으로, 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현하는 것이 추상화.</li>
<li>이 추상화를 통해 객체를 다른 객체와 구별할 수 있다.</li>
<li>즉, 객체는 여러 개의 값(속성)을 하나의 단위로 구성한 복합적인 자료구조.</li>
<li>객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.</li>
<li>이 때,</li>
<li>객체의 속성은 상태(프로퍼티), 동작(메서드)로 구분할 수 있다.</li>
<li>이 상태와 동작을 하나의 논리적인 단위로 묶은 게 함수고, 객체는 다른 객체와 메시지를 주고 받거나 데이터를 처리하거나,</li>
<li>다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다.(상속)<h1 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h1></li>
<li>상속은 객체지향 프로그래밍의 핵심 개념(코드의 재사용으로 개발 비용을 줄일 수 있는 잠재력이 있다)으로, 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.</li>
<li>가령, Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, Cicle.prototype의 모든 프로퍼티와 메서드를 상속받는다.</li>
<li>인스턴스에서 공통적으로 사용될 프로퍼티나 메서드를 Circle.prototype에 구현해두면?</li>
<li>모든 인스턴스가 상속받아 사용할 수 있는 거지.<h1 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h1></li>
<li>상속을 구현(목적)으로 사용.</li>
<li>모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값이 프로토타입의 참조.(null인 경우도 있다.)</li>
<li>동시에 프로토타입은 생성자 함수와 연결되어 있다.</li>
<li>생성자 함수 &lt;-&gt; 프로토타입 &lt;- 객체</li>
<li>객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근할 수 있으며,</li>
<li>프로토타입은 자신의 constructor프로퍼티를 통해 생성자 함수에 접근할 수 있고,</li>
<li>생성자 함수는 prototype프로퍼티를 통해 프로토타입에 접근할 수 있다.<h1 id="prototype-접근자-프로퍼티"><a href="#prototype-접근자-프로퍼티" class="headerlink" title="prototype 접근자 프로퍼티"></a><strong>prototype</strong> 접근자 프로퍼티</h1></li>
</ul>
<ol>
<li><strong>proto</strong> 는 접근자 프로퍼티다.<ul>
<li>getter/setter 함수를 통해 프로토타입을 취득하거나 할당.</li>
<li>프로토타입을 부르거나, 교체할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티는 상속을 통해 사용된다.<ul>
<li>기본적으로 __proto__는 Object.prototype의 프로퍼티.</li>
<li>모든 객체의 프로토타입 체인상 끝에는 Object.prototype이 있으므로,</li>
<li>__proto__를 상속받아 사용할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유.<ul>
<li>__proto__은 순환참조를 막도록 구현되어 있다.</li>
<li>단방향 리크드 리스트로 프로토타입 체인을 구현할 수 있다.</li>
</ul>
</li>
<li><strong>proto</strong> 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.<ul>
<li>직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 만들 수 있다.</li>
<li>이 경우 __proto__를 사용할 수 없으므로,</li>
<li>Object.getPrototypeOf, Object.setPrototypeOf 메서드를 사용한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 취득</span><br><span class="line">Object.getPrototypeOf(obj); &#x2F;&#x2F; obj.__proto__;</span><br><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 교체</span><br><span class="line">Object.setPrototypeOf(obj, parent); &#x2F;&#x2F; obj.__proto__ &#x3D; parent;</span><br></pre></td></tr></table></figure>
<h1 id="함수-객체의-prototype-프로퍼티"><a href="#함수-객체의-prototype-프로퍼티" class="headerlink" title="함수 객체의 prototype 프로퍼티"></a>함수 객체의 prototype 프로퍼티</h1></li>
</ul>
</li>
</ol>
<ul>
<li>생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</li>
<li>화살표 함수와 메서드 축약 표현으로 정의한 메서드는 non-constructor 함수로, prototype 프로퍼티를 가질 이유가 없지.</li>
<li>생성자 함수를 목적으로 만들지 않은 함수도 prototype 프로퍼티를 가지고는 있다. 의미는 없지만.<h1 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h1></li>
<li>prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</li>
<li>프로토타입 체인 상 자식 역할의 객체도 상속받아 사용할 수 있다.<h1 id="리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h1></li>
<li>일단 결론은, Object.prototype을 프로토타입으로 갖는다.</li>
<li>리터럴이 평가 될 때는 추상연산 OrdinaryObjectCreate가 호출되어 객체 등을 만드는데,</li>
<li>프로퍼티 추가 처리 등의 세부 내용은 다르지만,</li>
<li>추상연산을 호출한다는 점에서 Object() 함수를 이용한 방법과 동일하다.</li>
<li>즉, 리터럴로 만든 객체, 함수, 배열, 정규 표현식은 각각 Object, Function, Array, RegExp 생성자 함수로 만든 각각과 같은 프로토타입을 갖는다.<h1 id="프로토타입의-생성-시점"><a href="#프로토타입의-생성-시점" class="headerlink" title="프로토타입의 생성 시점"></a>프로토타입의 생성 시점</h1></li>
<li>생성자 함수가 생성되는 시점과 같다.</li>
<li>즉 생성자 함수가 생성되면 동시에 프로토타입도 준비하는 건데,</li>
<li>생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분할 수 있다.</li>
</ul>
<ol>
<li>사용자 정의 생성자 함수와 프로토타입 생성 시점<ul>
<li>함수 정의가 평가 되어 함수 객체를 생성하는 시점에 프로토타입도 생성.</li>
<li>그게 언제야?</li>
<li>함수 선언문으로 정의된 생성자 함수는 런타임 이전에 평가.</li>
<li>그때 만드는 거지, 뭐.</li>
<li>이렇게 만들어진 프로토타입의 프로토타입은? Object.prototype.</li>
</ul>
</li>
<li>빌트인 생성자 함수와 프로토타입 생성 시점<ul>
<li>모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성.</li>
<li>이 때 같이 만들어지지.</li>
</ul>
</li>
</ol>
<ul>
<li>즉, 프로토타입은 이미 만들어져 준비되어 있는 거다!<h1 id="객체-생성-방식과-프로토타입의-결정"><a href="#객체-생성-방식과-프로토타입의-결정" class="headerlink" title="객체 생성 방식과 프로토타입의 결정"></a>객체 생성 방식과 프로토타입의 결정</h1></li>
<li>어떤 방식이든 추상연산 OrdinaryObjectCreate를 호출하는 건 동일,</li>
<li>이 때 인수로 주어지는 프로토타입이 다른 거야.<h1 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h1></li>
<li>사용자 정의 생성자 함수로 만들어진 프로토타입은 Object.prototype을 프로토타입으로 갖고,</li>
<li>그 생성자 함수로 만든 객체는 그 함수.prototype을 프로토타입으로 가져,</li>
<li>셋은 연결된다.</li>
<li>이게 프로토타입 체인.</li>
<li>객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 그 프로퍼티가 없으면 상위 프로토타입을 따라 가며 찾는다.</li>
<li>Object.prototype은 프로토타입 체인의 종점인데,</li>
<li>여기까지 가서도 찾는 프로퍼티가 없으면 undefined.</li>
<li>프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이다.</li>
<li>앞서 다뤘던 스코프 체인과 비슷하게 움직이는데,</li>
<li>둘은 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용한다.<h1 id="오버라이딩과-프로퍼티-섀도잉"><a href="#오버라이딩과-프로퍼티-섀도잉" class="headerlink" title="오버라이딩과 프로퍼티 섀도잉"></a>오버라이딩과 프로퍼티 섀도잉</h1></li>
<li>상속받아 사용하던 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가했을 때,</li>
<li>프로토타입 프로퍼티에 덮어쓰는 게 아니라, 인스턴스 프로퍼티로 추가.</li>
<li>사용되어지는 것도 인스턴스 프로퍼티.</li>
<li>삭제하면 없어지는 것도 인스턴스 프로퍼티.</li>
<li>이 때, 인스턴스 프로퍼티가 프로토타입 메서드를 ‘오버라이딩’ 했고, 이렇게 가려지는 현상을 ‘프로퍼티 섀도잉’ 이라고 한다.<h1 id="프로토타입의-교체"><a href="#프로토타입의-교체" class="headerlink" title="프로토타입의 교체"></a>프로토타입의 교체</h1></li>
</ul>
<ol>
<li>생성자 함수에 의한 프로토타입의 교체<ul>
<li>프로토타입으로 쓸 객체를 재할당 하면 되지.</li>
<li>이때 교체한 프로토타입에는 constructor 프로퍼티가 없지.</li>
<li>따라서 인스턴스의 생성자 함수를 찾으면 상위의 Object가 나올 거야.</li>
<li>동적 추가로 새 프로토타입에 constructor 프로퍼티를 만들 수 있다.</li>
</ul>
</li>
<li>인스턴스에 의한 프로토타입의 교체<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(me, parent);</span><br><span class="line">&#x2F;&#x2F; 위 코드는 아래의 코드와 동일하게 동작한다.</span><br><span class="line">&#x2F;&#x2F; me.__proto__ &#x3D; parent;</span><br></pre></td></tr></table></figure>
<ul>
<li>이 경우도 새 프로토타입이 constructor가 없지</li>
<li>그건 위와 같지만,</li>
<li>차이는 생성자 함수의 prototype 프로퍼티가 새 프로토타입을 가리키냐 아니냐.</li>
<li>이것도 재설정 할수 있다.(재할당)</li>
</ul>
</li>
</ol>
<ul>
<li>이처럼 프로토타입 교체를 통해 상속 관계를 변경하는 것은 번거롭다.</li>
<li>직접 상속이나 클래스가 편함.<h1 id="instanceof-연산자"><a href="#instanceof-연산자" class="headerlink" title="instanceof 연산자"></a>instanceof 연산자</h1></li>
<li>좌항에 위차한 객체의 프로토타입 체인에, 우변의 생성자 함수가 있으면 트루, 아니먼 펄스.</li>
<li>프로토타입인지를 확인하는 게 아니라, 프로토타입 체인에 존재하는지를 확인한다.<h1 id="직접-상속"><a href="#직접-상속" class="headerlink" title="직접 상속"></a>직접 상속</h1></li>
</ul>
<ol>
<li>Object.create에 의한 직접 상속<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj &#x3D; Object.create(Object.prototype);</span><br></pre></td></tr></table></figure>
<ul>
<li>new 연산자 없이도 객체를 생성할 수 있다.</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다.</li>
<li>객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.</li>
<li>그런데,</li>
<li>const obj = Object.create(null); 처럼 프로토타입 체인의 종점에 해당하는 객체를 만들 수도 있다.</li>
<li>이때 Object.prototype 빌트인 메서드를 사용할 수 없으므로, 빌트인 메서드는 간접적으로 호출해서 써야 하는데,</li>
<li>이 방법은 나중에.</li>
</ul>
</li>
<li>객체 리터럴 내부에서 <strong>proto</strong> 에 의한 직접 상속<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  y: 20,</span><br><span class="line">  &#x2F;&#x2F; 객체를 직접 상속받는다.</span><br><span class="line">  &#x2F;&#x2F; obj → myProto → Object.prototype → null</span><br><span class="line">  __proto__: myProto</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="정적-프로퍼티-메서드"><a href="#정적-프로퍼티-메서드" class="headerlink" title="정적 프로퍼티/메서드"></a>정적 프로퍼티/메서드</h1></li>
</ol>
<ul>
<li>생성자 함수가 가지고 있는 프로퍼티/메서드.</li>
<li>프로토타입에 있는 프로퍼티/메서드가 아니므로, 인스턴스가 참조/호출할 수 없지만,</li>
<li>직접 호출할 수는 있다.</li>
<li>참고로 프로토타입 프로퍼티/메서드를 표기할 때 prototype을 #으로 표기(예를 들어, Object.prototype.isPrototypeOf를 Object#isPrototypeOf으로 표기)하는 경우도 있으니 알아두도록 하자.<h1 id="프로퍼티-존재-확인"><a href="#프로퍼티-존재-확인" class="headerlink" title="프로퍼티 존재 확인"></a>프로퍼티 존재 확인</h1></li>
</ul>
<ol>
<li>in 연산자<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체에 name 프로퍼티가 존재한다.</span><br><span class="line">console.log(&#39;name&#39; in person);    &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<ul>
<li>객체 내 프로퍼티가 존재하는지 여부 확인.</li>
<li>상속받은 모든 프로퍼티를 확인한다.</li>
<li>같은 동작으로<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflect.has(person, &#39;name&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Object.prototype.hasOwnProperty 메서드<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.hasOwnProperty(&#39;name&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li>상속받은 프로퍼티는 빼고, 객체 고유의 프로퍼티인 경우에만 트루.<h1 id="프로퍼티-열거"><a href="#프로퍼티-열거" class="headerlink" title="프로퍼티 열거"></a>프로퍼티 열거</h1></li>
</ul>
</li>
<li>for…in 문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.</span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">  console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name: Lee</span><br><span class="line">&#x2F;&#x2F; address: Seoul</span><br></pre></td></tr></table></figure>
<ul>
<li>in 연산자처럼 상속받은 프로퍼티까지 열거.</li>
<li>단 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false인 경우는 열거 안함.</li>
<li>상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티 만을 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용해서 방어코드 작성.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#39;Seoul&#39;,</span><br><span class="line">  __proto__: &#123; age: 20 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">  &#x2F;&#x2F; 객체 자신의 프로퍼티인지 확인한다.</span><br><span class="line">  if (!person.hasOwnProperty(key)) continue;</span><br><span class="line">  console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name: Lee</span><br><span class="line">&#x2F;&#x2F; address: Seoul</span><br></pre></td></tr></table></figure></li>
<li>for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다.</li>
<li>배열에는 for 문이나 for…of 문 또는 Array.prototype.forEach 메서드를 사용하기를 권장. 배열에서 다시.</li>
</ul>
</li>
<li>Object.keys/values/entries 메서드<ul>
<li>객체 자신의 고유 프로퍼티만 열거.</li>
<li>Object.keys: 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.</li>
<li>Object.values: 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.</li>
<li>Object.entries: 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="빌트인-객체"><a href="#빌트인-객체" class="headerlink" title="빌트인 객체"></a>빌트인 객체</h1><h1 id="자바스크립트-객체의-분류"><a href="#자바스크립트-객체의-분류" class="headerlink" title="자바스크립트 객체의 분류"></a>자바스크립트 객체의 분류</h1><ol>
<li>표준 빌트인 객체: ECMAScript 사양에 정의된 객체. 애플리케이션 전역의 공통 기능을 제공. 전역 객체의 프로퍼티로서 제공된다. 따라서, 별도의 선언없이 언제나 참조할 수 있다.</li>
<li>호스트 객체: 자바스크립트 실행 환경이 추가로 제공하는 객체.</li>
<li>사용자 정의 객체: 사용자가 직접 정의한 객체<h1 id="표준-빌트인-객체"><a href="#표준-빌트인-객체" class="headerlink" title="표준 빌트인 객체"></a>표준 빌트인 객체</h1></li>
</ol>
<ul>
<li>Objet, String, Number, Boolean, Symbol, Date, Math, Array 등, 자바스크립트가 제공하는 표준 빌트인 객체.</li>
<li>Math, Reflect, JSON을 제외한 모든 표준 빌트인 객체는 인스턴스를 생성할 수 있다.</li>
<li>인스턴스를 생성할 수 있단 건, 정적 메서드와 프로토타입 메서드를 제공한다는 거지.</li>
<li>아닌 건 정적 메서드만 제공하는 거고.</li>
<li>표준 빌트인 객체가 생성한 인스턴스의 프로토타입은, 그 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.</li>
<li>이 프로토타입이 다양한 프로토타입 메서드를 제공.<h1 id="원시값과-래퍼-객체"><a href="#원시값과-래퍼-객체" class="headerlink" title="원시값과 래퍼 객체"></a>원시값과 래퍼 객체</h1></li>
<li>원시값을 마치 객체처럼 접근할 수 있는데(ex. str.length),</li>
<li>이 때 자바스크립트 엔진은 일시적으로 원시값을 연관된 객체로 변환.</li>
<li>객체로 아주 바꾸는 건 아니고, 할 일 다 하면 버림.</li>
<li>아무튼 이때 생성되는 임시 객체를 ‘래퍼 객체’라 한다.</li>
<li>객체가 되었으니 프로토타입의 메서드를 갖다 쓸 수도 있지.</li>
<li>문자열, 숫자, 불리언, 심벌이 이렇게 움직이는데,</li>
<li>불리언은 쓸 일이 없고, 심벌은 나중에 배움.</li>
<li>그외 null과 undefined는 래퍼 객체를 생성하지 않는다.<h1 id="전역-객체"><a href="#전역-객체" class="headerlink" title="전역 객체"></a>전역 객체</h1></li>
<li>코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.</li>
<li>프로토타입 체인상 최상위는 아님. 당연하지. 프로토타입이 아닌데.<h1 id="빌트인-전역-프로퍼티"><a href="#빌트인-전역-프로퍼티" class="headerlink" title="빌트인 전역 프로퍼티"></a>빌트인 전역 프로퍼티</h1></li>
<li>전역 객체의 프로퍼티.<br>주로 애플리케이션 전역에서 사용하는 값을 제공.</li>
</ul>
<ol>
<li>Infinity</li>
<li>NaN</li>
<li>undefined<h1 id="빌트인-전역-함수"><a href="#빌트인-전역-함수" class="headerlink" title="빌트인 전역 함수"></a>빌트인 전역 함수</h1></li>
</ol>
<ul>
<li>전역 객체의 메서드</li>
<li>전역에서 호출 가능.</li>
</ul>
<ol>
<li>eval<ul>
<li>금지라는데 일아야 하나?</li>
</ul>
</li>
<li>isFinite<ul>
<li>전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환하고, 무한수이면 false를 반환한다.</li>
<li>NaN으로 평가되면 false.</li>
<li>null은 0으로 변환되므로 true.</li>
</ul>
</li>
<li>isNaN<ul>
<li>전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.</li>
</ul>
</li>
<li>parseFloat<ul>
<li>전달받은 문자열 인수를 실수로 해석(parsing)하여 반환.</li>
</ul>
</li>
<li>parseInt<ul>
<li>전달받은 문자열 인수를 정수(integer)로 해석(parsing)하여 반환.</li>
<li>두 번째 인수로 진법을 나타내는 기수(2 ~ 36)를 전달할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#39;10&#39;을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다</span><br><span class="line">parseInt(&#39;10&#39;, 2); &#x2F;&#x2F; -&gt; 2</span><br></pre></td></tr></table></figure></li>
<li>기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메서드(“28.3.8. Number.prototype.toString” 참고)를 사용.</li>
</ul>
</li>
<li>encodeURI / decodeURI<ul>
<li>encodeURI 함수는 완전한 URI(Uniform Resource Identifier)를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.</li>
</ul>
</li>
<li>encodeURIComponent / decodeURIComponent<ul>
<li>encodeURIComponent 함수는 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. <h1 id="암묵적-전역"><a href="#암묵적-전역" class="headerlink" title="암묵적 전역"></a>암묵적 전역</h1></li>
</ul>
</li>
</ol>
<ul>
<li>선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다.</li>
<li>전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다.</li>
<li>변수는 아니므로, 호이스팅은 발생하지 않는다.</li>
<li>단지 프로퍼티니까, delete 연산자로 삭제할 수 있다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/12/02/201202-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/201202-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/" class="post-title-link" itemprop="url">201202-생성자 함수에 의한 객체 생성</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-02 10:04:52 / Modified: 10:05:14" itemprop="dateCreated datePublished" datetime="2020-12-02T10:04:52+09:00">2020-12-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h1 id="Object-생성자-함수"><a href="#Object-생성자-함수" class="headerlink" title="Object 생성자 함수"></a>Object 생성자 함수</h1><ul>
<li>new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수.</li>
<li>생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; new Object();</span><br></pre></td></tr></table></figure></li>
<li>빈 객체를 생성, 프로퍼티 또는 메소드를 추가하여 객체를 완성.<ul>
<li>String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인(built-in, 내장) 생성자 함수.</li>
</ul>
</li>
<li>객체 리터럴이 더 간편해, 특별한 이유가 없다면 그다지 유용하지 않다.<h1 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h1></li>
<li>객체 리터럴과 달리, 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Who(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.hi &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;hi $&#123;name&#125;!&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Who(han, 32);</span><br><span class="line">const you &#x3D; new Who(park, 31);</span><br></pre></td></tr></table></figure></li>
<li>이런 식.</li>
<li>this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수. 함수를 호출하면서, 어떤 ‘객체’와 바인딩.</li>
<li>위의 경우, 생성자 함수가 생성할 인스턴스와 바인딩된다.</li>
<li>다시 생성자 함수로 돌아가서,</li>
<li>생성자 함수는 일반 함수와 동일한 방법으로 정의된다.</li>
<li>이후 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작.</li>
<li>new 연산자가 없으면 일반 함수로 동작한다.</li>
<li>생성자 함수의 인스턴스 생성 과정(인스턴스 생성, 인스턴스 초기화)<ol>
<li>인스턴스 생성과 this 바인딩<ul>
<li>런타임 이전에 실행.</li>
<li>암묵적으로 빈 객체 생성.</li>
<li>객체는 this에 바인딩(식별자와 값을 연결).</li>
<li>필수.</li>
</ul>
</li>
<li>인스턴스 초기화<ul>
<li>런타임.</li>
<li>함수 몸체가 한 줄씩 실행되며, this에 바인딩되어 있는 인스턴스를 초기화(프로퍼티나 메서드를 추가.)</li>
<li>인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</li>
<li>옵션.(함수 몸체가 비어있을 수 있다. 이 경우 빈 객체 반환.)</li>
</ul>
</li>
<li>인스턴스 반환<ul>
<li>모든 처리가 끝나면 인스턴스(함수로 만들어진 객체)가 바인딩된 this가 암묵적으로 반환.</li>
<li>return 문으로 명시적인 다른 객체를 반환하면 this는 무시.</li>
<li>return 문으로 명시적인 원시값을 반환하면 무시, this 반환.</li>
<li>return 문으로 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손하므로 반드시 생략.<h1 id="내부-메서드-Call-과-Construct"><a href="#내부-메서드-Call-과-Construct" class="headerlink" title="내부 메서드 [[Call]] 과 [[Construct]]"></a>내부 메서드 [[Call]] 과 [[Construct]]</h1></li>
</ul>
</li>
</ol>
</li>
<li>함수는 객체이므로 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가진다.</li>
<li>일반 객체와 달리 호출할 수 있는 건, 함수 객체만이 가진 내부 슬롯과 내부 메서드가 있기 때문.</li>
<li>[[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드 등.</li>
<li>이 때, 함수가 일반 수로 호출되면 [[Call]]이, new 연산자와 함께 생성자 함수로 호출되면 [[Construct]]가 호출된다.</li>
<li>모든 함수는 호출이 가능하므로 [[Call]]을 가지고 있으나,</li>
<li>[[Construct]] 는 생성자 함수만 가지고 있다.</li>
<li>즉, 함수는 constructor 와 non-constructor로 구분할 수 있다.</li>
<li>모든 함수가 생성자 함수로서 호출할 수 있는 것은 아닌 것.<h1 id="constructor와-non-constructor의-구분"><a href="#constructor와-non-constructor의-구분" class="headerlink" title="constructor와 non-constructor의 구분"></a>constructor와 non-constructor의 구분</h1></li>
<li>constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)</li>
<li>non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수</li>
<li>여기서 메서드는, ES6의 메서드 축약 표현만을 의미.</li>
<li>non-constructor 함수는 [[Construct]]가 없으므로, 생성자 함수로 호출하면 에러.</li>
<li>주의할 것은 생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반 함수(callable이면서 constructor)에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것이다.</li>
<li>this 등의 객체를 만들기 위한 내용이 있어야 하는데 없는 애를 데리고 그럴 수 있단 거지.</li>
<li>그럴 때는, 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span><br><span class="line">let inst &#x3D; new add();</span><br><span class="line">&#x2F;&#x2F; 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.</span><br><span class="line">console.log(inst); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체를 반환하는 일반 함수</span><br><span class="line">function createUser(name, role) &#123;</span><br><span class="line">  return &#123; name, role &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span><br><span class="line">inst &#x3D; new createUser(&#39;Lee&#39;, &#39;admin&#39;);</span><br><span class="line">&#x2F;&#x2F; 함수가 생성한 객체를 반환한다.</span><br><span class="line">console.log(inst); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;, role: &quot;admin&quot;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="new-연산자"><a href="#new-연산자" class="headerlink" title="new 연산자"></a>new 연산자</h1></li>
<li>일반 호출일 땐 [[Call]] 호출, new 연산자와 함께 호출할 땐 [[Construct]] 호출.</li>
<li>생성자 함수로 만들어진 함수를 일반 호출하면, 내부의 this는 전역 객체 window와 바인딩.</li>
<li>이로 인해 만들어진 프로퍼티와 메서드는 전역 객체의 프로퍼티와 메서드가 된다.</li>
<li>일반 함수와 생성자 함수는 특별한 형식적 차이가 없으므로, 이름 짓는 방법을 구분한다. 일반적으로 생성자 함수는 첫 문자를 대문자로 기술하는 파스칼 케이스.<h1 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h1></li>
<li>함수를 정의할 때, 이후 호출에 new가 붙을지 안 붙을지 모르잖아?</li>
<li>그걸 확인하는 new.target</li>
<li>new 연산자와 함께 호출되면 new.target은 함수 자신을 가리키고,</li>
<li>일반 함수로 호출되면 new.target은 undefined.</li>
<li>이걸 이용해서 함수가 실행될 때 호출 방법을 확인하고, 재귀 호출로 new 연산자를 붙일 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.</span><br><span class="line">  if (!new.target) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.</span><br><span class="line">    return new Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.</span><br><span class="line">const circle &#x3D; Circle(5);</span><br><span class="line">console.log(circle.getDiameter());</span><br></pre></td></tr></table></figure></li>
<li>IE에서는 지원하지 않아, 스코프 세이프 생성자 패턴을 사용할 수도 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Scope-Safe Constructor Pattern</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고</span><br><span class="line">  &#x2F;&#x2F; this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다.</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다.</span><br><span class="line">  &#x2F;&#x2F; 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다.</span><br><span class="line">  if (!(this instanceof Circle)) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.</span><br><span class="line">    return new Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>프로토타입이랑 instanceof를 모르겠네. 나중에 다시.</li>
<li>아무튼 중요한 건 호출될 때 new가 붙었는지 안붙었는지 확인할 수 있단 건데,</li>
<li>대부분의 빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다.</li>
<li>가령, Object와 Function 은 new가 없이 호출되어도 new가 있는 것과 동일하게 동작.</li>
<li>String, Number, Boolean 생성자 함수는 new 연산자와 함께 호출했을 때 String, Number, Boolean 객체를 생성하여 반환하지만 new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. -&gt; 명시적 타입 변환 때 봤던 거. 이것도 결국 꼼수였네.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/29/201130-let-const%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/29/201130-let-const%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">201130 let, const와 블록 레벨 스코프, 프로퍼티 어트리뷰트</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-29 17:16:06 / Modified: 17:16:27" itemprop="dateCreated datePublished" datetime="2020-11-29T17:16:06+09:00">2020-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록-레벨-스코프"><a href="#let-const와-블록-레벨-스코프" class="headerlink" title="let, const와 블록 레벨 스코프"></a>let, const와 블록 레벨 스코프</h1><h1 id="var-키워드로-선언한-변수의-문제점"><a href="#var-키워드로-선언한-변수의-문제점" class="headerlink" title="var 키워드로 선언한 변수의 문제점"></a>var 키워드로 선언한 변수의 문제점</h1><ol>
<li>변수 중복 선언 허용<ul>
<li>var 키워드로 선언한 변수는 중복 선언을 허용한다.</li>
<li>중복 선언의 경우, 초기화문의 유무에 따라 다르게 동작.</li>
<li>초기화문이 있는 변수 선언문은 자바스크립트에 의해 var 키워드가 없는 것처럼(할당문만 있는 것처럼) 동작하고,</li>
<li>초기화문이 없는 변수 선언문은 무시된다.</li>
<li>변수 중복 선언은 의도치 않게 변수 값이 변경되는 부작용을 낳는다.</li>
</ul>
</li>
<li>함수 레벨 스코프<ul>
<li>var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.</li>
<li>함수 외부(if나 for 문의 블록 안쪽이더라도,)에서 선언한 변수는 모두 전역 변수가 된다.</li>
<li>전역 변수를 남발하게 되고, 중복 선언이 되는 경우가 발생한다.</li>
</ul>
</li>
<li>변수 호이스팅<ul>
<li>호이스팅에 의해 변수 선언문 이전에도 참조할 수 있다.(undefined)</li>
<li>에러는 아니지만, 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.<h1 id="let-키워드"><a href="#let-키워드" class="headerlink" title="let 키워드"></a>let 키워드</h1></li>
</ul>
</li>
</ol>
<ul>
<li>var 키워드의 단점을 보완하기 위해 만들어진 새로운 변수 선언 키워드.</li>
</ul>
<ol>
<li>변수 중복 선언 금지<ul>
<li>중복 선언하면 문법 에러(SyntaxError) 발생.</li>
</ul>
</li>
<li>블록 레벨 스코프</li>
<li>변수 호이스팅<ul>
<li>선언 단계와 초기화 단계가 분리되어 진행.</li>
<li>초기화 단계가 실행되기 이전에 접근하면 참조 에러(ReferenceError). -&gt; 일시적 사각지대.</li>
<li>호이스팅이 일어나지 않는 것은 아니다. 다만 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ul>
</li>
<li>전역 객체와 let<ul>
<li>let 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 아니다.</li>
<li>보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하는데, 이거 뭔지 아직 모름.<h1 id="const-키워드"><a href="#const-키워드" class="headerlink" title="const 키워드"></a>const 키워드</h1></li>
</ul>
</li>
</ol>
<ul>
<li>재할당이 금지됨. -&gt; 값의 불변과 다름.</li>
<li>선언과 동시에 초기화해야 한다. 그렇지 않으면 문법 에러.</li>
<li>재할당이 금지된 것으로, 객체가 할당되었을 경우 값을 변경할 수 있다.<h1 id="var-vs-let-vs-const"><a href="#var-vs-let-vs-const" class="headerlink" title="var vs. let vs. const"></a>var vs. let vs. const</h1></li>
<li>ES6를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.</li>
</ul>
<hr>
<h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><ul>
<li>(객체의) 프로퍼티 각각도 어트리뷰트를 갖고, 객체로 관리된다.<h1 id="내부-슬롯과-내부-메서드"><a href="#내부-슬롯과-내부-메서드" class="headerlink" title="내부 슬롯과 내부 메서드"></a>내부 슬롯과 내부 메서드</h1></li>
<li>자바스크립트 엔진의 구현 알고리즘을 ‘설명’하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티(pseudo property)와 의사 메서드(pseudo method).</li>
<li>예를 들어, 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다.</li>
<li>실제로 그 이름의 내부 슬롯이 있는지는 중요한 게 아니고, 그런 식으로 동작되는 원리가 있다는 게 중요.</li>
<li>원칙적으로 직접 접근할 수 없지만 [[Prototype]] 내부 슬롯의 경우 __proto__를 통해 간접적으로 접근할 수 있다.<h1 id="프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h1></li>
<li>자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</li>
<li>프로퍼티 상태: 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable). -&gt; 자바스크립트 엔진이 프로퍼티를 관리하는 내부 상태 값인 내부 슬롯.</li>
<li>각각에 직접 접근할 수는 없지만, Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyDescriptor(person, &#39;name&#39;));</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure></li>
<li>프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor) 객체. 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터는 undefined.</li>
<li>Object.getOwnPropertyDescriptors는 모든 프로퍼티 어트리뷰트 정보를 제공.(끝에 s. 복수형)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;,</span><br><span class="line">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="데이터-프로퍼티"><a href="#데이터-프로퍼티" class="headerlink" title="데이터 프로퍼티"></a>데이터 프로퍼티</h1></li>
<li>키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.</li>
<li>프로퍼티 어트리뷰트로 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 을 갖는다.</li>
<li>value: 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값. 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다. 이때 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</li>
<li>writable: 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</li>
<li>enumerable: 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티는 for…in 문이나 Object.keys 메서드 등으로 열거할 수 없다.</li>
<li>configurable: 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다. false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우 [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. -&gt; 객체 밀봉, 객체 동결.<h1 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h1></li>
<li>자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function)로 구성된 프로퍼티다. getter / setter 함수</li>
<li>프로퍼티 어트리뷰트로 [[Get]], [[Set]], [[Enumerable]], [[Configurable]] 을 갖는다.</li>
<li>get: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수. 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</li>
<li>set: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</li>
<li>객체 안에 접근자 프로퍼티라고 하는 함수가 있고, 이 함수를 통해 프로퍼티를 읽거나 쓸 수 있다.</li>
<li>읽을 때는 getter, 쓸 때는 setter가 쓰인다.<h1 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h1></li>
<li>새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것.</li>
<li>Object.defineProperty<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(person, &#39;firstName&#39;, &#123;</span><br><span class="line">  value: &#39;Ungmo&#39;,</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>정의할 때, 프로퍼티 어트리뷰트를 생략하면, 기본값은 undefined, false.</li>
<li>Object.defineProperties 메서드를 사용하면 여러 개의 프로퍼티를 한 번에 정의할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 데이터 프로퍼티 정의</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    value: &#39;Ungmo&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName: &#123;</span><br><span class="line">    value: &#39;Lee&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 접근자 프로퍼티 정의</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    &#x2F;&#x2F; getter 함수</span><br><span class="line">    get() &#123;</span><br><span class="line">      return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; setter 함수</span><br><span class="line">    set(name) &#123;</span><br><span class="line">      [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="객체-변경-방지"><a href="#객체-변경-방지" class="headerlink" title="객체 변경 방지"></a>객체 변경 방지</h1></li>
<li>프로퍼티 어트리뷰트를 재정의하여, 객체의 변경을 방지할 수 있다.</li>
<li>메서드 제공.</li>
</ul>
<ol>
<li>Object.preventExtensions<ul>
<li>객체 확장 금지.</li>
<li>프로퍼티 추가 금지.(프로퍼티 동적 추가, Object.defineProperty 모두.)</li>
<li>확장 가능한 객체인지 여부는 Object.isExtensible 메서드로 확인할 수 있다.</li>
</ul>
</li>
<li>Object.seal<ul>
<li>객체 밀봉. 읽기와 쓰기만 가능.(열거, 재정의 불가.)</li>
<li>밀봉된 객체인지 여부는 Object.isSealed 메서드로 확인 할 수 있다.</li>
</ul>
</li>
<li>Object.freeze<ul>
<li>객체 동결. 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의, 프로퍼티 값 갱신 금지. -&gt; 읽기만 가능.</li>
<li>동결된 객체인지 여부는 Object.isFrozen 메서드로 확인 할 수 있다.<h1 id="불변-객체"><a href="#불변-객체" class="headerlink" title="불변 객체"></a>불변 객체</h1></li>
</ul>
</li>
</ol>
<ul>
<li>위 세 메서드는 얕은 변경 방지로, 직속 프로퍼티만 변경 방지 되고 중첩 객체까지는 영향을 주지 못한다.(얕은 복사?)</li>
<li>중첩 객체까지 동결하여 불변 객체를 구현하려면, 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(target) &#123;</span><br><span class="line">  &#x2F;&#x2F; 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.</span><br><span class="line">  if (target &amp;&amp; typeof target &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; !Object.isFrozen(target)) &#123;</span><br><span class="line">    Object.freeze(target);</span><br><span class="line">    &#x2F;*</span><br><span class="line">      모든 프로퍼티를 순회하며 재귀적으로 동결한다.</span><br><span class="line">      Object.keys 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.</span><br><span class="line">      (&quot;19.15.2. Object.keys&#x2F;values&#x2F;entries 메서드&quot; 참고)</span><br><span class="line">      forEach 메서드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.</span><br><span class="line">      (&quot;27.9.2. Array.prototype.forEach&quot; 참고)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    Object.keys(target).forEach(key &#x3D;&gt; deepFreeze(target[key]));</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#123; city: &#39;Seoul&#39; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/26/201127-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/201127-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" class="post-title-link" itemprop="url">스코프, 전역 객체의 문제점</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-26 11:22:17 / Modified: 11:22:56" itemprop="dateCreated datePublished" datetime="2020-11-26T11:22:17+09:00">2020-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><ul>
<li>자바스크립트의 스코프는 다른 언어의 스코프와 구별되는 특징이 있어 주의가 필요하다.</li>
<li>모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.</li>
<li>이것이 스코프.</li>
<li>즉, 스코프는 식별자가 유효한 범위.</li>
<li>자바스크립트 엔진의 입장에서 보자면, ‘식별자를 검색할 때 사용하는 규칙’이라고도 볼 수 있다.</li>
<li>자바스크립트 엔진은 코드를 실행할 때 (암묵적 타입 변환 등에서 살펴봤듯이,) 코드의 문맥을 고려한다.</li>
<li>‘코드가 어디서 실행되며 주변에 어떤 코드가 있는지’를 렉시컬 환경이라고 부른다. = 코드의 문맥</li>
<li>이를 구현한 것이 ‘실행 컨텍스트’</li>
<li>그건 나중에 살펴볼 거고, 아무튼,</li>
<li>컴퓨터를 사용할 때 디렉토리가 다르면 같은 이름을 쓸 수 있는 것처럼,</li>
<li>식별자 이름 역시 스코프가 다르면 같은 이름을 사용할 수 있다.</li>
<li>즉, 스코프는 ‘네임스페이스(개체를 구분할 수 있는 범위)’다.</li>
<li>정리.<ol>
<li>식별자의 입장에서, 스코프는 ‘식별자가 유효한 범위’</li>
<li>자바스크립트 엔진의 입장에서, ‘식별자를 검색할 때 사용하는 규칙.’</li>
<li>같은 이름의 식별자를 구분하게 하는 ‘네임 스페이스’</li>
</ol>
</li>
<li>근데, var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용. 개판. let, const는 허용 안함.<h1 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h1></li>
</ul>
<ol>
<li>전역 스코프: 코드의 가장 바깥 영역 -&gt; 전역 변수<ul>
<li>전역 변수는 어디서든지 참조할 수 있다.</li>
</ul>
</li>
<li>지역 스코프: 함수 몸체 내부 -&gt; 지역 변수<ul>
<li>지역은 ‘함수 몸체 내부’</li>
<li>지역에 변수를 선언하면 그 지역을 ‘지역 스코프’로 갖는 ‘지역 변수’가 된다.</li>
<li>지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</li>
<li>상위 지역 스코프는 스코프는 유효하지 않아, 식별자가 같더라도 참조하지 않는다. -&gt; 스코프 체인<h1 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h1></li>
</ul>
</li>
</ol>
<ul>
<li>함수는 중첩이 가능하므로, 지역 역시 중첩이 가능하고, 지역 스코프도 중첩이 됨.</li>
<li>이말인 즉슨, 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 것.</li>
<li>상위 스코프 / 하위 스코프</li>
<li>최상위 스코프는 뭐야? 전역 스코프.</li>
<li>이렇게 스코프가 계층적으로 연결된 것을 ‘스코프 체인’이라고 한다.</li>
<li>스코프 체인은 ‘물리적인 실체’로 존재한다.<ul>
<li>스코프 체인, 렉시컬 환경, 실행 컨텍스트.</li>
<li>이런 자료 구조를 갖추고 관리한다는 말 같은데,</li>
<li>아직은 정확히 몰라.<h1 id="스코프-체인에-의한-변수-함수-검색"><a href="#스코프-체인에-의한-변수-함수-검색" class="headerlink" title="스코프 체인에 의한 변수, 함수 검색"></a>스코프 체인에 의한 변수, 함수 검색</h1></li>
</ul>
</li>
<li>자바스크립트 엔진은 변수를 참조할 때, 변수가 ‘선언’된 위치에서부터 ‘상위’스코프로 이동하며 변수 식별자를 검색한다.</li>
<li>‘상위’스코프로 이동하며 식별자를 검색한다 -&gt; 유효한 스코프는 자신과 하위 스코프다.</li>
<li>상속의 개념으로 생각할 수도 있다.</li>
<li>호이스팅? -&gt; 호이스팅 역시 스코프 단위로 동작한다.</li>
<li>함수의 경우,</li>
<li>자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.(함수 선언문)</li>
<li>그렇다면 똑같지 뭐.</li>
<li>자바스크립트 엔진은 코드 실행 전, 모든 (전역)선언문을 찾는다.<h1 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h1></li>
<li>대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 모든 코드 블록이 지역 스코프를 만든다. 이게 ‘블록 레벨 스코프’.</li>
<li>하지만 var키워드로 선언된 변수는 오로지 함수의 코드블록(함수 몸체)만을 지역 스코프로 인정한다. 이게 ‘함수 레벨 스코프’.<ul>
<li>예를 들어, if문의 코드 블록에서 var키워드로 선언된 변수는 전역 변수.</li>
<li>말만 들어도 개판이네,</li>
<li>let, const 키워드는 블록 레벨 스코프를 지원.<h1 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h1></li>
</ul>
</li>
<li>상위 스코프를 결정하는 두 가지 방식.<ol>
<li>함수를 어디서 ‘호출’ 했는지<ul>
<li>함수를 정의하는 시점에서, 이 함수가 어디서 호출될지 알 수 없다. 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 ‘동적 스코프’.</li>
</ul>
</li>
<li>함수를 어디서 ‘정의’ 했는지<ul>
<li>함수를 정의하는 순간 상위 스코프가 결정되므로 ‘정적 스코프’. 이를 ‘렉시컬 스코프’라고 부른다.</li>
<li>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h1 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1><ul>
<li>전역 변수의 무분별한 사용은 위험.</li>
<li>이름이 중복되기도 쉽고, 그 과정에서 값이 변하기도 할 테고.</li>
<li>전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면, 지역 변수를 사용해야 한다.<h1 id="지역-변수의-생명-주기"><a href="#지역-변수의-생명-주기" class="headerlink" title="지역 변수의 생명 주기"></a>지역 변수의 생명 주기</h1></li>
<li>변수에 생명 주기가 없다면, 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.</li>
<li>어우, 이러면 안 되지.</li>
<li>전역 변수는 애플리케이션이 종료되면 죽고, 함수 내부에서 선언된 지역 변수는 함수가 호출되면 태어났다가 종료하면 죽는다.</li>
<li>함수 몸체의 문들은 함수가 호출되어야만 하나씩 실행되기 때문.</li>
<li>즉, 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치.</li>
<li>스코프, 렉시컬 환경는 물리적 실체가 있는데, 함수가 종료되어도 누군가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존.</li>
<li>지역 변수가 함수보다 더 오래 사는 건데, 클로저가 뭔데.ㅠㅠ<h1 id="전역-변수의-생명-주기"><a href="#전역-변수의-생명-주기" class="headerlink" title="전역 변수의 생명 주기"></a>전역 변수의 생명 주기</h1></li>
<li>전역 코드는 함수 호출과 같이 특별한 진입점이 없으므로 코드가 로드되면 곧바로 해석, 실행.</li>
<li>마지막 문이 실행되면 종료.</li>
<li>var 키워드로 선언한 전역 변수는 이 전역에서, ‘전역 객체’의 프로퍼티가 된다.<ul>
<li>전역 객체: 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체.</li>
<li>클라이언트 사이드 환경(브라우저)에서는 window,</li>
<li>서버 사이드 환경(Node.js)에서는 global 객체를 의마하나,</li>
<li>ES11부터 globalThis로 통일.</li>
<li>이 객체는 프로퍼티로 ‘표준 빌트인 객체’, ‘호스트 객체’, ‘var 키워드로 선언한 전역 변수와 전역 함수’ 등이 있다.</li>
<li>이것도 나중에.</li>
</ul>
</li>
<li>전역 객체는 웹페이지가 닫히면 꺼지고, 전역 변수도 그때 사라져.<h1 id="전역-변수의-문제점-1"><a href="#전역-변수의-문제점-1" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1></li>
</ul>
<ol>
<li>암묵적 결합<ul>
<li>모든 코드가 전역 변수를 참조하고 변경할 수 있는 ‘암묵적 결합’</li>
<li>변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험.</li>
</ul>
</li>
<li>긴 생명 주기<ul>
<li>메모리 리소스도 오랜 기간 소비.</li>
<li>전역 변수의 상태를 변경할 수 있는 시간과 기회도 많아 위험.</li>
<li>이름도 중복될 가능성. -&gt; 의도치 않는 재할당의 위험.</li>
</ul>
</li>
<li>스코프 체인 상에서 종점에 존재<ul>
<li>검색 속도가 가장 느리다.</li>
<li>크진 않지만 차이가 있긴 있어.</li>
</ul>
</li>
<li>네임스페이스 오염<ul>
<li>자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.<h1 id="전역-변수의-사용을-억제하는-방법"><a href="#전역-변수의-사용을-억제하는-방법" class="headerlink" title="전역 변수의 사용을 억제하는 방법"></a>전역 변수의 사용을 억제하는 방법</h1></li>
</ul>
</li>
<li>즉시 실행 함수<ul>
<li>즉시 실행 함수를 통해 스코프를 인위적으로 만들 수도 있지.</li>
</ul>
</li>
<li>네임스페이스 객체<ul>
<li>전역 객체의 역할을 할 객체를 생성할 수 있어.</li>
<li>근데 어차피 네임스페이스 객체도 전역 변수에 할당되는 거잖아?</li>
<li>유용하지 않음.</li>
</ul>
</li>
<li>모듈 패턴<ul>
<li>모듈 패턴을 이해하려면 클로저를 먼저 이해해야 하므로 지금은 클로저라는 기능을 통해 전역 변수를 억제할 수 있다는 데 주목하자.</li>
</ul>
</li>
<li>ES6 모듈<ul>
<li>파일 자체의 독자적인 모듈 스코프를 제공.</li>
<li>모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다. script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다.</li>
<li>IE를 포함한 구형 브라우저에서는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.</li>
<li>후에 다시.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/24/201125-%ED%95%A8%EC%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/201125-%ED%95%A8%EC%88%98/" class="post-title-link" itemprop="url">함수</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-24 14:27:03" itemprop="dateCreated datePublished" datetime="2020-11-24T14:27:03+09:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-26 11:22:35" itemprop="dateModified" datetime="2020-11-26T11:22:35+09:00">2020-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5);</span><br></pre></td></tr></table></figure>
<ul>
<li>일련의 과정을 문(statement)로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.</li>
<li>함수 정의 통해 생성, 함수 호출을 통해 실행.</li>
<li>호출의 인수(argument)가 매개변수(parameter)를 통해 함수 몸체(문)의 과정을 실행하고 결과값 출력.</li>
<li>return이 없거나 값이 없으면, undefined 출력.<h1 id="함수의-사용-이유"><a href="#함수의-사용-이유" class="headerlink" title="함수의 사용 이유"></a>함수의 사용 이유</h1></li>
<li>코드의 재사용.</li>
<li>함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</li>
<li>적절한 함수 이름을 통해 코드의 가독성을 향상.<h1 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h1></li>
<li>자바스크립트의 함수는 객체 타입의 ‘값’이므로, 리터럴로 생성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>함수 이름<ul>
<li>식별자다. 식별자 네이밍 규칙을 준수해야 한다.</li>
<li>함수 몸체 내에서만 참조할 수 있는 식별자다.(밖에서 부르는 식별자를 가지려면 변수 식별자에 할당이 필요하다.)</li>
<li>함수 이름은 생략할 수 있다. 기명함수, 익명 함수.</li>
</ul>
</li>
<li>매개변수 목록<ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고, 쉼표로 구분</li>
<li>각 매개변수에는 지정한 인수가 순서대로 할당. 즉, 매개 변수 목록은 ‘순서’에 의미가 있다.</li>
<li>매개변수는 몸체 내에서 변수와 동일하게 취급.(암묵적으로 선언과 할당을 실행한다.) -&gt; 식별자 네이밍 규칙을 준수해야 한다.</li>
</ul>
</li>
<li>함수 몸체<ul>
<li>실행된 문들을 묶은 코드 블록.</li>
<li>함수 호출에 의해 실행된다.</li>
</ul>
</li>
<li>함수 리터럴도 ‘리터럴’이므로 값으로 평가 가능. 그 값은 ‘객체’이고, 즉, 함수는 객체.</li>
<li>리터럴만 된 코드의 함수를 호출할 수는 없다.(식별자가 없잖아.)</li>
<li>함수 객체 값을 만들기 위한 수단.</li>
<li>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.<h1 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h1></li>
</ul>
<ol>
<li>함수 선언문<ul>
<li>함수 이름을 생략할 수 없다는 것만 빼면 함수 리터럴과 형태가 같다.</li>
<li>차이는 값으로 평가되느냐, 되지 않느냐.</li>
<li>자바스크립트 엔진은 문맥(값이 들어가야 할 자린지 아닌지)에 따라 둘을 구분한다.</li>
<li>함수 선언문의 함수 이름은 자바스크립트 엔진이 암묵적으로 식별자로 생성해 선언, 할당한다.</li>
<li>선언문이므로, 호이스팅된다.</li>
</ul>
</li>
<li>함수 표현식<ul>
<li>자바스크립트의 함수는 객체 타입의 값이므로, 함수를 값처럼 자유롭게 사용할 수 있다.</li>
<li>변수에 함수(리터럴)를 할당하는 모양새.</li>
<li>함수 이름은 생략하는 것이 일반적이다.(호출하는데는 식별자만 변수 식별자만 있으면 되니까.)</li>
<li>호이스팅으로 함수 선언문과 차이를 보인다.</li>
<li>함수를 호출하기 전에 반드시 함수를 선언해야한다는 규칙을, 호이스팅은 무시하므로, 선언문 대신 함수 표현식(var가 아닌)을 사용하는 걸 권장.</li>
</ul>
</li>
<li>Function 생성자 함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Function 함수로 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.</li>
<li>클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.</li>
</ul>
</li>
<li>화살표 함수.<ul>
<li>이후 자세히.<h1 id="함수-호출"><a href="#함수-호출" class="headerlink" title="함수 호출"></a>함수 호출</h1><h1 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h1></li>
</ul>
</li>
</ol>
<ul>
<li>인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.</li>
<li>매개변수는 함수 몸체 내부에서만 참조할 수 있다. 즉, 매개변수의 스코프는 함수 내부다.</li>
<li>매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다.<ul>
<li>인수가 더 적을 때, 전달되지 않은 매개변수는 undefined.</li>
<li>인수가 더 많을 때, 무시.(버려지는 것처럼 보이지만, 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관.)</li>
</ul>
</li>
<li>인수 확인<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(2));        &#x2F;&#x2F; NaN</span><br><span class="line">console.log(add(&#39;a&#39;, &#39;b&#39;)); &#x2F;&#x2F; &#39;ab&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.</li>
<li>자바스크립트는 동적 타입 언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.</li>
<li>따라서, 의도하지 않은 동작을 할 수도 있다.</li>
<li>이 때, 인수 확인이 필요하다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  if (typeof x !&#x3D;&#x3D; &#39;number&#39; || typeof y !&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.</span><br><span class="line">    throw new TypeError(&#39;인수는 모두 숫자 값이어야 합니다.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>타입스크립트를 사용하는 것도 방법.</li>
<li>인수가 전달되지 않은 경우, 단축 평가(or 옵셔널 체이닝 연산자 ?.)를 사용해 매개변수에 기본값을 할당할 수도 있다.</li>
<li>매개변수의 기본값도 사용 가능.<h1 id="매개변수의-최대-개수"><a href="#매개변수의-최대-개수" class="headerlink" title="매개변수의 최대 개수"></a>매개변수의 최대 개수</h1></li>
</ul>
</li>
<li>매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 함수의 사용법을 이해하기 어렵게 만들고 실수를 발생시킬 가능성을 높인다.</li>
<li>또한 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받는다. 즉, 유지보수성이 나빠진다.</li>
<li>이상적인 매개변수 개수는 0개이며 적을 수록 좋다.</li>
<li>매개변수의 개수가 많다는 것은 함수가 여러가지 일을 한다는 증거이므로 바람직하지 않다. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.</li>
<li>매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.</li>
<li>객체를 인수로 전달했을 때, 주의할 것은 부수 효과.<h1 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h1></li>
<li>반환문은 값을 반환하고, 이 값으로 평가되는 함수 호출은 평가식이다.</li>
<li>반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.(이후 문은 무시.)</li>
<li>반환문이 생략되면, 함수 몸체의 마지막 문까지 실행 후, undefined를 반환.</li>
<li>반환문과 뒤의 표현식에 줄바꿈이 있으면 세미콜론이 자동 추가 되어, 아래 쓰인 표현식이 무시된다.<h1 id="참조에-의한-전달과-외부-상태의-변경"><a href="#참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="참조에 의한 전달과 외부 상태의 변경"></a>참조에 의한 전달과 외부 상태의 변경</h1></li>
<li>인수 -&gt; 매개변수 -&gt; 함수 몸체 에서, 원시값은 ‘값에 의한 전달’, 객체는 ‘참조에 의한 전달’</li>
<li>특히 객체를 매개변수로 사용할 경우, 함수 몸체에서 참조값을 통해 객체를 변경할 경우 원본이 훼손된다. -&gt; 부수효과 발생.</li>
<li>이런 변경을 어떻게 추적하겠어.(옵저버 패턴을 통해 객체의 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응?)</li>
<li>이 때, 객체를 불변 객체로 만들어 사용해, 방어적 복사를 통한 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체할 수 있다.</li>
<li>이것도 힘드니까 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는, ‘순수 함수’를 지향하는 게 필요.<h1 id="다양한-함수의-형태"><a href="#다양한-함수의-형태" class="headerlink" title="다양한 함수의 형태"></a>다양한 함수의 형태</h1></li>
</ul>
<ol>
<li>즉시 실행 함수(생성과 동시에 ())<ul>
<li>리터럴을 ()그룹 연산자로 감싼 형태.(값이 들어갈 자리. -&gt; 자바스크립트 엔진이 함수 선언문이 아닌 리터럴로 읽을 수 있도록. -&gt; 다른 연산자도 사용할 수 있지만, 일반적이지 않다.)</li>
<li>감싸지 않으면 엔진이 함수 선언문이라고 읽는다. -&gt; 중괄호 뒤에 세미콜론이 찍히고, -&gt; 뒤의 ()은 그룹 연산자로 읽어, 에러.</li>
<li>즉시 실행하며, 일반 함수처럼 값을 반환할 수 있고, 인수를 전달할 수도 있다.</li>
<li>즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수 있는 변수나 함수 이름의 충동을 방지할 수 있다 -&gt; 전역 변수 사용 억제 방법.</li>
</ul>
</li>
<li>재귀 함수<ul>
<li>함수가 자기 자신을 호출(재귀 호출)할 때, 재귀 호출을 수행하는 함수.</li>
<li>반복되는 처리를 위하 새용한다.</li>
<li>함수 몸체에서, 함수 이름으로 호출한다.</li>
<li>탈출 조건이 반드시 있어야 한다. -&gt; 없으면 스택 오버플로 에러.</li>
<li>따라서, 반복문을 대체할 수 있지만, 주의해서 사용해야 해.</li>
<li>반복문을 사용하는 것보다 직관적으로 이해하기 쉬울 때만 한정적으로 사용.</li>
</ul>
</li>
<li>중첩 함수<ul>
<li>일반적으로 중첩 함수는 외부 함수를 돕는 헬퍼 함수의 역항르 한다.</li>
<li>함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하지만,</li>
<li>호이스팅으로 인해 혼란이 발생할 수 있으므로, if문이나 for문 등의 코드 블록에서 정의하는 것은 바람직하지 않다.</li>
</ul>
</li>
<li>콜백 함수<ul>
<li>함수를 인수로 사용, 매개변수를 통해 함수 안에 함수를(중첩 함수)를 만든다.</li>
<li>공통적으로 수행해야 할 함수(고차함수)에 일부분만 다른 함수들(콜백함수)를 조합해 사용.</li>
<li>고차 함수의 몸체에는 콜백 함수의 호출 시점이 명시.</li>
<li>이 때 필요에 따라 인수를 전달.</li>
<li>콜백 함수가 고차 함수 내부에만 호출된다면, 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.(즉시 실행 함수).</li>
<li>다른 곳에서도 호출할 필요가 있다면, 콜백 함수를 정의한 후, 함수 참조(식별자)를 고차 함수에 전달.</li>
<li>콜백 함수는 비동기 처리, 배열 고차 함수 등에 활용된다.(아직은 뭔지 모름)</li>
</ul>
</li>
<li>순수 함수와 비순수 함수<ul>
<li>순수 함수: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수</li>
<li>비순수 함수:  외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수 -&gt; 외부 상태에 따라 반환값이 달라진다.</li>
<li>함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이라 할 수 있다. 자바스크립트는 멀티 패러다임 언어이므로 객체지향 프로그래밍뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/22/201123-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/201123-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/" class="post-title-link" itemprop="url">201123 객체 리터럴, 원시값과 객체의 비교</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-22 19:10:43 / Modified: 19:11:10" itemprop="dateCreated datePublished" datetime="2020-11-22T19:10:43+09:00">2020-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="객체 리터럴"></a>객체 리터럴</h1><hr>
<h1 id="객체란"><a href="#객체란" class="headerlink" title="객체란?"></a>객체란?</h1><ul>
<li>원시값을 제외한 나머지 값들.</li>
<li>자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든 것이 객체다.</li>
<li>원시값과 달리, 객체는 변경 가능한 값이다.</li>
<li>객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.</li>
<li>모든 값은 프로퍼티 값이 될 수 있다.</li>
<li>함수 역시 값으로 취급할 수 있으므로 프로퍼티 값이 될 수 있고,</li>
<li>프로퍼티 값이 함수일 때, 일반 함수와 구분하기 위해 메서드(method)라 부른다.</li>
<li>프로퍼티는 객체의 ‘상태’를 나타내는 값이고,</li>
<li>메서드는 프로퍼티를 참조하고 조작할 수 있는 ‘동작’이므로</li>
<li>객체는 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.</li>
<li>객체와 함수는 분리할 수 없는 개념이다.</li>
<li>함수로 객체를 생성하기도 하며, 함수 자체가 객체이기도 하다.</li>
<li>프로그래밍 언어 자체에는 순서가 없고 서로 물고 물리는 순환 구조가 있어서 잘 이해되지 않는 개념이 나오면 멈추지 말고 일단은 다음으로 넘어가는 것도 한 가지 방법이다.<h1 id="자바스크립트의-객체-생성-방법"><a href="#자바스크립트의-객체-생성-방법" class="headerlink" title="자바스크립트의 객체 생성 방법"></a>자바스크립트의 객체 생성 방법</h1></li>
</ul>
<ol>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메서드</li>
<li>클래스 (ES6)</li>
</ol>
<ul>
<li>다양한 생성 방법을 지원하지만, 객체 리터럴 외의 생성 방식은 모두 함수를 사용해 객체를 생성한다.</li>
<li>이러한 방법은 함수를 배우고 나서 알아본다.<h1 id="객체-리터럴에-의한-객체-생성"><a href="#객체-리터럴에-의한-객체-생성" class="headerlink" title="객체 리터럴에 의한 객체 생성"></a>객체 리터럴에 의한 객체 생성</h1></li>
<li>가장 일반적이고 간단한 방법</li>
<li>중괄호{} 내에 0개 이상의 프로퍼티를 정의한다.</li>
<li>할당이 이루어지는 시점에 객체 리터럴을 해석해 객체를 생성한다.</li>
<li>중괄호 내에 프로퍼티가 없으면 빈 객체.</li>
<li>중괄호는 코드 블록이 아니고, 값으로 표현되는 표현식. -&gt; 중괄호 뒤에 세미콜론을 붙인다.</li>
<li>객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식이다.</li>
<li>객체 생성과 동시에 프로퍼티를 만들 수 있고,</li>
<li>객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.<h1 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h1></li>
<li>객체를 구성하는 단위. 프로퍼티는 키와 값으로 구성된다. 프로퍼티의 나열은 쉼표,를 사용한다.</li>
<li>프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값.<ul>
<li>프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 하지만, 반드시 식별자 네이밍 규칙을 따라야 하는 것은 아님.</li>
<li>기본적으로 문자열을 사용하므로, ‘’ 로 묶어서 표시하지만,</li>
<li>식별자 네이밍 규칙을 따르는 이름은 따옴표 생략 가능.</li>
<li>문자열로 평가될 수 있는 표현식을 사용해 만들 경우, 표현식을 대괄호[]로 묶어야 한다.</li>
<li>빈 문자열을 사용해도 되지만 권장 안함.</li>
<li>문자열이나 심벌 값 외에 값을 사용하면 암묵적 타입 변환.</li>
<li>예약어도 사용 가능하지만 권장 안함.</li>
<li>이미 존재하는 프로퍼티 키를 중복 선언하면 이전의 값을 덮어씀.(갱신)</li>
<li>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성, 프로퍼티 값 할당.</li>
<li>delete 연산자로 프로퍼티 삭제 가능.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete person.age;</span><br></pre></td></tr></table></figure>
<ul>
<li>존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시.</li>
</ul>
</li>
</ul>
</li>
<li>프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값.<h1 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h1></li>
<li>자바스크립트의 함수는 객체(일급 객체)다.</li>
<li>값으로 취급할 수 있고, 프로퍼티 값으로도 사용 가능.</li>
<li>프로퍼티 값이 함수일 때, 일반 함수와 구분하기 위해 메서드(method)라 부른다.<h1 id="프로퍼티-접근"><a href="#프로퍼티-접근" class="headerlink" title="프로퍼티 접근"></a>프로퍼티 접근</h1></li>
</ul>
<ol>
<li>마침표 표기법: 마침표 프로퍼티 접근 연산자(.)를 사용.</li>
<li>대괄호 표기법: 대괄호 프로퍼티 접근 연산자([])를 사용.</li>
</ol>
<ul>
<li>프로퍼티 키가 식별자 네이밍 규칙을 준수하면 둘 다 사용 가능.</li>
<li>대괄호 표기법에서는 반드시 따옴표로 감싼 문자열로 표시.<ul>
<li>문자열을 다 읽을 수 있는 거니까, 네이밍 규칙을 준수 안한 프로퍼티 키는 대괄호 표기법으로 접근 가능.</li>
</ul>
</li>
<li>아니면 식별자로 해석해 식별자를 찾음.</li>
<li>객체에 존재하지 않는 프로퍼티에 접근하면 undefined.<h1 id="ES6에-추가된-객체-리터럴의-확장-기능"><a href="#ES6에-추가된-객체-리터럴의-확장-기능" class="headerlink" title="ES6에 추가된 객체 리터럴의 확장 기능"></a>ES6에 추가된 객체 리터럴의 확장 기능</h1></li>
</ul>
<ol>
<li>프로퍼티 축약 표현<ul>
<li>프로퍼티 값이 변수이고, 변수 이름을 프로퍼터 키로 사용할 때, 프로퍼티 키를 생략할 수 있다. -&gt; 프로퍼티 키는 변수 이름으로 자동 생성.</li>
</ul>
</li>
<li>계산된 프로퍼티 이름<ul>
<li>문자열 또는 문자열로 평가되는 표현식을 대괄호로 묶어 프로퍼티 키를 생성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj[prefix + &#39;-&#39; + ++i] &#x3D; i;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i,</span><br><span class="line">  [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i,</span><br><span class="line">  [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>메서드 축약 표현<ul>
<li>funktion 키워드를 축약할 수 있다.</li>
<li>메서드 축약 표현으로 정의한 메서드는 일반 메서드와 다르게 동작하는데,</li>
<li>이건 다음에 계속.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="원시값과-객체의-비교"><a href="#원시값과-객체의-비교" class="headerlink" title="원시값과 객체의 비교"></a>원시값과 객체의 비교</h1><ol>
<li>원시값은 변경 불가능한 값. 객체는 변경 가능한 값.</li>
<li>원시값을 할당한 변수(확보된 메모리 공간)에는 실제 값이 저장, 객체를 할당한 변수(확보된 메모리 공간)에는 참조값이 저장.</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달(값에 의한 전달), 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달(참조에 의한 전달).<h1 id="원시값"><a href="#원시값" class="headerlink" title="원시값"></a>원시값</h1></li>
<li>변경 불가능한 값: 불변성<ul>
<li>값 자체를 변경할 수는 없지만, 변수 값은 변경할 수 있다. -&gt; 재할당</li>
<li>상수는 재할당이 금지된 변수. 상수와 변경 불가능한 값이 같은 게 아님.</li>
<li>재할당 외에는 변수 값을 변경할 수 있는 방법이 없다.</li>
</ul>
</li>
<li>문자열과 불변성<ul>
<li>문자열은 유사 배체 객체면서, 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다. 단 변경은 할 수 없다.</li>
</ul>
</li>
<li>값에 의한 전달<ul>
<li>변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)이라 한다.</li>
<li>엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.</li>
<li>값에 의한 전달을 생각할 수 있는 두 가지 방법<ol>
<li>새로운 80을 생성(복사)해서 메모리 주소를 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 다르다.</li>
<li>score의 변수값 80의 메모리 주소를 그대로 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.</li>
</ol>
<ul>
<li>어떤 방식이든 간에,</li>
<li>결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.<h1 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h1></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다.</li>
<li>프로퍼티의 값에도 제약이 없다. -&gt; 원시값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.</li>
<li>원시값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에 따라 크기가 매우 클 수도 있다. 객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이 드는 일이다. -&gt; 객체는 원시값과는 다른 방식으로 동작하도록 설계되어 있다.</li>
</ul>
<ol>
<li>변경 가능한 값<ul>
<li>객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장된다. 변수는 이 참조값을 통해 객체에 접근할 수 있다. -&gt;  “변수는 객체를 참조하고 있다” 또는 “변수는 객체를 가리키고(point) 있다”라고 표현한다.</li>
<li>객체의 값을 변경하면, 참조값은 그대로 두고 참조값이 참조하는 값을 변경.</li>
<li>객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일이다. -&gt; 원시값처럼 이전 값을 복사해서 새롭게 생성한다면 명확하고 신뢰성이 확보되겠지만 객체는 크기가 매우 클 수도 있고, 원시값처럼 크기가 일정하지도 않으며, 프로퍼티 값이 객체일 수도 있어서 복사(deep copy)해서 생성하는 비용이 많이 든다. -&gt; 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다. -&gt; 이러한 구조적 단점에 따른 부작용, 여러 개의 식별자가 하나의 객체를 공유할 수 있다.<ul>
<li>얕은 복사와 깊은 복사<ol>
<li>얕은 복사: 참조값만 복사해 새로운 메모리에 저장하여 쓰고, 객체는 복사없이 사용.</li>
<li>깊은 복사: 객체까지 모두 복사해 참조값과 복사 모두 새로운 메모리를 만듦. -&gt; 완전한 복사본을 만듦.<ul>
<li>둘 다 원본과 참조값은 다름.</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>참조에 의한 전달<ul>
<li>객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조값이 복사되어 전달. 이를 ‘참조에 의한 전달’이라 한다.</li>
<li>얕은 복사.(동일)</li>
<li>따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제)하면 서로 영향을 주고받는다.<h1 id="값에-의한-전달-참조에-의한-전달"><a href="#값에-의한-전달-참조에-의한-전달" class="headerlink" title="값에 의한 전달, 참조에 의한 전달"></a>값에 의한 전달, 참조에 의한 전달</h1></li>
</ul>
</li>
</ol>
<ul>
<li>사실 ‘값에 의한 전달’과 ‘참조에 의한 전달’은 둘 다 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.</li>
<li>다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시값이냐 참조값이냐의 차이만 있을 뿐.</li>
<li>엄격히 말하면, 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있다.</li>
<li>‘공유에 의한 전달’이라는 표현도 있지만, 이 또한 에크마스크립트 사양에 정의된 공식 용어는 아니며, 자바스크립트의 동작 방식을 정확히 설명하지는 못한다.</li>
<li>다만, 전달되는 값의 종류에 원시값인지 참조값인지 구별해서 강조하는 의미에서 “값에 의한 전달”과 “참조에 의한 전달”로 구분하여 부르기로 한다.</li>
<li>자바스크립트에는 포인터(pointer)가 존재하지 않기 때문에 포인터가 존재하는 다른 프로그래밍 언어의 “참조에 의한 전달”과 의미가 정확히 일치하지 않다는 점에 주의.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/19/201119-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%A0%9C%EC%96%B4%EB%AC%B8-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/19/201119-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%A0%9C%EC%96%B4%EB%AC%B8-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80/" class="post-title-link" itemprop="url">연산자, 제어문, 타입 변환, 단축 평가</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-19 19:22:36 / Modified: 19:23:13" itemprop="dateCreated datePublished" datetime="2020-11-19T19:22:36+09:00">2020-11-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1바이트가-8비트인-이유"><a href="#1바이트가-8비트인-이유" class="headerlink" title="1바이트가 8비트인 이유"></a>1바이트가 8비트인 이유</h1><ul>
<li>내가 순서대로 말해볼게, 들어봐.<ol>
<li>1바이트=8비트 라고 결정되지 않은 때가 있었어.</li>
<li>처음 아이디어는 1바이트에 한 글자를 표현할 수 있도록 하고 싶었지.</li>
<li>영어 대소문자와 숫자, 공백과 몇 개의 특수문자, 그 외 출력 불가능한 제어 문자들(?)을 표현하려면 100개 남짓의 가짓수가 필요하겠지?</li>
<li>컴퓨터는 2진수로 값을 저장하니까, 2의 7승(128)이면 다 담을 수 있지.</li>
<li>그래서 1바이트-&gt;표현하고 싶은 글자들 중 하나-&gt;7비트 였는데,</li>
<li>후에 영어가 아닌 다른 언어도 넣고 싶어서 8비트로 확장했어.</li>
<li>그때부터 규격이 정해지고 표준화 됨.</li>
<li>ㅇㅇ?</li>
<li>근데 세상엔 너무 많은 언어가 있잖아.</li>
<li>2의 8승으로 그게 다 표현 안 되지.</li>
<li>그래서,</li>
<li>세계 모든 언어를 같은 방법으로 인코딩하고 싶은 유니코드는, 한 글자를 표현하기 위해 2바이트를 써.</li>
<li>2바이트, 8비트<em>8비트, 2의8승</em>2의8승 = 65536.</li>
<li>더 필요할 거 같은데, 그 이후로 어떻게 됐지?</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/ASCII">https://ko.wikipedia.org/wiki/ASCII</a></li>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C">https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C</a></li>
<li><a target="_blank" rel="noopener" href="https://zepeh.tistory.com/313">https://zepeh.tistory.com/313</a></li>
<li><a target="_blank" rel="noopener" href="https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C">https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C</a></li>
<li><a target="_blank" rel="noopener" href="https://whatisthenext.tistory.com/103">https://whatisthenext.tistory.com/103</a></li>
</ul>
<hr>
<h1 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h1><ul>
<li>하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다.</li>
<li>피연산자: 연산의 대상, 표현식이어야 함,</li>
<li>피연산자와 연산자로 만들어진 문도 값으로 평가될 수 있어 표현식.<h1 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h1></li>
<li>수학적 연산으로 숫자 값을 만든다.</li>
<li>수학적 연산이 불가할 경우, NaN값.</li>
<li>피연산자의 개수에 따라 이항 산술 연산자, 단항 산술 연산자.</li>
</ul>
<ol>
<li>이항 산술 연산자<ul>
<li>+, -, / *, %</li>
<li>새로운 값을 만들어낸다.</li>
<li>피연산자의 값을 변경하는 ‘부수 효과’ 없음.</li>
</ul>
</li>
<li>단항 산술 연산자<ul>
<li>++, –, +, -</li>
<li>++, – 는 피연산자의 값을 변경, ‘부수 효과’.</li>
<li>+는 아무 효과도 없어 보이지만, 숫자 타입이 아닌 값을 숫자 타입으로 바꿈. 단, 피연산자의 값을 변경하지는 않음.</li>
<li>-도 +와 같이 피연산자의 값을 숫자 타입으로 바꿈.</li>
</ul>
</li>
<li>문자열 연결 연산자<ul>
<li>+</li>
<li>피연산자 중 하나가 문자열 타입일 때, 나머지도 문자열로 바꾸고 합침.</li>
<li>문자열 연결 연산자.</li>
<li>단항 산술 연산자의 +, -와 함께, ‘암묵적 타입 변환’을 일으킴.<h1 id="할당-연산자"><a href="#할당-연산자" class="headerlink" title="할당 연산자"></a>할당 연산자</h1></li>
</ul>
</li>
</ol>
<ul>
<li>=, +=, -=, *=, /=, %=, **=</li>
<li>우항의 결과를 좌항의 변수에 할당.</li>
<li>할당문은 값으로 평가되는 표현식인 문.<h1 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h1></li>
<li>좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환.</li>
</ul>
<ol>
<li>동등/일치 비교 연산자<ul>
<li>==, ===</li>
<li>동등 비교 연산자(==)는 암묵적 타입 변환을 통해 두 피연산자의 타입을 일치 시킨 후 비교.</li>
<li>일치 피교 연산자(===)는 암묵적 타입 변환을 하지 않고, 두 피연산자를 비교. 타입이 다르면 false.</li>
<li>일치 피교 연산자로 비교했을 때, NaN값은 자신과 일치하지 않는 유일한 값.</li>
<li>0도 양의 0과 음의 0을 같다고 비교함.</li>
<li>메소드인 Object.is()을 쓰면 +0과 -0도 동일, NaN도 자신과 동일하다고 표시함.</li>
<li>!=, !==</li>
</ul>
</li>
<li>대소 관계 비교 연산자<ul>
<li>&lt;, &gt;, &lt;=, &gt;= <h1 id="삼항-조건-연산자"><a href="#삼항-조건-연산자" class="headerlink" title="삼항 조건 연산자"></a>삼항 조건 연산자</h1></li>
</ul>
</li>
</ol>
<ul>
<li>조건식의 평가 결과(불리언으로 평가)에 따라 반환할 값을 결정.</li>
<li>(조건식) ? (트루일 때 반환 값) : (펄스일 때 반환 값)</li>
<li>조건식을 사용하므로, 조건문.</li>
<li>if…else 문과 유사하게 사용 가능.</li>
<li>단, 삼항 조건 연산자는 값으로 평가 가능, if…else 문은 값으로 평가 불가.</li>
<li>삼항 조건 연산자는 표현식, if…else문은 평가식이 아님.</li>
<li>그래서, 값을 결정해야 한다면 삼항 조건 연산자를 사용하고,</li>
<li>조건에 따라 수행해야 할 문이 많은 경우에는 if…else.<h1 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h1></li>
<li>||, &amp;&amp;, !</li>
<li>!는 피연산자를 불리언 속성으로 변환, 부정하여 반환.</li>
<li>불리언 속성이 아닌 값을 불리언 속성으로 바꿀 수 있다. -&gt; !!값</li>
<li>||, &amp;&amp;는 불리언 값만 반환하는 게 아니야,<ol>
<li>양쪽의 피연산자 중 하나를 반환.</li>
<li>불리언 타입이 아닌 값은 불리언 타입으로 변환하여 평가, 피연산자 중 하나를 반환.</li>
<li>단축 평가<h1 id="쉼표-연산자"><a href="#쉼표-연산자" class="headerlink" title="쉼표 연산자"></a>쉼표 연산자</h1></li>
</ol>
</li>
<li>,</li>
<li>왼쪽부터 평가를 시작해 마지막 피연산자의 값을 반환.<h1 id="그룹-연산자"><a href="#그룹-연산자" class="headerlink" title="그룹 연산자"></a>그룹 연산자</h1></li>
<li>(, )</li>
<li>연산자 우선순위가 가장 높다.</li>
<li>연산자 우선순위를 명시적으로 표시할 수 있다.<h1 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h1></li>
<li>typeof</li>
<li>데이터 타입을 문자열로 반환.</li>
<li>null 타입은 undefined로 반환하는데, 버그임.</li>
<li>선언되지 않은 식별자를 연산하면 undefined를 반환.<h1 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h1></li>
<li>**</li>
<li>Math.pow()</li>
<li>이항 연산자 중에서 우선순위가 가장 높다.</li>
<li>할당 연산자와 함께 쓸 수 있따. **=</li>
<li>음수의 거듭제곱의 경우 음수를 ()로 묶어줘서 사용.<h1 id="그외-연산자"><a href="#그외-연산자" class="headerlink" title="그외 연산자"></a>그외 연산자</h1></li>
<li>?., ??, delete, new, instanceof, in</li>
<li>다른 주제와 연관되어 있으므로, 그때 다시.<h1 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h1></li>
<li>() 가 제일 높고,</li>
<li>그 아래로 단항 산술 연산자</li>
<li>이항 산술 연산자(그 중에 **이 가장 높다.)</li>
<li>비교 연산자</li>
<li>동등/일치 연산자</li>
<li>논리 연산자</li>
<li>삼항</li>
<li>할당</li>
<li>-&gt; 외우기 어려움. (, ) 로 명시적으로 표시가 필요하다.</li>
</ul>
<hr>
<h1 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h1><ul>
<li>위에서 아래로 한 줄씩 진행되는 코드 진행 방향을 제어.</li>
<li>조건문, 반복문</li>
<li>코드 흐름이 왔다갔다 하면 가독성이 떨어지는데, 후에 살펴볼 고차 함수가 이를 해결하려 노력.</li>
<li>하지만 일단 이거부터 해야지.<h1 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h1></li>
<li>0개 이상의 문을 중괄호({, })로 묶은 것, 코드 블록, 블록.</li>
<li>블록문을 하나의 실행 단위로 취급한다.</li>
<li>자체 종결성을 갖기 때문에 뒤에 ;을 붙이지 않는다.</li>
<li>일반적으로 제어문이나 함수에 사용한다.</li>
<li>제어문과 함수의 형식에 중괄호가 있는 게 아니라, 블록문이 따로 있는 거.</li>
<li>그러니까 제어문과 함수에서 한 줄의 문만 있을 땐 블록문을 안 써도 되지.<h1 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h1></li>
<li>조건식의 평가 결과에 따라 블록의 실행을 결정.</li>
<li>if…else문과 switch…case문.</li>
</ul>
<ol>
<li>if…else<ul>
<li>조건식을 불리언 타입으로 평가하여 트루면 if의 블록 실행, 펄스면 else의 블록 실행.</li>
<li>평가된 조건식의 값이 불리언 타입이 아니더라도, 불리언 타입으로 암묵적 변환.</li>
<li>조건식을 추가하고 싶으면 else if를 사용.</li>
<li>삼항 조건 연산자로 바꿔 쓸 수 있다.</li>
</ul>
</li>
<li>switch<ul>
<li>조건식을 평가하여, 그 값과 일치하는 case로 실행 흐름을 옮긴다.</li>
<li>: 이후의 문들을 실행하고,</li>
<li>break로 빠져나간다.<ol>
<li>break가 없을 경우,</li>
<li>가장 아래의 default를 실행.</li>
<li>이것을 폴스루(fall through)라고 한다.</li>
<li>이걸 이용할 수도 있는데,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var year &#x3D; 2000; &#x2F;&#x2F; 2000년은 윤년으로 2월이 29일이다.</span><br><span class="line">var month &#x3D; 2;</span><br><span class="line">var days &#x3D; 0;</span><br><span class="line"></span><br><span class="line">switch (month) &#123;</span><br><span class="line">  case 1: case 3: case 5: case 7: case 8: case 10: case 12:</span><br><span class="line">    days &#x3D; 31;</span><br><span class="line">    break;</span><br><span class="line">  case 4: case 6: case 9: case 11:</span><br><span class="line">    days &#x3D; 30;</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    &#x2F;&#x2F; 윤년 계산 알고리즘</span><br><span class="line">    &#x2F;&#x2F; 1. 연도가 4로 나누어떨어지는 해(2000, 2004, 2008, 2012, 2016, 2020...)는 윤년이다.</span><br><span class="line">    &#x2F;&#x2F; 2. 연도가 4로 나누어떨어지더라도 연도가 100으로 나누어떨어지는 해(2000, 2100, 2200...)는 평년이다.</span><br><span class="line">    &#x2F;&#x2F; 3. 연도가 400으로 나누어떨어지는 해(2000, 2400, 2800...)는 윤년이다.</span><br><span class="line">    days &#x3D; ((year % 4 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D;&#x3D; 0) || (year % 400 &#x3D;&#x3D;&#x3D; 0)) ? 29 : 28;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    console.log(&#39;Invalid month&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>case, default, break 등 다양한 키워드가 사용되고, 폴 스루가 적용되는 등, if…else보다 문법적으로 어려워.</li>
<li>if…else를 쓸 수 있으면 쓰는데, 조건이 너무 많은 경우에는 switch가 가독성이 좋다.<h1 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h1></li>
</ul>
</li>
</ol>
<ul>
<li>조건식이 참일 경우, 거짓이 될 때까지 블록을 반복.</li>
<li>for, while, do…while</li>
</ul>
<ol>
<li>for문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>선언문, 조건식, 증감식은 모두 옵션으로 안 써도 돼. 안 쓰면 무한 루프.</li>
<li>for문 안에 for문으로 중첩 가능.</li>
</ul>
</li>
<li>while 문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (count &lt; 3) &#123;</span><br><span class="line">  console.log(count); &#x2F;&#x2F; 0 1 2</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>블록 안에 if문, break문으로 탈출 가능.</li>
</ul>
</li>
<li>do…while 문<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  console.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; while (count &lt; 3); &#x2F;&#x2F; 0 1 2</span><br></pre></td></tr></table></figure>
<ul>
<li>do를 먼저 실행하므로, 무조건 한 번은 실행.</li>
</ul>
</li>
<li>break 문<ul>
<li>레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출</li>
<li>그 외의 문에서 사용하면 문법 에러.</li>
<li>레이블 문<ul>
<li>식별자가 붙은 문</li>
<li>식별자: 문;</li>
<li>문 앞에 식별자: 를 붙여 이름을 붙인다.</li>
<li>변수처럼 다시 부르기 위한 용도는 아니고, break 문을 사용하기 위한 별칭으로 사용.</li>
</ul>
</li>
<li>레이블 for문(식별자가 달린 for문)을 탈출할 때 유용하지만, 다른 경우는 사용을 권장하지 않아.</li>
<li>그외 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문.</li>
</ul>
</li>
<li>continue 문<ul>
<li>반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동.</li>
<li>반복문 자체를 탈출하지는 않음.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h1><ul>
<li>명시적 타입 변환과 암묵적 타입 변환</li>
<li>숫자 타입, 문자열 타입, 불리언 타입으로 변환.</li>
<li>기존 원시값을 직접 변환하는 것은 아니고, 다른 타입의 새로운 원시값을 생성.</li>
<li>재할당되지도 않고 한번 쓰고 버리므로, 재사용하기 위해서는 할당이 필요.</li>
<li>암묵적 타입 변경은 개발자의 의지가 코드에 명백히 나타나지 않는다.</li>
<li>그러면 데이터 타입의 추측이 어려워지고,</li>
<li>오류를 생산할 가능성이 높아진다.</li>
<li>암묵적 타입 변환이 이루어지지 않도록 코딩할 수도 있겠지만, 가독성 상 암묵적 타입 변환을 잘 이해하는 편이 좋다.<h1 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h1></li>
<li>자바스크립트 엔진이 개발자의 의도와 상관없이 코드의 문맥을 고려해 데이터 타입을 강제 변환.</li>
<li>가급적 에러를 발생시키지 않기 위해</li>
</ul>
<ol>
<li>문자열 타입으로 변환<ul>
<li>문자열 연결 연산자 1 + ‘2’</li>
<li>템플릿 리터널의 표현식 삽입 ‘1 + 1 = &amp;{1 + 1}’ -&gt; 숫자 타입으로 평가된 표현식을 문자열 타입으로 변환.</li>
<li>참고<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 숫자 타입</span><br><span class="line">0 + &#39;&#39;         &#x2F;&#x2F; -&gt; &quot;0&quot;</span><br><span class="line">-0 + &#39;&#39;        &#x2F;&#x2F; -&gt; &quot;0&quot;</span><br><span class="line">1 + &#39;&#39;         &#x2F;&#x2F; -&gt; &quot;1&quot;</span><br><span class="line">-1 + &#39;&#39;        &#x2F;&#x2F; -&gt; &quot;-1&quot;</span><br><span class="line">NaN + &#39;&#39;       &#x2F;&#x2F; -&gt; &quot;NaN&quot;</span><br><span class="line">Infinity + &#39;&#39;  &#x2F;&#x2F; -&gt; &quot;Infinity&quot;</span><br><span class="line">-Infinity + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;-Infinity&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 타입</span><br><span class="line">true + &#39;&#39;  &#x2F;&#x2F; -&gt; &quot;true&quot;</span><br><span class="line">false + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;false&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 타입</span><br><span class="line">null + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;null&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; undefined 타입</span><br><span class="line">undefined + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 심벌 타입</span><br><span class="line">(Symbol()) + &#39;&#39; &#x2F;&#x2F; -&gt; TypeError: Cannot convert a Symbol value to a string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 타입</span><br><span class="line">(&#123;&#125;) + &#39;&#39;           &#x2F;&#x2F; -&gt; &quot;[object Object]&quot;</span><br><span class="line">Math + &#39;&#39;           &#x2F;&#x2F; -&gt; &quot;[object Math]&quot;</span><br><span class="line">[] + &#39;&#39;             &#x2F;&#x2F; -&gt; &quot;&quot;</span><br><span class="line">[10, 20] + &#39;&#39;       &#x2F;&#x2F; -&gt; &quot;10,20&quot;</span><br><span class="line">(function()&#123;&#125;) + &#39;&#39; &#x2F;&#x2F; -&gt; &quot;function()&#123;&#125;&quot;</span><br><span class="line">Array + &#39;&#39;          &#x2F;&#x2F; -&gt; &quot;function Array() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>숫자 타입으로 변환<ul>
<li>+를 제외한 이항 산술 연산자 -,*,/,%</li>
<li>단항 산술 연산자 +</li>
<li>비교 연산자 &gt;,&lt; -&gt; 크기를 비교에 불리언 값을 반환. 크기를 비교하려면 피연산자 모두 숫자 타입이어야지.</li>
<li>참고<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 문자열 타입</span><br><span class="line">+&#39;&#39;       &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+&#39;0&#39;      &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+&#39;1&#39;      &#x2F;&#x2F; -&gt; 1</span><br><span class="line">+&#39;string&#39; &#x2F;&#x2F; -&gt; NaN</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 타입</span><br><span class="line">+true     &#x2F;&#x2F; -&gt; 1</span><br><span class="line">+false    &#x2F;&#x2F; -&gt; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 타입</span><br><span class="line">+null     &#x2F;&#x2F; -&gt; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; undefined 타입</span><br><span class="line">+undefined &#x2F;&#x2F; -&gt; NaN</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 심벌 타입</span><br><span class="line">+Symbol() &#x2F;&#x2F; -&gt; ypeError: Cannot convert a Symbol value to a number</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 타입</span><br><span class="line">+&#123;&#125;             &#x2F;&#x2F; -&gt; NaN</span><br><span class="line">+[]             &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+[10, 20]       &#x2F;&#x2F; -&gt; NaN</span><br><span class="line">+(function()&#123;&#125;) &#x2F;&#x2F; -&gt; NaN</span><br></pre></td></tr></table></figure>
<ul>
<li>객체, 빈 배열이 아닌 배열, undefined는 NaN으로 반환</li>
</ul>
</li>
</ul>
</li>
<li>불리언 타입으로 변환<ul>
<li>if문, for문, 삼항 조건 연산자 등의 조건식</li>
<li>falsy 값 여섯 개<ol>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>’’ (빈 문자열)</li>
</ol>
</li>
<li>나머지는 모두 truthy값<h1 id="명시적-타입-변환"><a href="#명시적-타입-변환" class="headerlink" title="명시적 타입 변환"></a>명시적 타입 변환</h1></li>
</ul>
</li>
</ol>
<ul>
<li>개발자의 의도에 따라 명시적으로 타입을 변경</li>
<li>빌트인 생성자 함수를 new 연산자 없이 호출하는 방법, 빌트인 메서드를 사용, 암묵적 타입 변환을 이용.</li>
</ul>
<ol>
<li>문자열 타입으로 변환<ol>
<li>String(1);</li>
<li>(1).toString();</li>
<li>1 + ‘’;</li>
</ol>
</li>
<li>숫자 타입으로 변환<ol>
<li>Number(‘0’);</li>
<li>parseInt(‘0’);</li>
<li>+’0’;</li>
</ol>
</li>
<li>불리언 타입으로 변환<ol>
<li>Boolean(‘x’);</li>
<li>!!’x’;</li>
</ol>
</li>
</ol>
<hr>
<h1 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h1><ul>
<li>논리 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Cat&#39; &amp;&amp; &#39;Dog&#39; &#x2F;&#x2F; -&gt; &quot;Dog&quot;</span><br></pre></td></tr></table></figure></li>
<li>논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환.</li>
<li>이 단축 평가로 if문을 대체할 수 있다.</li>
<li>if문의 조건이 truthy값일 때 무얼 해야 한다면 &amp;&amp; -&gt; 앞의 피연산자가 트루일 때, 뒤 피연산자를 반환하니까.</li>
<li>if문의 조건이 falsy값일 때 무얼 해야 한다면 || -&gt; 앞의 피연산자가 펄스일 때, 뒤 피연산자를 반환하니까.<ul>
<li>삼항 조건 연산자는 if…else문을 대체할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (done) message &#x3D; &#39;완료&#39;;</span><br><span class="line">else      message &#x3D; &#39;미완료&#39;;</span><br><span class="line">console.log(message); &#x2F;&#x2F; 완료</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if...else 문은 삼항 조건 연산자로 대체 가능하다.</span><br><span class="line">message &#x3D; done ? &#39;완료&#39; : &#39;미완료&#39;;</span><br><span class="line">console.log(message); &#x2F;&#x2F; 완료</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>객체와 함수에서의 단축 평가 사용<ol>
<li>객체를 가리키기를 기대하는 변수가 null 또는 undefined이 아닌지 확인하고 프로퍼티를 참조할 때.<ul>
<li>값이 null, undefined인 변수를 객체인 줄 알고 프로퍼티를 참조하면, 타입 에러TypeError, 프로그램 강제 종료.</li>
<li>이 때, &amp;&amp; 단축 평가를 사용하는 거지.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var elem &#x3D; null;</span><br><span class="line">var value &#x3D; elem &amp;&amp; elem.value;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>함수 매개변수에 기본값을 설정할 때.<ul>
<li>함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다. -&gt; 에러</li>
<li>이 때, || 단축 평가를 먼저 하고 함수 내용을 쓰는 거지.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getStringLength(str) &#123;</span><br><span class="line">  str &#x3D; str || &#39;&#39;;</span><br><span class="line">  return str.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>인수를 전달 받지 못한 경우, str은 false가 되고, 뒤 피연산자인 ‘’를 반환.<h1 id="옵셔널-체이닝-연산자"><a href="#옵셔널-체이닝-연산자" class="headerlink" title="옵셔널 체이닝 연산자"></a>옵셔널 체이닝 연산자</h1></li>
</ul>
</li>
</ol>
</li>
<li>?.</li>
<li>좌항의 피연산자가 null 또는 undefined일 경우, undefined를 반환.</li>
<li>그렇지 않으면 우항의 프로퍼티 참조를 계속.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; elem?.value;</span><br></pre></td></tr></table></figure></li>
<li>이전에는 &amp;&amp; 단축 평가를 사용했다.</li>
<li>&amp;&amp; 단축 평가는 null, undefined 외에도 falsy값이면 우항의 프로퍼티 참조를 계속 하는데,</li>
<li>falsy값인 0이나 ‘’(빈 문자열)은 객체로 평가될 때도 있어서 오류를 일으킴<h1 id="null-병합-연산자"><a href="#null-병합-연산자" class="headerlink" title="null 병합 연산자"></a>null 병합 연산자</h1></li>
<li>좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고,</li>
<li>그렇지 않으면 좌항의 피연산자를 반환.</li>
<li>변수의 기본값을 설정할 때 유용.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; null ?? &#39;default string&#39;;</span><br></pre></td></tr></table></figure></li>
<li>이전에는 || 연산자를 써서 사용했음</li>
<li>이거 뭔지 잘 모르겠는데?</li>
</ul>
<hr>
<h1 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h1><ol>
<li>표준 빌트인 생성자 함수와 빌트인 메서드<ul>
<li>표준 빌트인(built-in) 생성자 함수와 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 함수이다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이며 new 연산자와 함께 호출한다. 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 빌트인 객체의 메서드다.</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bg-shorthand.github.io/2020/11/17/201117-%EB%B3%80%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bg-shorthand">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bg-shorthand-blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/201117-%EB%B3%80%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/" class="post-title-link" itemprop="url">201117- 변수, 표현식과 문, 데이터 타입</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-17 19:43:50 / Modified: 19:44:14" itemprop="dateCreated datePublished" datetime="2020-11-17T19:43:50+09:00">2020-11-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><ul>
<li>하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름<ol>
<li>아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고 그 결과를 출력(output)하는 것이 전부다.</li>
<li>변수는 그 데이터를 관리하기 위한 핵심 개념<h2 id="변수가-필요한-이유"><a href="#변수가-필요한-이유" class="headerlink" title="변수가 필요한 이유"></a>변수가 필요한 이유</h2></li>
</ol>
</li>
</ul>
<ol>
<li>데이터 관리는 값을 메모리셀에 저장하는 것.</li>
<li>근데 그 메모리셀에 메모리 주소로 직접 접근하는 건 위험해.</li>
<li>실수로 운영체제가 사용하고 있는 메모리를 수정하거나 지우면 어떡해?</li>
<li>그러니까 직접 접근하지 않고,</li>
<li>메모리 공간을 식별하기 위한 이름을 붙여 관리.</li>
<li>그게 변수임.<ul>
<li>따라서 변수는, 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>
<li>프로그래밍 언어에서 값을 저장하고 참조(읽어 들이는)하는 메커니즘으로,</li>
<li>값의 위치를 가리키는 상징적인 ‘이름’</li>
<li>메모리 주소가 아닌 다른 명명을 한다는 것은,</li>
<li>사람이 이해할 수 있는 언어로 저장된 값의 의미를 명확히 할 수 있다는 것.</li>
<li>명확한 네이밍으로 코드를 이해하기 쉽게 해야겠지?</li>
<li>협업과 품질 향상에 도움<h2 id="할당과-참조"><a href="#할당과-참조" class="headerlink" title="할당과 참조"></a>할당과 참조</h2></li>
</ul>
</li>
<li>할당: 변수에 값을 저장하는 것</li>
<li>참조: 변수에 저장된 값을 읽어 들이는 것<h2 id="식별자"><a href="#식별자" class="headerlink" title="식별자"></a>식별자</h2></li>
</ol>
<ul>
<li>어떤 값을 구별해서 식별할 수 있는 고유한 이름</li>
<li>변수에서만 사용되는 용어가 아니라, 변수, 함수, 클래스 등의 이름을 모두 지칭함.(자바스크립트에서는 함수도 값)</li>
<li>메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름<ol>
<li>변수의 식별자는 메모리 주소와 매핑(그래야 거기 저장된 값을 찾지)</li>
<li>네이밍 규칙을 준수해야 함<h2 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h2></li>
</ol>
</li>
<li>변수를 생성하는 것.</li>
<li>값을 저장하기 위한 메모리 공간을 확보하고, 그 주소에 변수 이름을 연결,</li>
<li>값을 저장할 수 있게 준비하는 것.</li>
<li>변수를 사용하려면 꼭 필요해. 선언하지 않은 식별자에 접근하면 참조 에러(ReferenceError)<ol>
<li>확보된 메모리 공간은 해제되기 전까지 보호되므로, 안전하게 사용 가능.</li>
<li>var, let, const 키워드를 사용.</li>
<li>변수 선언에 의해 준비된 메모리 공간에는, undefined 라는 값이 암묵적으로 할당</li>
<li>즉, 변수 선언은 두 단계를 거침<ol>
<li>선언 단계: 메모리 공간 확보, 변수 이름 연결, 자바스크립트 엔진에 변수의 존재를 알림.</li>
<li>초기화 단계: 암묵적으로 undefined라는 값을 할당.</li>
</ol>
</li>
<li>초기화 단계를 거치지 않으면, 이전에 저장되어 있던 값(쓰레기 값)이 남아 있을 수 있다.<h2 id="변수-선언의-실행-시점"><a href="#변수-선언의-실행-시점" class="headerlink" title="변수 선언의 실행 시점"></a>변수 선언의 실행 시점</h2></li>
</ol>
</li>
<li>변수 선언은 런타임 이전 단계에서 먼저 실행됨.<ol>
<li>자바스크립트 엔진은 소스코드를 실행하기 앞서 소스코드 평가 과정을 거침.</li>
<li>이 과정에서 변수 선언을 포함한 모든 선언문을 먼저 실행.</li>
<li>따라서, 변수 선언이 어느 위치에 있든 변수 참조 가능</li>
<li>이처럼 변수 선언문이 선두로 끌어올려지는 것처럼 동작하는 자바스크립트 특유의 동작을 ‘호이스팅’이라고 함<h2 id="변수-선언과-할당의-단축-그리고-호이스팅"><a href="#변수-선언과-할당의-단축-그리고-호이스팅" class="headerlink" title="변수 선언과 할당의 단축, 그리고 호이스팅"></a>변수 선언과 할당의 단축, 그리고 호이스팅</h2></li>
</ol>
</li>
</ul>
<ol>
<li>변수 선언과 할당은 하나의 문으로 단축해 쓸 수 있음.</li>
<li>하지만 동작은 나눠서 해.</li>
<li>호이스팅에 의해 변수 선언’만’ 먼저 실행</li>
<li>근데 말이야,</li>
<li>할당은 이전의 undefined 값을 지우고 할당 하는 게 아니라, 새로운 메모리 공간을 확보하고 거기에 저장(이게 무슨 의미지? 선언과 할당이 명확히 구분되어 동작한단 의미?)<h2 id="값의-재할당"><a href="#값의-재할당" class="headerlink" title="값의 재할당"></a>값의 재할당</h2></li>
<li>var 키워드로 선언한 변수는 값이 변할 수 있는 변수.</li>
<li>할당과 마찬가지로 새로운 메모리 공간을 확보하고 거기에 저장</li>
<li>불필요해진 이전의 메모리 공간은 가비지 콜렉터에 의해 자동 해제<ul>
<li>가비지 콜렉터: 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release)하는 기능</li>
<li>가비지 콜렉터가 내장된 언어를 ‘매니지드 언어’, 없는 언어를 ‘언매니지드 언어’라고 함.</li>
<li>매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다. 일정한 생산성을 확보할 수 있지만, 성능 면에서는 손실을 감수할 수밖에 없다.</li>
<li>언매니지드 언어는 개발자가 직접 메모리를 할당, 해제할 수 있는 메모리 제어 기능을 제공. 개발자의 역량에 따라 최적의 성능을 기대할 수 있지만, 반대의 경우 폭망.<h2 id="식별자-네이밍-규칙"><a href="#식별자-네이밍-규칙" class="headerlink" title="식별자 네이밍 규칙"></a>식별자 네이밍 규칙</h2></li>
</ul>
</li>
<li>식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.</li>
<li>단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.</li>
<li>예약어는 식별자로 사용할 수 없다.</li>
<li>유니코드 문자 사용으로 한글 등도 사용가능하지만 권장 안함</li>
<li>대소문자를 구분함</li>
<li>명확한 의미의 이름을 사용.</li>
<li>네이밍 컨벤션은 어떤 것을 사용해도 좋으나, 통일은 해야지.</li>
<li>일반적으로, 변수나 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용<h3 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h3></li>
<li>키워드: 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행</li>
<li>예약어: 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. 자바스크립트의 예약어는 다음과 같다.<ul>
<li>await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* switch this throw true try typeof var void while with yield*</li>
<li><ul>
<li>식별자로 사용 가능하나 Strict Mode에서는 사용 불가</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="표현식과-문"><a href="#표현식과-문" class="headerlink" title="표현식과 문"></a>표현식과 문</h1><h2 id="값"><a href="#값" class="headerlink" title="값"></a>값</h2><ul>
<li>식(표현식, expression)이 평가(evaluate)되어 생성된 결과<ol>
<li>‘표현식’을 ‘평가’하다</li>
<li>변수에 할당되는 것이 ‘값’<h2 id="값을-생성하는-방법"><a href="#값을-생성하는-방법" class="headerlink" title="값을 생성하는 방법"></a>값을 생성하는 방법</h2></li>
</ol>
</li>
</ul>
<ol>
<li>리터럴<ul>
<li>사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(‘’, “”, ., [], {}, // 등)를 사용해 값을 생성하는 표기 방식</li>
<li>자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성. -&gt; 리터럴은 값을 생성하기 위해 미리 약속된 표기법</li>
<li>리터럴을 통해 생성할 수 있는 값<ol>
<li>정수 리터럴 (ex. 100)</li>
<li>부동소수점 리터럴 (ex. 1.5)</li>
<li>2진수 리터럴 (ex. 0b01000001 -&gt; 0b로 시작)</li>
<li>8진수 리터럴 (ex. 0o101 -&gt; 0o로 시작)</li>
<li>16진수 리터럴 (ex. 0x41 -&gt; 0x로 시작)</li>
<li>문자 리터럴 (ex. ‘hello’ “world”)</li>
<li>불리언 리터럴 (ex. true false)</li>
<li>null 리터럴</li>
<li>undefined 리터럴</li>
<li>객체 리터럴 (ex. { name: ‘Lee’, address: ‘Seoul’ })</li>
<li>배열 리터럴 (ex. [ 1, 2, 3 ])</li>
<li>함수 리터럴 (ex. function() {})</li>
<li>정규표현식 리터럴 (ex. /[A-Z]+/g)</li>
</ol>
</li>
</ul>
</li>
<li>표현식 <ul>
<li>값으로 평가될 수 있는 문(statement)</li>
<li>값으로 평가되면 표현식 -&gt; 리터럴도 값으로 평가되므로, 리터럴도 표현식이다. -&gt; 식별자 ‘참조’ 역시 값으로 평가되므로 표현식</li>
<li>표현식과 값은 동치, 즉 표현식은 값처럼 사용될 수 있다 -&gt; 문법적으로 값이 위치해야 할 위치에 표현식이 위치 가능.<h2 id="문-statement"><a href="#문-statement" class="headerlink" title="문(statement)"></a>문(statement)</h2></li>
</ul>
</li>
</ol>
<ul>
<li>프로그램을 구성하는 기본 단위이자 최소 실행 단위</li>
<li>문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍<ol>
<li>문은 여러 토큰으로 이루어진다.<ul>
<li>토큰: 문법적 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</li>
<li>키워드, 식별자, 연산자, 리터럴, 세미콜론 따위</li>
</ul>
</li>
<li>문은 ‘명령문’이라고도 부른다 -&gt; 문이 실행되면 명령이 실행되고, 무언가 일어남.</li>
<li>선언문, 할당문, 조건문, 반복문 등으로 구분</li>
<li>세미콜론(;)<ul>
<li>문의 종료를 표시</li>
<li>자바스크립트 엔진은 세미콜론으로 문의 종료를 파악하고 순차적으로 실행</li>
<li>단, 문을 중괄호로 묶은 블록 뒤에는 세미콜론 표시 안함 -&gt; 코드 블록은 언제나 자체 종결성을 갖기 때문</li>
<li>세미콜론은 생략 가능. 자바스크립트 엔진의 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문<h2 id="표현식과-문-1"><a href="#표현식과-문-1" class="headerlink" title="표현식과 문"></a>표현식과 문</h2></li>
</ul>
</li>
</ol>
</li>
<li>표현식은 문의 일부분일 수도, 그 자체로 문일 수도 있다.</li>
<li>문이 값으로 평가 되면 표현식. 아닐 수도 있지</li>
<li>확인하는 가장 간단한 방법은 문을 변수에 할당해 보는 것. -&gt; 값으로 평가되는 표현식이면 할당이 될 거고, 값으로 평가되지 않으면 에러.<h2 id="용어-1"><a href="#용어-1" class="headerlink" title="용어"></a>용어</h2></li>
</ul>
<ol>
<li>완료 값: 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 완료 값이라 한다. 완료 값은 표현식의 평가 결과가 아니다.</li>
</ol>
<hr>
<h1 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h1><ul>
<li>값의 종류</li>
<li>원시 타입: 숫자, 문자열, 불리언, undefined, null, 심벌</li>
<li>객체 타입: 객체, 함수, 배열 등 (함수도 값이다!)<h2 id="원시-타입"><a href="#원시-타입" class="headerlink" title="원시 타입"></a>원시 타입</h2></li>
<li>변경 불가능한 값</li>
<li>변수에 다른 원시타입을 할당하는 경우는 기존의 값이 변경되는게 아니라 새로운 값이 생성되어 할당되는 것.<ol>
<li>숫자 타입<ul>
<li>자바스크립트는 정수와 실수를 구분하지 않고 하나의 숫자 타입만 제공</li>
<li>2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않으므로, 이들 값을 참조하면 모두 10진수로 해석</li>
<li>숫자 타입의 세 가지 특별한 값<ol>
<li>10/0 -&gt; infinity: 양의 무한대</li>
<li>10/-0 -&gt; -infinity: 음의 무한대</li>
<li>1*”string” -&gt; NaN: 산술 연산 불가(NAN, Nan 등과 다름. 자바스크립트 엔진은 대소문자를 구별하므로, 이와 같은 표현은 식별자로 해석)</li>
</ol>
</li>
</ul>
</li>
<li>문자열 타입<ul>
<li>유니코드 문자로, 전 세계 대부분의 문자를 표현 가능</li>
<li>‘’, “”, `` 으로 감싸 표현 가능. 일반적으론 ‘’</li>
<li>키워드, 식별자 등과 구분하기 위해 감싸서 표현</li>
<li>자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다</li>
<li>문자열 연산자 + 로 연결 가능</li>
<li>템플릿 리터럴<ul>
<li>멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능을 제공</li>
<li>런타임에 문자열로 변환되어 처리</li>
<li>백틱(``)을 사용해 표현<ol>
<li>이스케이프 시퀀스를 사용하지 않고도 줄바꿈, 공백 등이 그대로 적용</li>
<li>${ } 을 통해 표현식 삽입 가능. 안의 표현식은 강제로 문자열로 바뀜(표현식 삽입은 반드시 템플릿 리터럴 에서만. 일반 문자열에서는 ${}도 문자열로 취급)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>불리언<ul>
<li>true, false</li>
</ul>
</li>
<li>undefined<ul>
<li>var 키워드로 선언한 변수는 undefined 로 암묵적 초기화</li>
<li>엔진이 변수를 초기화 하는데 쓰는 undefined를 개발자가 의도적으로 할당하면 취지와 어긋나,</li>
<li>권장하지 않음.</li>
<li>변수에 값이 없다는 걸 명시하고 싶을 땐, null을 써</li>
</ul>
</li>
<li>null<ul>
<li>변수에 값이 없다는 걸 명시</li>
<li>이전에 할당 되어 있던 값에 대한 참조를 명시적으로 제거</li>
<li>값은 가비지 가비지 콜렉터가 지움</li>
</ul>
</li>
<li>symbol 타입<ul>
<li>다른 값과 중복되지 않는 유일무이한 값</li>
<li>주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용<h2 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h2></li>
</ul>
</li>
</ol>
</li>
<li>데이터는 크기가 정해져 있지 않고 변수에 할당될 때 값이 직접 해당 변수에 저장될 수 없으며, 변수에는 데이터에 대한 참조만 저장된다. 참조는 참조 타입 데이터의 주소이지 해당 데이터의 값이 아니다.</li>
<li>객체에 대해서는 후에 자세히 알아볼 텐데, 중요한 것은 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것.</li>
<li>이거 궁금한데, 일단 원시 타입 여섯 개의 데이터 타입 외의 값은 모두 객체<h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2></li>
</ul>
<ol>
<li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해<h2 id="동적-타입-언어인-자바스크립트"><a href="#동적-타입-언어인-자바스크립트" class="headerlink" title="동적 타입 언어인 자바스크립트"></a>동적 타입 언어인 자바스크립트</h2></li>
<li>정적 타입 언어와 동적 타입 언어<ul>
<li>정적 타입 언어: 변수를 선언할 때, 데이터 타입을 먼저 선언 -&gt; 컴파일 때 타입이 맞는지를 확인하고, 안 맞으면 에러, -&gt; 더욱 안정적인 코드의 구현 가능</li>
<li>동적 타입 언어: 데이터 타입 선언이 따로 없음, 값에 따라 데이터 타입이 결정<ul>
<li>할당에 의해 타입이 결정(타입 추론)</li>
<li>재할당으로 언제든 변수의 타입이 바뀔 수 있다-&gt; 동적 타입 언어</li>
<li>변수는 기본적으로 타입을 갖지 않지만, 연결된 값에 따라 타입을 갖게 됨</li>
<li>변수에 자유롭게 할당을 할 수 있어 편리하지만, 단점이 있지</li>
</ul>
</li>
</ul>
</li>
<li>동적 타입 언어의 단점<ul>
<li>동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다</li>
<li>개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다</li>
<li>유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어진다</li>
</ul>
</li>
<li>단점으로 인해 주의해야 할 점<ul>
<li>변수는 꼭 필요한 경우에 한해 제한적으로 사용</li>
<li>변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제</li>
<li>전역 변수는 최대한 사용하지 않도록</li>
<li>변수보다는 상수를 사용해 값의 변경을 억제</li>
<li>변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍<h2 id="용어-2"><a href="#용어-2" class="headerlink" title="용어"></a>용어</h2></li>
</ul>
</li>
<li>이스케이프 시퀀스: 문자열에서, 줄바꿈 등의 공백(white space)을 표현하는 방법. (ex. \0)</li>
<li>라인 피드와 캐리지 리턴<ul>
<li>라인 피드(LF, Line Feed): 커서를 정지한 상태에서 종이를 한 줄 올리는 것</li>
<li>캐리지 리턴(CR, Carriage Return): 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것</li>
<li>개행 방식의 차이</li>
<li>운영체제마다 다른 개행 방식을 따르는데,</li>
<li>대부분의 텍스트 에디터는 운영체제에 맞게 개행 방식을 바꿔줘</li>
<li>자바스크립트에서 라인 피드와 캐리지 리턴은 모두 개행을 의미한다. 하지만 캐리지 리턴(\r)으로 개행하는 경우는 거의 없고 일반적으로 라인 피드(\n)를 사용해 개행한다.</li>
</ul>
</li>
<li>트레이드 오프: 두 개의 정책 목표 가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적 관계</li>
<li>은 탄환: 고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bg-shorthand</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bg-shorthand</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
